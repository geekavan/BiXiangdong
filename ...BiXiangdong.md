* [02](#02)
    * [github中md编写注意事项](#github中md编写注意事项)
    * [关键字](#02_01关键字)
    * [标识符](#02_02标识符)
    * [负数的进制](#02_08负数的进制)
    * [自动类型提升与强制转换_类型运算细节](#02_11_13自动类型提升与强制转换_类型运算细节)
    * [算术运算符_1](#02_14算术运算符_1)
    * [算术运算符_2](#02_15算术运算符_2_赋值运算符)
    * [赋值运算符](#赋值运算符)
* [03](#03)
    * [逻辑运算符_位运算符](#03_02_03逻辑运算符_位运算符)
    * [异或运算](#异或运算)
    * [位运算符](#03_04_05_06位运算符)
    * [for语句](#03_22_23for语句)
    * [while与for语句最简单的无限循环表现形式](#while与for语句最简单的无限循环表现形式)
* [04](#04)
    * [For循环嵌套练习-99乘法表&转义字符](#04_01_04For循环嵌套练习-99乘法表_转义字符)
    * [break&continue](#04_01_06break_continue)
    * [堆栈](#04_03_04_05_06_07堆栈)
    * [数组常见问题](#数组常见问题)
* [复习练习题](#复习练习题来源Java程序员面试笔试宝典)
* [05](#05)
    * [Java数组的三种定义格式](#05_01Java数组的三种定义格式)
    * [常见排序算法](#05_04_05常见排序算法)
    * [折半查找](#05_09折半查找)
    * [进制的转换_查表法](#05_11_12进制的转换_查表法)
* [06](#06)
    * [成员变量和局部变量的区别](#06_08成员变量和局部变量的区别)
    * [private关键字](#06_14private关键字)
    * [python中的set与get方法](#python中的set与get方法)
* [07](#07)
    * [构造函数细节](#07_06构造函数细节)
    * [python为什么不支持函数重载](#python为什么不支持函数重载)
    * [this关键字](#07_07_08this关键字)
    * [static关键字特点及注意事项](#07_11_13static关键字特点及注意事项)
    * [成员变量和静态变量的区别](#07_12成员变量和静态变量的区别)
    * [static关键字_内存图解](#07_15static关键字_内存图解)
    * [静态代码块_构造代码块_局部代码块](#07_17_18静态代码块_构造代码块_局部代码块)
* [08](#08)
    * [单例设计模式](#08_04_06单例设计模式)
    * [数组工具类中静态的使用_文档的使用](#08_02_03数组工具类中静态的使用_文档的使用)
        * [阶段一____](#阶段一____)
        * [阶段二____函数](#阶段二____函数)
        * [阶段三____类](#阶段三____类)
        * [阶段四____静态](#阶段四____静态)
        * [阶段五____私有化构造函数](#阶段五____私有化构造函数)
        * [阶段六____文档的使用](#阶段六____文档的使用)
    * [Java中的单继承](#08_08Java中的单继承)
    * [子父类中的成员变量特点及内存图解](#08_10_11子父类中的成员变量特点及内存图解)
    * [子父类中的成员函数特点](#08_12子父类中的成员函数特点)
* [09](#09)
    * [一个对象的实例化过程](#09_01_02_03一个对象的实例化过程)
    * [final关键字](#09_04final关键字)
    * [抽象类的特点和细节](#09_05_06_07抽象类的特点和细节)
    * [接口的定义与实现](#09_09_10接口的定义与实现)
        * [接口的定义](#09_09接口的定义)
        * [接口的实现](#09_10接口的实现)
    * [接口的多实现_接口之间的多继承](#09_11_12接口的多实现_接口之间的多继承)
* [10](#10)
    * [多态的好处](#10_03多态的好处)
    * [多态转型](#10_05_06多态转型)
    * [多态下的成员变量_成员函数非静态_静态函数](#10_08_09_10多态下的成员变量_成员函数非静态_静态函数)
        * [多态下的成员变量](#10_08多态下的成员变量)
        * [多态下的成员函数非静态](#10_09多态下的成员函数非静态)
        * [多态下的静态函数](#10_10多态下的静态函数)
        * [总结](#总结)
    * [内部类概述](#10_11内部类概述)
        * [内部类编译后生成的.class文件](#内部类编译后生成的.class文件)
        * [内部类访问的特点](#内部类访问的特点)
        * [内部类修饰符](#10_12内部类修饰符)
        * [内部类细节](#10_13内部类细节)
        * [匿名内部类](#10_15_16_17匿名内部类)
* [11](#11)
    * [异常体系](#11_02异常体系)
    * [异常的抛出](#11_03_04_05异常的抛出)
    * [异常的捕捉](#11_06_07_08异常的捕捉)
    * [finally](#11_09finally)
    * [异常的应用](#11_10异常的应用)
    * [异常的注意事项](#11_11异常的注意事项)
    * [Object](#11Object)
        * [equals](#equals)
        * [hasCode](#hasCode)
        * [getClass](#getClass)
        * [toString](#toString)

* [12](#12)
    * [包概述](#12_01包概述)
    * [包与包之间的访问与import关键字](#12_02_03包与包之间的访问_import关键字)
    * [Jar工具](#12_04Jar工具)
    * [练习4](#练习4_01)
        * [习题7](#习题7)
        * [习题8](#习题8)
        * [习题9](#习题9)
        * [习题11](#习题11)
        * [习题13](#习题13)
        * [习题14](#习题14)
        * [习题16](#习题16)
        * [习题18](#习题18)
        * [习题20](#习题20)
    * [多线程概述](#12_01_02_03_04多线程概述)
    * [Thread类](#12_05Thread类)
    * [Thread类中的方法及线程名称](#12_06Thread类中的方法及线程名称)

* [13](#13)
    * [创建线程的第二种方式](#13_09创建线程的第二种方式)
    * [多线程_卖票示例](#13_12多线程_卖票示例)
        * [通过继承Thread类实现](#通过继承Thread类实现)
        * [通过Runnable接口实现](#通过Runnable接口实现)
    * [线程安全问题](#13_13线程安全问题)
    * [线程安全问题产生的原因](#13_14线程安全问题产生的原因)
    * [同步代码块_同步的好处和弊端_同步的前提](#13_15_16_17同步代码块_同步的好处和弊端_同步的前提)
    * [同步函数_验证同步函数的锁_验证静态同步函数的锁](#13_18_19_20同步函数_验证同步函数的锁_验证静态同步函数的锁)
        * [代码段1_非静态同步方法持有的锁为this](#代码段1_非静态同步方法持有的锁为this)
        * [代码段2_静态方法持有的锁为静态方法所属的字节码文件对象](#代码段2_静态方法持有的锁为静态方法所属的字节码文件对象)
        * [代码段3_检验](#代码段3_检验)
    * [单例模式中涉及的线程安全问题](#13_21单例模式中涉及的线程安全问题)
    * [死锁](#13_22死锁)

* [14](#14)
    * [线程间通信](#14_26线程间通信)
    * [线程间通信_JDK5_0新特性](#14_28_31线程间通信_JDK5_0新特性)
        * [锁_Lock接口_显式获取与释放锁](#1锁_Lock接口_显式获取与释放锁)
        * [监视器_Condition接口_锁上可建多个监视器](#2监视器_Condition接口_锁上可建多个监视器)
        * [JDK5_0下生产者与消费者问题的代码形式](#3JDK5_0下生产者与消费者问题的代码形式)
    * [wait方法与sleep方法的区别](#14_32wait方法与sleep方法的区别)
    * [停止线程的方式](#14_34停止线程的方式)
    * [守护线程](#14_35守护线程)
    * [join方法](#14_36join方法)
        * [toString方法](#toString方法)

* [15](#15)
    * [常用对象String类特点](#15_01常用对象String类特点)
    * [字符串的构造方法](#15_2字符串的构造方法)
    * [String类_常见功能_获取与转换](#15_3_4_5String类_常见功能_获取与转换)
    * [String类_常见功能_判断与比较](#15_6_7String类_常见功能_判断与比较)
    * [练习1_字符串数组排序](#15_9练习1_字符串数组排序)
    * [StringBuffer容器的增删改查](#15_9_10StringBuffer容器的增删改查)
    * [StringBuffer类_可变长度字符序列](#15_11StringBuffer类_可变长度字符序列)
    * [StringBuilder类](#15_12_13StringBuilder类)

* [16](#16)
    * [包装类_字符串转为基本数字类型](#16_02包装类_字符串转为基本数字类型)
    * [自动装箱和自动拆箱](#16_04自动装箱和自动拆箱)
    * [集合框架概述_共性功能](#16_01_02集合框架概述_共性功能)
    * [集合框架方法演示](#16_03_04集合框架方法演示)
    * [迭代器](#16_05_06迭代器)
    * [List_Set](#16_07List_Set)
    * [List集合的常见方法](#16_08List集合的常见方法)
    * [ListIterator接口](#16_09ListIterator接口)
    * [List常用实现类的特点](#16_10List常用实现类的特点)

* [17](#17)
    * [Vector集合](#17_12Vector集合)
    * [LinkedList集合](#17_14LinkedList集合)
    * [HashSet集合](#17_16HashSet集合)
    * [TreeSet集合](#17_22TreeSet集合)

* [18](#18)
    * [泛型](#18_01泛型)
    * [java中泛型的实现](#18_02java中泛型的实现)
    * [泛型类](#18_04泛型类)
    * [泛型方法](#18_05泛型方法)
    * [泛型接口](#18_06泛型接口)
    * [泛型_上限](#18_07泛型_上限)
        * [泛型下的继承关系](#泛型下的继承关系)
        * [泛型下的通配符](#泛型下的通配符)
        * [API中泛型下的通配符体现](#API中泛型下的通配符体现)
        * [泛型上限](#泛型上限)
        * [API中泛型上限的体现](#API中泛型上限的体现)
    * [泛型_下限](#18_08泛型_下限)
        * [API中泛型下限的体现](#API中泛型下限的体现)
    * [集合使用技巧](#18_12集合使用技巧)
    * [Map集合特点_常用方法](#18_01Map集合特点_常用方法)
    * [Map集合的遍历方式1_keySet方法](#18_03Map集合的遍历方式1_keySet方法)
    * [Map集合的遍历方式2_entrySet方法](#18_04Map集合的遍历方式2_entrySet方法)
    * [Map集合values方法演示](#18_05Map集合values方法演示)
    * [HashMap存储自定义对象](#18_07HashMap存储自定义对象)
    * [TreeMap存储自定义对象](#18_08TreeMap存储自定义对象)
        * [实现Comparable接口进行元素_Key的比较](#实现Comparable接口进行元素_Key的比较)

* [19](#19)
    * [LinkedHashMap](#19_01LinkedHashMap)
    * [工具类Collections_排序](#19_13工具类Collections_排序)
        * [自然排序](#自然排序)
        * [自定义排序](#自定义排序)
    * [工具类Colections_折半查找_最值](#19_14工具类Colections_折半查找_最值)
    * [工具类Collections_逆序_替换](#19_15工具类Collections_逆序_替换)
        * [逆序](#逆序)
        * [替换](#替换)
    * [工具类Collections其它方法_将非同步容器转换为同步容器](#19_16工具类Collections其它方法_将非同步容器转换为同步容器)
        * [其他方法](#其他方法)
        * [将非同步容器转换为同步容器](#将非同步容器转换为同步容器)
    * [工具类Arrays的toString方法及其源码](#工具类Arrays的toString方法及其源码)
    * [工具类Arrays的asList方法](#19_18工具类Arrays的asList方法)
    * [接口Collection的toArray方法](#19_19接口Collection的toArray方法)
    * [foreach循环](#19_20foreach循环)
    * [函数可变参数](#19_21函数可变参数)
    * [静态导入](#19_22静态导入)

* [20](#20)
    * [System类](#20_01System类)
        * [getProperties方法](#getProperties方法)
        * [currentTimeMillis方法](#currentTimeMillis方法)
    * [Runtime类](#20_02Runtime类)
        * [Process类](#Process类)
    * [Math类](#20_03Math类)
    * [Date类](#20_04Date类)
    * [DateFormate类_将Date类型转换为String类型](#20_05DateFormate类_将Date类型转换为String类型)
        * [SimpleDateFormate类_自定义Date类型转换为String类型的格式](#SimpleDateFormate类_自定义Date类型转换为String类型的格式)
    * [DateFormate类_将String类型转换为Date类型](#20_06DateFormate类_将String类型转换为Date类型)
    * [Date类练习](#20_07Date类练习)
    * [Calendar类](#20_08Calendar类)
    * [IO_字符流_FileWriter](#20_03IO_字符流_FileWriter)
    * [IO_字符流_FileWriter细节_换行和续写](#20_04IO_字符流_FileWriter细节_换行和续写)
    * [IO_字符流_FileWriter_异常处理](#20_05IO_字符流_FileReader)
    * [IO_字符流_FileReader_读取方式一](#20_06IO_字符流_FileReader_读取方式一)
    * [IO_字符流_FileReader_读取方式二](#20_06IO_字符流_FileReader_读取方式二)

* [21](#21)
    * [练习_复制文本文件](#21_08_练习_复制文本文件)
    * [练习2_复制文本文件](#21_09_练习2_复制文本文件)
    * [字符流_缓冲区](#21_11字符流_缓冲区)
    * [字符流_缓冲区_BufferedWriter](#21_12字符流_缓冲区_BufferedWriter)
    * [字符流_缓冲区_BufferedReader](#21_13字符流_缓冲区_BufferedReader)
    * [MyBufferedReader的read方法](#21_16MyBufferedReader的read方法)
    * [MyBufferedReader的readLine方法](#21_17MyBufferedReader的readLine方法)
    * [装饰设计模式_与继承的区别](#21_18_19装饰设计模式_与继承的区别)
    * [LineNumberReader](#21_20LineNumberReader)
    * [字节流](#21_21字节流)
    * [复制MP3](#21_22复制MP3)
        * [方式一_FileInputStream类使用自定义缓冲区](#方式一_FileInputStream类使用自定义缓冲区)
        * [方式二_BufferedInputStream类加上自定义缓冲区](#方式二_BufferedInputStream类加上自定义缓冲区)
        * [方式三_BufferedInputStream类加上read方法](#方式三_BufferedInputStream类加上read方法)
        * [方式四_FileInputStream类加上read方法](#方式四_FileInputStream类加上read方法)

* [22](#22)
    * [演示键盘录入](#22_23演示键盘录入)
    * [转换流](#22_25转换流)
        * [输入转换流](#输入转换流)
        * [输出转换流](#输出转换流)
    * [流操作的基本规律](#22_27流操作的基本规律)
    * [流操作的基本规律_需求体现](#22_28_29流操作的基本规律_需求体现)
        * [需求1_复制一个文本](#需求1_复制一个文本)
        * [需求2_读取键盘录入信息_并写入到一个文件中](#需求2_读取键盘录入信息_并写入到一个文件中)
        * [需求3_将一个文本数据显示在控制台上](#需求3_将一个文本数据显示在控制台上)
        * [需求4_读取键盘录入数据_打印控制台上](#需求4_读取键盘录入数据_打印控制台上)
    * [转换流的编解码](#22_30转换流的编解码)
    * [File对象构造函数及字段](#22_31File对象构造函数及字段)
    * [File对象常见功能_获取](#22_32File对象常见功能_获取)
    * [File对象常见功能_创建和删除](#22_33File对象常见功能_创建和删除)
    * [File对象常见功能_判断](#22_34File对象常见功能_判断)
    * [File对象常见功能_重命名](#22_35File对象常见功能_重命名)
    * [File对象常见功能_系统根目录和容量获取](#22_36File对象常见功能_系统根目录和容量获取)
    * [File对象常见功能_获取目录内容](#22_37File对象常见功能_获取目录内容)
    * [File对象常见功能_过滤器](#22_38File对象常见功能_过滤器)

* [23](#23)
    * [深度遍历文件夹](#23_39深度遍历文件夹)
        * [广度遍历方式](#广度遍历方式)
        * [深度遍历方式](#深度遍历方式)
    * [删除一个带内容的目录](#23_41删除一个带内容的目录)
    * [Properties集合的基本功能](#23_42Properties集合的基本功能)
    * [Properties的list方法](#23_43Properties的list方法)
    * [Properties的store方法](#23_44Properties的store方法)
    * [Properties修改配置信息](#23_45Properties修改配置信息)
    * [打印流PrintStream](#23_48打印流PrintStream)
    * [打印流PrintWriter](#23_49打印流PrintWriter)
    * [序列流SequenceInputStream](#23_50序列流SequenceInputStream)

* [24](#24)
    * [文件切割](#24_52文件切割)
    * [文件合并](#24_53文件合并)
    * [文件切割合并_配置文件](#24_54文件切割合并_配置文件)
    * [ObjectOutputStream对象的序列化](#24_55ObjectOutputStream对象的序列化)
    * [对象的反序列化](#24_56对象的反序列化)
    * [序列化接口Serializable](#24_57序列化接口Serializable)
    * [transient关键字](#24_58transient关键字)
    * [RandomAccessFile写入](#24_59RandomAccessFile写入)
    * [RandomAccessFile读取与随机读取](#24_60RandomAccessFile读取与随机读取)
    * [RandomAccessFile读取与随机读取_细节](#24_60_61RandomAccessFile读取与随机读取_细节)
    * [管道流PipedStream](#24_62管道流PipedStream)
    * [操作基本数据类型的流对象DataInputStream](#24_63操作基本数据类型的流对象DataInputStream)
    * [操作数组的流](#24_64操作数组的流)
    * [编码表](#24_65编码表)
    * [简单的编码解码及问题](#24_66_67_68简单的编码解码及问题)

* [25](#25)

* [26](#26)
    * [网络模型概述](#26_01网络模型概述)
    * [网络要素_IP地址](#26_02网络要素_IP地址)
    * [网络要素_端口](#26_03网络要素_端口)
    * [网络要素_传输协议](#26_04网络要素_传输协议)
    * [IP对象InetAddress](#26_05IP对象InetAddress)
    * [域名解析](#26_06域名解析)
    * [UDP协议_发送端](#26_07UDP协议_发送端)
    * [UDP协议_接收端](#26_08UDP协议_接收端)
    * [UDP协议_聊天程序](#26_09UDP协议_聊天程序)
    * [TCP协议客户端](#26_10TCP协议客户端)
    * [TCP协议服务器端](#26_11TCP协议服务器端)
    * [TCP协议客户端与服务器端的交互](#26_12TCP协议客户端与服务器端的交互)
    * [TCP协议_练习_文本转换客户端_服务器端](#26_13_14TCP协议_练习_文本转换客户端_服务器端)
    * [TCP协议_练习_上传文本文件](#26_16TCP协议_练习_上传文本文件)

* [27](#27)
    * [TCP协议_练习_上传图片](#27_17_18TCP协议_练习_上传图片)
    * [TCP协议_练习_服务器端多线程技术](#27_19TCP协议_练习_服务器端多线程技术)
    * [常见的客户端与服务器端](#27_20常见的客户端与服务器端)
    * [了解客户端和服务器端原理](#27_21了解客户端和服务器端原理)
    * [网络编程_模拟一个浏览器获取信息](#27_22网络编程_模拟一个浏览器获取信息)
    * [网络编程_URL_URLConnection](#27_23网络编程_URL_URLConnection)
    * [网络编程_常见网络结构](#27_24网络编程_常见网络结构)

* [28](#28)
    * [正则表达式_匹配](#28_03正则表达式_匹配)
    * [正则表达式_切割](#28_04正则表达式_切割)
    * [正则表达式_替换](#28_05正则表达式_替换)
    * [正则表达式_获取](#28_06正则表达式_获取)
    * [正则表达式_练习1](#28_07正则表达式_练习1)
    * [正则表达式_练习2](#28_08正则表达式_练习2)
    * [正则表达式_练习_爬虫](#28_10正则表达式_练习_爬虫)

* [29](#29)
    * [HTML概述与演示](#29_01_02HTML概述与演示)
    * [HTML列表标签](#29_04HTML列表标签)
    * [HTML图像标签](#29_05HTML图像标签)
    * [HTML表格标签](#29_06HTML表格标签)
    * [HTML表格标签_2](#29_07HTML表格标签_2)
    * [HTML超链接_1](#29_08HTML超链接_1)
    * [HTML超链接_2](#29_09HTML超链接_2)
    * [HTML框架](#29_10HTML框架)
    * [HTML画中画标签](#29_11HTML画中画标签)
    * [HTML表单组件_input](#29_12HTML表单组件_input)
    * [HTML表单组件_select_textarea](#29_13HTML表单组件_select_textarea)
    * [HTML表单格式化](#29_14HTML表单格式化)
    * [HTML_GET和POST区别](#29_15_16HTML_GET和POST区别)
    * [HTML服务器端和客户端的校验问题](#29_17HTML服务器端和客户端的校验问题)
    * [HTML常见的其他标签](#29_18HTML常见的其他标签)
    * [HTML标签的分类](#29_19HTML标签的分类)

* [30](#30)
    * [CSS概述_和HTML结合的方式一二](#30_01_CSS概述_和html结合的方式一二)
    * [CSS和HTML结合的方式三四](#30_02CSS和HTML结合的方式三四)
    * [CSS基本选择器_优先级](#30_03CSS基本选择器_优先级)
    * [关联选择器与组合选择器](#30_04关联选择器与组合选择器)
    * [伪元素选择器_1](#30_05伪元素选择器_1)
    * [伪元素选择器_2](#30_06伪元素选择器_2)
    * [CSS样式的结合应用](#30_07CSS样式的结合应用)
    * [CSS的盒子模型](#30_08CSS的盒子模型)
    * [CSS的布局_漂浮](#30_09CSS的布局_漂浮)
    * [CSS的布局_定位](#30_10CSS的布局_定位)
    * [CSS的布局_图文混排](#30_11CSS的布局_图文混排)

# 02

# github中md编写注意事项

其中标题的编写格式为:

```java
    * [github中md编写注意事项](#github中md编写注意事项)
```

1.&nbsp;*与[]之间有一个空格

2.&nbsp;()中不允许有&nbsp;空格&nbsp;&&nbsp;、&nbsp;()&nbsp;《》&nbsp;等符号

3.&nbsp;()中#只是一个#号，与你要关联的几级标题没有关系，无论几级标题都只是一个#号

# 02_01关键字

Java 严格区分大小写

一般关键字小写，类名大写

# 02_02标识符

标识符：自己起的一些名称(变量名、函数名、类名等)

组成：26个英文字母，数字0-9，**符号_$**

注意：

1.数字不可以开头

2.不可以使用关键字做标识符

# 02_08负数的进制

负数的二进制为该负数取绝对值的二进制取反再加一

如：-6

首先计算6的二进制00000000000000000000000000000110

取反&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11111111111111111111111111111001

加一&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11111111111111111111111111111010

即-6的二进制表示为11111111111111111111111111111010

```java
class Demo02_08{
    public static void main(String[] args){
        System.out.println(Integer.toBinaryString(6));
        System.out.println(Integer.toBinaryString(-6));
    }
/*
$ java Demo02_08
110                      //前面的0都被省略了
11111111111111111111111111111010
*/
}
```

# 02_11_13自动类型提升与强制转换_类型运算细节

注意，其实老师在教程中，"强制转换"用词有点不太严格，为了让"强制转换"这个词更加"专有化"，本笔记中将"类型转换的结果可能丢失精度"的转换称之为"强制转换"(或"强制类型转换")

```java
class VarDemo2{
    public static void main(String[] args){
        byte b = 3;
        b = b + 4;
        System.out.println(b);
    }
}
/*
$ javac VarDemo2.java 
VarDemo2.java:4: 错误: 不兼容的类型: 从int转换到byte可能会有损失
        b = b + 4;
              ^
1 个错误
*/
```

1.Java中整数的默认类型为int类型

2.byte b = 3;在编译的时候，**编译器会判断int类型的3在不在byte所表示的范围之内**，在则进行一次类型转换，将int类型的3转换为byte类型存储在变量b中(因为会进行是否丢失精度的判断，所以这里称之为类型转换，而非老师说的强制类型转换)，不在则报错。

3.b = b + 4;表达式b + 4中b为byte类型的变量，在与int类型的4相加时会进行**自动类型提升**，将byte类型的b提升为int类型，结果为int类型，我们要把int类型的结果b+4存储在byte类型b之中，这需要对int类型的值b+4做判断，但是需要注意的一点是b为变量，也就是说它存储的数值是在变化的，所以说**编译器无法判断int类型的b+4在不在byte所表示的范围之内**，所以报错。

```java
class VarDemo2{
    public static void main(String[] args){
        byte b;
        b = 3 + 4;
        System.out.println(b);
    }
}
```
这里就不会报错(因为3+4在byte可以表示的范围之内)，因为3+4中int类型的3和int类型的4都是常量，编译器可以判断其结果在不在byte可以表示的范围之内，在则进行类型转换(同理，这里会进行是否丢失精度的判断，所以称之为类型转换)，将int类型转换为byte类型，不在则报错。

我们可以将程序写为

```java
class VarDemo2{
    public static void main(String[] args){
        byte b = 3;
        int c = b + 4;
        System.out.println(c);
    }
}
```

这里(b+4)为int类型，赋值给int类型的变量c，类型兼容，程序可以正常运行

还可以写为

```java
class VarDemo2{
    public static void main(String[] args){
        byte b = 3;
        b = (byte)(b + 4);
        System.out.println(b);
    }
}
```

这里将(b+4)进行了**强制转换**(因为这个转换是将int类型强制转换为byte类型，可能会丢失精度)

# 02_14算术运算符_1

```java
class OperateDemo{
    public static void main(String[] args){
        int b = 6370;
        b = 6370/1000*1000;
        System.out.println(b);
    }
}
/*
$ java OperateDemo
6000
*/
```

Java是强类型的语言,6370是int类型，1000也是int类型，那么两者运算完的结果也是int类型，java会将小数点舍去

# 02_15算术运算符_2_赋值运算符

```java
class OperateDemo2{
    public static void main(String[] args){
        int a=3,b;
        b = a++;
        System.out.println("a="+a+",b="+b);
    }
}
/*
$ java OperateDemo2
a=4,b=3
*/
```

 b = a++;就相当于

 ```java
 int temp = a;//因为a参与了其他运算，内存会将a的值复制一份
 a = a + 1；//做到这里相当于等式右边a++步骤做完了
 b = temp;//将复制的a的值赋值给等式左边
 ```

 大家理解了上边这个例子之后下边这个例子就很好理解了

```java
 class OperateDemo3{
     public static void main(String[] args){
         int i=3;
         i = i++;
         System.out.println("i="+i);
     }
 }
 /*
 $ java OperateDemo3
i=3
 */
```

# 赋值运算符

s+=4;与s=s+4;一样吗？在Java的世界里是有区别的

```java
class OperateDemoFuZhi{
    public static void main(String[] args){
        short s=3;
        s+=4;
        System.out.println("s="+s);
    }
}
/*
$ java OperateDemoFuZhi
s=7
*/
```

而

```java
class OperateDemoFuZhi{
    public static void main(String[] args){
        short s=3;
        s = s + 4;
        System.out.println("s="+s);
    }
}
/*
$ javac OperateDemoFuZhi.java 
OperateDemoFuZhi.java:4: 错误: 不兼容的类型: 从int转换到short可能会有损失
        s = s + 4;
              ^
1 个错误
*/
```

因为s+=4;底层做了**强制类型转换**，就相当于s = (short)(s + 4);

# 03

# 03_02_03逻辑运算符_位运算符

& &nbsp;&& 的区别：

两者运算的结果是一致的，但是运算的过程有一点小区别(&还可以进行位运算)

    &运算符两边都进行计算

    &&运算符左边为false时，并不计算右边(记忆方法:我们平时一般用&&，比较"高效")

| &nbsp;||的区别

两者运算的结果是一致的，但是运算的过程有一点小区别(| &nbsp;还可以进行位运算)

    |运算符两边都进行计算

    ||运算符左边为true时，并不计算右边(记忆方法:我们平时一般用||，比较"高效")

```java
class OperateDemo0302{
    public static void main(String[] args){
        int a = 3;
        boolean b = (1>a) && (a++ > 4); 
        System.out.println("a="+a+",b="+b);
    }
}
/*
$ java OperateDemo0302
a=3,b=false
*/
```

```java
class OperateDemo0302{
    public static void main(String[] args){
        int a = 3;
        boolean b = (1>a) & (a++ > 4); 
        System.out.println("a="+a+",b="+b);
    }
}
/*
$ java OperateDemo0302
a=4,b=false
*/
```

从上边两段程序中，大家很容易看出两者的区别。

为了复习自加操作，我们有如下程序

```java
class OperateDemo0302{
    public static void main(String[] args){
        int a = 3;
        boolean b = a++ > 3; 
        System.out.println("a="+a+",b="+b);
    }
}
/*
$ java OperateDemo0302
a=4,b=false
*/
```

过程为：

    int temp = a;

    a = a + 1；

    boolean b = temp > 3;

# 异或运算

一个数异或另一个数偶数次，还等于原来那个数，如：
b ^ 3 ^ 3 = b

1.这个小知识点非常重要，因为有面试题会让你编写程序，找出一段数字里只出现过一次的数字(其他数字都出现过两次)等类似的题，就可以用该知识点来做

2.还可以用来做两个变量的换值(不使用第三方变量，参见03_04_05_06节)

3.另外一个好玩的事情为，该小知识点可以用来加密，比如说用来加密图片(当然现实中没谁会用它来加密图片)，这是毕老师提到的一点，我利用matlab(因为用Java写就没那么简单了/笑哭脸)写了一段程序大家可以感受一下

```matlab
>> img = imread('nv_xing.jpg');
>> img_encrypted = bitxor(img, 125);
>> imwrite(img_encrypted, 'nv_xing_encrypted.jpg');
```

![nv_xing_encrypted.jpg](https://github.com/geekavan/BiXiangdong/blob/master/nv_xing_encrypted.jpg)

大家猜到她是谁了吗

答案揭晓

```matlab
>> img = imread('nv_xing_encrypted.jpg');
>> img_decrypt = bitxor(img, 125);
>> imwrite(img_decrypt, 'nv_xing_decrypt.jpg');
```

![nv_xing_decrypt.jpg](https://github.com/geekavan/BiXiangdong/blob/master/nv_xing_decrypt.jpg)

至于为什么解密后的图片中有许多彩色的小点呢，欢迎大家留言讨论

# 03_04_05_06位运算符

<<左移运算符相当于乘以2的次幂，>>右移运算符相当于除以2的次幂(右移的时候原来最高位为几，则补几，即符号位是不变的)，>>>无符号右移(右移的时候无论原来最高位为几，都补0)

```java
class OperateDemo03_04{
    public static void main(String[] args){
        Integer a = -2147483647;
        System.out.println(Integer.toBinaryString(a));
        System.out.println("a = "+a);
        System.out.println(Integer.toBinaryString(a>>1));
        System.out.println("a>>1 = "+(a>>1));
        System.out.println(Integer.toBinaryString(a>>>1));
        System.out.println("a>>>1 = "+(a>>>1));
    }
}
/*
$ java OperateDemo03_04
10000000000000000000000000000001
a = -2147483647
11000000000000000000000000000000
a>>1 = -1073741824
1000000000000000000000000000000   //最开头有一位0，给省略了
a>>>1 = 1073741824
 */
```

练习题1如何高效地计算2*8

```java
class OperateTest03_05{
    public static void main(String[] args){
        System.out.println(2<<3);
    }
}
/*
 $ java OperateTest03_05
16
 */
```

练习题2，在不使用第三方变量的情况下(答案里也写了利用第三方变量的形式)，怎么将两个变量互换

大家可以自己先思考一下，这个练习题是前几节一起学完后的练习题，不要受本节内容位运算符的影响

```java
class OperateTest03_04_05{
    public static void main(String[] args){
        /*
        方式1，利用第三方变量，开发的时候使用这个，因为阅读性强
        */
        int a = 4;
        int b = 3;
        System.out.println("a="+a+",b="+b);
        int temp = a;
        a = b;
        b = temp;
        System.out.println("a="+a+",b="+b);

        /*
        方式2，没有用到第三方变量，面试的时候使用，开发的时候一般不用，因为阅读性较差
        */
        int e = 4;
        int f = 3;
        System.out.println("e="+e+",f="+f);
        e = e ^ f;
        f = e ^ f;
        e = e ^ f;
        System.out.println("e="+e+",f="+f);
        
        /*
        方式3，没有用到第三方变量，该种方式不推荐使用(开发面试的时候都不要使用)，因为如果c、d过大的话c=c+d就会超出int可表示的范围(并不推荐说成老师说的强制转换，因为这里虽然丢失了精度，但是没有涉及类型之间的转换)出现错误(但是程序是可以执行的哦)，这里第二行的输出语句表明c的值就是错的
        */
        int c = 2147483647;
        int d = 3;
        System.out.println("c="+c+",d="+d);
        c = c + d;
        System.out.println("c="+c);
        d = c - d;
        c = c - d;
        System.out.println("c="+c+",d="+d);
    }
}
```

# 03_22_23for语句

```java
//注意以下程序如果编译出现问题，请使用javac -encoding utf-8 forDemo.java语句进行编译
class forDemo{
    public static void main(String[] args){
        /*
        for(初始表达式；条件表达式；每次循环后执行的表达式){
            循环体；
        }
        */
        for(int i=0;i<3;i++){
            System.out.println(i);
        }
        //上边是我们常见的一种for语句的写法，但是下面这一种也是可以的，但是有一定基础的同学可能会认为并不正确
        int i = 0;
        for(System.out.println("初始表达式");i<3;System.out.println("每次循环后执行的表达式")){
            System.out.println("循环体");
            i++;
        }
    }
}
/*
 $ java forDemo
0
1
2
初始表达式
循环体
每次循环后执行的表达式
循环体
每次循环后执行的表达式
循环体
每次循环后执行的表达式 
 */
```

下图为for语句中各个部分的执行顺序

初始表达式

**条件表达式**

————————————————————————————————————————————

循环体

每次循环后执行的表达式

**条件表达式**

————————————————————————————————————————————

循环体

每次循环后执行的表达式

**条件表达式**

也如下图所示

!["for语句中各个部分的执行顺序"](https://github.com/geekavan/BiXiangdong/blob/master/for%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png)


# while与for语句最简单的无限循环表现形式

while(true){}

for(;;;){}

for语句中如果条件表达式不写，默认为真

# 04

# 04_01_04For循环嵌套练习-99乘法表_转义字符

比较简单的一个小练习，大家在编写的时候，可以限制一下自己的用时

```java
class ForFor99_04_01_04{
    public static void main(String[] args){
        /*
         九九乘法表
         1*1=1
         1*2=2 2*2=4
         1*3=3 2*3=6 3*3=9
         */
        for(int i=0;i<9;i++){
            for(int j=0;j<(i+1);j++){
                System.out.print((j+1)+"*"+(i+1)+"="+((j+1)*(i+1)));
                System.out.print(' ');
            }
            System.out.print('\n');

        }
    }
}
/*
$ java ForFor99_04_01_04
1*1=1 
1*2=2 2*2=4
1*3=3 2*3=6 3*3=9
1*4=4 2*4=8 3*4=12 4*4=16 
1*5=5 2*5=10 3*5=15 4*5=20 5*5=25
1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36
1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 
1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64
1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81
*/
```

从上边结果中，我们发现有几列是没有对齐的，我们想要对齐该怎么做呢？

这里要用到转义字符，顾名思义，可以用来转变字(母)符(号)含义的字符(串)

```java
class ForFor04_01_04{
    public static void main(String[] args){
        System.out.print("hello\tworld");
        System.out.println();
        System.out.print("hi\tworld");
    }
}
/*
$ java ForFor04_01_04
hello   world
hi      world
*/
```

上边用到了制表符\t，这个符号像画表格一样，将后边的字符串，放到了下一个格子里边，所以看起来就会对的整齐，大家可以自己动手更改一下99乘法表程序使之打印格式更加规整

其他(仅作为了解)：

\n换行(其实执行了两个步骤\n\r)

\r回车，将当前位置移动到本行开头

(其实这么说来，windows下的Enter键包含了两个步骤\n\r，这一点从Enter下的图标就可以看出来(图标先向下，再向左))

\t制表符

\b退格，将当前位置移动到前一列

因为这些并不是重点，所以本笔记不打算给出它们的演示，大家感兴趣的话可以自己编程试一下，看一下它们的作用效果

# 04_01_06break_continue

break用在循环结构中，跳出当前循环体(还可以用在swith语句中)

continue用在循环结构中，结束本次循环，继续下一次循环

下面给出几个例子，说明这两个关键字的作用，请同学注意了解一下**循环体的名称**，以及如何break或continue指定循环体

break跳出当前循环体

```java
class BreakContinueDemo{
    public static void main(String[] args){
        for(int i=0;i<3;i++){
            if(i>1)
                break;
            System.out.println(i);
        }
    }
}
/*
$ java BreakContinueDemo
0
1
*/
```

break跳出指定循环体

```java
class BreakContinueDemo2{
    public static void main(String[] args){
        for1name:for(int i=0;i<3;i++){
            for2name:for(int j=0;j<6;j++){
                if(j>3)
                    break for1name;
                System.out.println("i="+i+",j="+j);
            }
        }
    }
}
/*
$ java BreakContinueDemo2
i=0,j=0
i=0,j=1
i=0,j=2
i=0,j=3
 */
```

continue类同，这里不再举例

# 04_03_04_05_06_07堆栈

java虚拟机所管理的内存在数据运行时可划分为(本课程循序渐进，这里讲的并不细致，深入)

**线程共享**：

堆

方法区

**线程私有**：

程序计数器

虚拟机栈

本地方法栈

**其中堆的特点为**：

1.几乎所有的类实例和数组都在堆上分配内存(其实数组也是对象)

2.每一个实例都有一个首地址

3.数组实例在创建时有初始化值，根据数组类型的不同而不同，整型为0，小数为0.0或0.f，boolean为false，char为'\u0000'

**其中栈的特点为**：

1.局部变量存储在虚拟机栈中(局部变量表，jdk1.8后似乎有变化)

2.变量所属作用域一旦结束，该变量就自动释放

# 数组常见问题

```java
class ArrayDemo2{
    public static void main(String[] args){
        int[] arr = new int[3];
        // System.out.println(arr[3]);//ArrayIndexOutOfBoundsException
        //可以正常编译，运行时产生错误

        // arr = null;
        // System.out.println(arr[3]);//NullPointerException
        //正常编译，运行时产生错误，空指针异常

        System.out.println(arr);//   [I@15db9742
        //其中@后边是这个对象的哈希值，根据这个哈希值给对象分配地址
        //@前边[代表arr指向为数组，I表示数组存储为int类型数据
    }
}
```

# 复习练习题来源Java程序员面试笔试宝典

1.如何判断一个数是否为2的n次方，大家可以自己动手练习一下

下面是我想的思路

```java
class isPowerTest{
    public static void main(String[] args){
        System.out.print(isPower(4096));

    }
    public static boolean isPower(int x){
        if(x<=0)
            return false;
        else{
            while(x!=0){
                if(((x&1)==1) && (x/2 == 0))
                    return true;
                else if (((x&1)==1) && (x/2 != 0))
                    return false;
                x = x>>1;
            }
        }
        return false;
    }
}
```

答案：一个数若为2的n次方，那么它的二进制中只有一个1，如00001000(一个int型在java中占据4个字节，这里只写了低八位)它如果减去1，那么为00000111(只写了低八位)，没有一位是同为1的，两者按位与等于0

```java
class IsPowerTest2{
    public static void main(String[] args){
        System.out.println(isPower(128));
    }
    public static boolean isPower(int x){
        if(x<=0)
            return false;
        else if((x&(x-1))==0)
            return true;
        return false;
    }
}
```

2.如何求二进制中1的个数

```java
class OneNumbersTest{
    public static void main(String[] args){
        System.out.println(checkOneNumbers(0x12481249));
    }
    public static int checkOneNumbers(int x){
        int oneNumbers = 0;
        while(x!=0){
            oneNumbers++;
            x = x&(x-1);
        }
        return oneNumbers;
    }
}
```

# 05

# 05_01Java数组的三种定义格式

```java
class ArrayDemo3{
    public static void main(String[] args){
        int[] arr0 = new int[3];
        int[] arr1 = new int[]{0,1,2};
        int[] arr2 = {0,1,2};
        print(arr0);
        print(arr1);
        print(arr2);
    }
    public static void print(int[] arr){
        System.out.print("[");
        for(int i=0;i<arr.length-1;i++){
            System.out.print(arr[i]+",");
        }
        System.out.print(arr[arr.length-1]+"]");
        System.out.print("\n");
    }
}
/*
$ java ArrayDemo3
[0,0,0]
[0,1,2]
[0,1,2]
*/
```

# 05_04_05常见排序算法

```java
class Sort{
    public static void main(String[] args){
        int[] arr =  {5,8,7,9,4,6,2,3,1,0};
        // int[] arr = {1};
        print(arr);
        // selectSort(arr);
        // bubbleSort(arr);
        // insertSort(arr);
        // shellSort(arr);
        mergeSort(arr);
        print(arr);
    }

    public static void exch(int[] arr, int a , int b){
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    public static void print(int[] arr){
        System.out.print("[");
        for(int i=0; i<arr.length-1; i++){
            System.out.print(arr[i]+",");
        }
        System.out.print(arr[arr.length-1]+"]");    
        System.out.print('\n');
    }

    public static void selectSort(int[] arr){
        if(arr==null)
            return; 
        int length = arr.length;
        for(int i = 0; i< length; i++){
            for(int j=i; j<length; j++){
                if(arr[i] > arr[j])
                    exch(arr, i, j);
            }
        }
    }
    public static void bubbleSort(int[] arr){
        if(arr==null)
            return;
        int length = arr.length;
        for(int i=0;i<length-1;length--){
            for(int j =0; j<length-1;j++){
            if(arr[j]>arr[j+1])
                exch(arr, j, j+1);
            }
        }
    }
    public static void insertSort(int[] arr){
        if(arr==null)
            return ;
        for(int i=0;i<arr.length;i++){
            for(int j=i;j>=1 && arr[j]<arr[j-1];j--)
                exch(arr, j, j-1);
        }
    } 
    public static void shellSort(int[] arr){
        int step = arr.length;
        while(step!=0){
            for(int i = 0;i<arr.length;i+=step){
                for(int j=i;j>=step && arr[j]<arr[j-step];j-=step)
                    exch(arr, j, j-step);
            }
            step/=3;
        }
    }
    public static void merge(int[] arr, int lo, int mid, int hi){
        int i = lo;
        int j = mid+1;
        for(int k = lo;k<=hi;k++)
            temp[k] = arr[k];
            for(int k = lo;k<=hi;k++){
                if(i>mid)                  arr[k] = temp[j++];
                else if(j>hi)               arr[k] = temp[i++];
                else if(temp[i]<temp[j])    arr[k] = temp[i++];
                else                        arr[k] = temp[j++];
        }
    }
    public static void mergeSort(int[] arr, int lo, int hi){
        if(lo < hi){ 
            int mid = lo + (hi-lo)/2;
            mergeSort(arr, lo, mid);
            mergeSort(arr, mid+1, hi);
            merge(arr, lo, mid, hi);
        }
    }

    private static int[] temp;

    public static void mergeSort(int[] arr){
        temp = new int[arr.length]; 
        // 下边调用的mergeSort左右索引都包含了，以后归并就这么写吧
        mergeSort(arr, 0, arr.length-1);
    }
}
```

# 05_09折半查找

```java
class HalfSearch{
    public static void main(String[] args){
        int[] arr = {15,23,31,42,49,51,53,64,69,70,72,75,80,88,99};
        System.out.print(halfSearch(arr,42));
    }
    public static int halfSearch(int[] arr ,int key){
        int lo = 0;
        int hi = arr.length;
        int mid = lo + (hi-lo)/2;
        while(mid!=lo && mid!=hi){
            if(arr[mid]==key)
                return mid;
            if(arr[mid]<key)
                lo=mid;
            else
                hi=mid;
        mid = lo+(hi-lo)/2;
        }
        return -1;
    }
}
```

# 05_11_12进制的转换_查表法

给定一个数，输出它的十六进制

```java
class ArrayDemo{
    public static void main(String[] args){
        toHex(15);
    }
    public static void toHex(int num){
        int a= 15;
        String[] hex = new String[8];
        for(int i=0;i<8;i++){
            hex[i]= sign((num & a)>>(i*4));
            a = a<<4;
        }
        for(int i=7;i>=0;i--){
            System.out.print(hex[i]);
        }

    }
    public static String sign(int num){
        if(num<0 || num > 15)
            return "";
        else if(num >=0 && num <=9){
            return (""+num);
        }
        else if(num==10)
            return ("a");
        else if(num==11)
            return ("b");
        else if(num==12)
            return "c";
        else if(num==13)
            return "d";
        else if(num==14)
            return "e";
        else 
            return "f";
    }
}
```

其实这其中获取10-15的二进制表示可以使用查表法

```java
class ArrayDemo{
    public static char[] chs = {'0','1','2','3',
                                '4','5','6','7',
                                '8','9','a','b',
                                'c','d','e','f'};
    public static void main(String[] args){
        toHex(60);
    }
    public static void toHex(int num){
        int index = 7;
        char[] hex = new char[8];
        while(num!=0){
            hex[index--]= chs[num&15];
            num = num>>>4;
        }
        for(int i = 0; i < 8;i++){
            System.out.print(hex[i]);
        }
    }
}
/*
$ java ArrayDemo
      3c
*/
```

# 06

# 06_08成员变量和局部变量的区别

1.定义的位置不同

    成员变量定义在类中

    局部变量定义在函数(或局部代码块)中

2.存在的内存位置不同

    成员变量在所属类实例化后存在于堆中

    局部变量在所属函数加载后存在于虚拟机栈中

3.初始化不同

    成员变量在所属类实例化后就有初始化值，可以直接使用

    局部变量随着所属函数加载到栈而在栈中存在但并无初始化值，不可以直接使用

4.生存周期不同

    成员变量随着对象的创建而存在，随着对象的回收而消失

    局部变量随着函数的加载而存在，随着函数的弹栈而消失

下面两段程序是区别3的演示

```java
class Test06_08{
    public static void main(String[] args){
        Person p = new Person();
        System.out.println(p.name);
        System.out.println(p.age);
    }
}
class Person{
    String name;
    int age;
}
/*
$ java Test06_08
null
0
*/
```

```java
class Test06_08{
    public static void main(String[] args){
        String name;
        int age;
        System.out.println(name);
        System.out.println(age);
    }
}
/*
$ javac Test06_08.java
Test06_08.java:16: 错误: 可能尚未初始化变量name
        System.out.println(name);
                           ^
Test06_08.java:17: 错误: 可能尚未初始化变量age
        System.out.println(age);
                           ^
2 个错误
 */
```

# 06_14private关键字

```java
class PersonDemo{
    public static void main(String[] args){
        Person p = new Person();
        p.age = -20;
        System.out.println(p.age);
    }
}
class Person{
    int age;
}
/*
$ java PersonDemo
-20
*/
```

但是一个人的年龄为负值是不符合常识的，出现这种情况的原因为age数据对外暴露，或者说我们没有对输入数据进行检查，改变方式为：

1.将age设置为private，类外不能对其进行直接访问

2.添加一种方法可以设置age值，但要对所赋的值进行合理性判断

更改为：

```java
class PersonDemo{
    public static void main(String[] args){
        Person p = new Person();
        p.setAge(-20);
        System.out.println(p.getAge());
    }
}
class Person{
    private int age;
    public void setAge(int ag){
        if(ag<=0 || age>=150)
            System.out.println("错误的数据");
        else
            age = ag;
    }
    public int getAge(){
        return age;
    }
}
/*
$ java PersonDemo
错误的数据
0
*/
```

因为age为private类型，类外访问不到所以一般会有get方法用来获取age

# python中的set与get方法

```python
class Person():
    def __init__(self):
        self.__age = 0
    @property
    def getAge(self):
        return self.__age
    @getAge.setter
    def setAge(self, ag):
        if ((ag<0) or (ag > 150)):
            print("错误的数据")
        else:
            self.__age = ag
p = Person()
p.setAge = -20
print(p.getAge)
'''
$ python PersonDemo.py
错误的数据
0
'''
```

一般地我们将上述程序写为

```python
class Person():
    def __init__(self):
        self.__age = 0
    @property
    def age(self):
        return self.__age
    @age.setter
    def age(self, ag): #其实这里ag的阅读性并不强，一般我们会把其写为age，相应地为了区分局部变量与成员变量会将ag<0写为self.__age<0，ag>150类同
        if ((ag<0) or (ag > 150)):
            print("错误的数据")
        else:
            self.__age = ag
p = Person()
p.age = -20
print(p.age)
'''
$ python PersonDemo.py
错误的数据
0
'''
```

即将setAge与getAge都写为age，从名称到操作都是像在和成员变量打交道一样

# 07

# 07_06构造函数细节

1.当类没有写构造函数时，编译器会为类自动生成一个空参数空函数体的构造函数

&nbsp;&nbsp;当类有写构造函数时，编译器就不会再自动生成构造函数了

示例如下：

```java
class ConsDemo{
    public static void main(String[] args){
        Person p = new Person();
    }
}
class Person{
    private char sex;
}
/*
$ javac ConsDemo.java
*/
```

```java
class ConsDemo{
    public static void main(String[] args){
        Person p = new Person();
    }
}
class Person{
    private char sex;
    Person(char sex){
        this.sex = sex;
    }
}
/*
$ javac ConsDemo.java
1 个错误

        Person p = new Person();
                   ^
  需要: char
  找到: 没有参数
  原因: 实际参数列表和形式参数列表长度不同
1 个错误
*/
```

2.构造函数中有return语句(可以省略不写)(注意Java函数中都有return语句，不论写与不写，程序执行到return语句时就会弹栈)

```java
class ConsDemo{
    public static void main(String[] args){
        Person p = new Person('f');
    }
}
class Person{
    private char sex;
    Person(char sex){
        this.sex = sex;
        return;
    }
}
/*
$ javac ConsDemo.java
*/
```

3.构造函数也可以重载

```java
class ConsDemo2{
    public static void main(String[] args){
        Person p = new Person();
        System.out.println(p.name+":"+p.sex+"|");
        Person p1 = new Person('f');
        System.out.println(p1.name+":"+p1.sex+"|");
        Person p2 = new Person("小明",'f');
        System.out.println(p2.name+":"+p2.sex+"|");
    }
}
class Person{
    String name;//为了减少代码量，我没有限定成员变量为private
    char sex;
    Person(){}
    Person(char sex){
        this.sex = sex;
    }
    Person(String name, char sex){
        this.name = name;
        this.sex = sex;
    }
}
/*
$ java ConsDemo2
null: |
null:f|
小明:f|
*/
```

其实这里老师并没有讲，我想在这里说明为什么python不支持函数重载

# python为什么不支持函数重载

首先我们要了解为什么java要支持函数重载

1.解决函数功能相同，但是函数参数类型不同的问题。比如同为add,两个int型相加和double型相加就不一样，如果不支持函数重载，那么同一个函数功能就要用不同的函数名，烂透了

2.解决函数目的相同，但是参数个数不一样的问题。比如孩子类，孩子一生下来(创建出来)有的就有名字，有的还没有来得及起名字，那么同为对象初始化，参数个数就不一样，不支持重载的话，就需要不同函数名字(其实这一点也可以通过默认参数来解决)，烂透了

那么python不支持函数重载那它又是怎么解决这些问题的呢？

1.python是动态语言，不需要去指定变量类型，自然没有1的问题

2.python支持默认参数(Java并不支持默认参数)，这样一定程度上就解决了问题2，比如上面的程序ConsDemo2，虽然有的构造函数没有指定name或者sex的值，但是如果不指定的话，它们也是存在默认值的，这样的话python也可以较完美地改写上述程序，如下：

```python
class Person:#当类没有父类时，类名后面的()可以省略
    def __init__(self, name="null", sex = ' '):
        # 注意这里的null为一个字符串，和Java中的null不是一回事，python中""与''都是表示字符串而Java中""是字符串而''是字符
        self.name = name
        self.sex = sex

if __name__=="__main__":
    p = Person()
    print(p.name+":"+p.sex+"|")
    p1 = Person(sex = 'f')
    print(p1.name+":"+p1.sex+"|")
    p2 = Person("小明",'f')
    print(p2.name+":"+p2.sex+"|")
'''
$ python ConsDemo2.py
null: |
null:f|
小明:f|
'''
```
总结：

1.python不支持函数重载的原因为：动态语言且支持默认参数

2.Java不支持默认参数的原因为：支持函数重载，没必要再支持默认参数

# 07_07_08this关键字

this关键字是所在函数所属对象的引用

```java
class ThisDemo{
    public static void main(String[] args){
        Person p = new Person("如花",30);
    }
}
class Person{
    String name;
    int age;
    Person(String name){
        this.name = name;
    }
    Person(String name, int age){
        this(name);//必须放在第一行
        this.age = age;
    }
}
```

![class__init__](https://github.com/geekavan/BiXiangdong/blob/master/class__init__.png)
注意这里p的赋值顺序和老师不一样，可能存在错误

# 07_11_13static关键字特点及注意事项

### static关键字特点

1.static关键字是一个修饰符，用于修饰成员(成员变量与成员函数)

2.static修饰的成员被所有类对象共享

3.static修饰的成员可以由对象所调用，也可以由类名直接调用

4.static修饰的成员随着类的加载而存在，先于对象存在

```java
class Person{
    static String country;
    String name;
    System.out.println(country+":"+name);
    //上述语句补全为System.out.println(Person.country+":"+this.name);
}
```

其中虽然country可以由对象调用写为this.country，但是为了阅读性更好还是写为类名调用比较合适，表明它是静态成员变量

### static注意事项

1.静态方法中不能访问非静态成员

这点很好理解，静态方法随着类的加载就已经存在了可以由类名直接调用，而此时对象还并不存在(而成员变量是封装在对象中的)

2.静态方法中不能使用this或super关键字

3.主函数是静态的

# 07_12成员变量和静态变量的区别

1.存在位置不同：

成员变量在所属类实例化后存在于堆中

静态变量在所属类被加载后存在于方法区(共享数据区)的静态区中

2.生存周期不同：

成员变量随着对象的创建而存在，随着对象的回收而消失

静态变量随着类的加载而存在，随着类的消失而消失(jvm结束类就消失了，其实类也是对象，jvm也会管理)

3.访问方式不同：

成员变量由对象访问

静态变量既可以由对象访问，又可以由类名访问

4.别名不同：

成员变量又叫实例变量

静态变量又叫类变量

# 07_15static关键字_内存图解

这一步部分很重要，建议看视频

# 07_17_18静态代码块_构造代码块_局部代码块

### 静态代码块

静态代码块：类中static修饰的代码块

作用：用于类的初始化

什么时候执行：类加载的时候执行，且执行一次

### 构造代码块

构造代码块：类中{}内的代码块

什么时候执行：创建对象的时候执行，创建一次对象就执行一次，且**先于构造函数执行**

### 局部代码块

局部代码块：方法中{}内的代码块

作用：用于限定局部变量的生存范围，节省内存空间

什么时候执行：方法中顺序执行

```java
class Person{

    {
        System.out.println("构造代码块 run");
    }
    Person(){
        System.out.println("构造函数 run");
    }
    static{
        System.out.println("静态代码块 run");
    }
    public void show(){
        System.out.println("show run");
        {
            System.out.println("局部代码块 run");
        }
    }
}
class StaticCodeDemo{
    public static void main(String[] args){
        new Person();
        new Person();
        new Person().show();
    }
}
/*
$ java StaticCodeDemo
静态代码块 run
构造代码块 run
构造函数 run
构造代码块 run
构造函数 run
构造代码块 run
构造函数 run
show run
局部代码块 run
*/
```

注意：

1.当程序中使用到某类的时候，这个类就加载到内存的方法区中，类只用加载一次，所以**静态代码块**只执行了一次

2.当创建对象时，**构造代码块**会在**构造函数**之前执行，创建一次对象就执行一次构造代码块及构造函数

3.**局部代码块**在方法中按函数语句顺序执行

# 08

# 08_04_06单例设计模式

何为单例设计模式？一个类只能有一个对象

如何做到呢？

1.首先类外应该不允许建立本类对象，否则的话就可能会有很多个对象，因为用户并不受我们控制，这一点要怎么实现呢？

    类外建立对象时一定会初始化，就相当于调用了类的构造函数，那么我们把构造函数私有化，类外不可以访问，类外不就不可以建立对象了吗

2.但是类外不能够建立对象的话，怎么使得程序会有一个对象呢？

    答案当然是在类内建立对象

3.那么外界怎么获取这个对象呢？

    1.类内提供一个方法，返回本类对象

    2.要注意此类在类外建立不了对象，只能通过类名访问该方法，所以该方法应该为静态

    3.静态方法只能访问静态成员变量，所以存储对象的类类型变量应该为静态变量

```java
class Person{
    private Person(){}
    private static Person p = new Person();//为什么是私有？和其他成员变量一样，为了可控，不被外界随意篡改，提供方法访问，在方法中对输入参数进行判断，符合要求则返回实例
    public static Person getInstance(){
        return p;
    }
}
class SingleDemo{
    public static void main(String[] args){
        Person p1 = Person.getInstance();
        Person p2 = Person.getInstance();
        System.out.println(p1==p2);
    }
}
/*
$ java SingleDemo
true
*/
```

该方法中Person类只要一加载，堆中就存在Person对象，称之为饿汉式单例模式

```java
class Person{
    private Person(){}
    private static Person p = null;
    public static Person getInstance(){
        if(p==null){
            p = new Person();
            return p;
        }
        else
            return p;
    }
}
class SingleDemo{
    public static void main(String[] args){
        Person p1 = Person.getInstance();
        Person p2 = Person.getInstance();
        System.out.println(p1==p2);
    }
}
/*
$ java SingleDemo
true
*/
```

该方式下，类加载时堆中并无Person对象，只有当getInstance()方法被调用时，对象才被建立，称之为懒汉式单例建立模式

# 08_02_03数组工具类中静态的使用_文档的使用

我将以一段程序几个阶段的演化来讲解此部分内容

### 阶段一____

```java
class ArrayToolsDemo1{
    public static void main(String[] args){
        int[] arr = {5,4,7,6,9,8,2,1,3,0};
        int maxIndex = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]>arr[maxIndex])
                maxIndex = i;
        }
        System.out.println(arr[maxIndex]);
    }
}
/*
$ java ArrayToolsDemo1
9
*/
```

### 阶段二____函数

求数组最大值可能会经常用到，为了提高代码的复用性将其封装为函数

```java
class ArrayToolsDemo2{
    public static void main(String[] args){
        int[] arr = {5,4,7,6,9,8,2,1,3,0};
        int max = max(arr);
        System.out.println(max);
    }

    public static int max(int[] arr){
        int maxIndex = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]>arr[maxIndex])
                maxIndex = i;
        }
        return arr[maxIndex];
    }
}
/*
$ java ArrayToolsDemo2
9
*/
```

### 阶段三____类

当有很多个关于数组的函数，一个较为好的代码管理办法是将其封装在一个数组工具类中，这样的话无论使用者要调用哪个关于数组的函数，只要找到这个数组工具类就可以了

```java
class ArrayTools{
    public int getMax(int[] arr){
        int maxIndex = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]>arr[maxIndex])
                maxIndex = i;
        }
        return arr[maxIndex];
    }
    public void selectSort(int[] arr){
        for(int i=0;i<arr.length;i++){
            for(int j=i;j<arr.length;j++){
                if(arr[j] < arr[i])
                    swap(arr, i, j);
            }
        }
    }
    private void swap(int[] arr, int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public void print(int[] arr){
        System.out.print("[");
        for(int i=0;i<arr.length-1;i++){
            System.out.print(arr[i]+",");
        }
        System.out.print(arr[arr.length-1]+"]");
        System.out.print('\n');
    }
}
class ArrayToolsDemo3{
    public static void main(String[] args){
        int[] arr = {5,4,7,6,9,8,2,1,3,0};
        ArrayTools tool = new ArrayTools();
        tool.print(arr);
        tool.selectSort(arr);
        tool.print(arr);
    }
}
/*
$ java ArrayToolsDemo3
[5,4,7,6,9,8,2,1,3,0]
[0,1,2,3,4,5,6,7,8,9]
*/
```

### 阶段四____静态

我们仔细观察程序不难发现，我们ArrayTools类中所有的函数只需要给定参数就可以正常运行，用不到类对象任何特有的数据，所以建立ArrayTools类的对象是无意义的，所有函数应该为静态，可以由类名直接访问

```java
class ArrayTools{
    public static int getMax(int[] arr){
        int maxIndex = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]>arr[maxIndex])
                maxIndex = i;
        }
        return arr[maxIndex];
    }
    public static void selectSort(int[] arr){
        for(int i=0;i<arr.length;i++){
            for(int j=i;j<arr.length;j++){
                if(arr[j] < arr[i])
                    swap(arr, i, j);
            }
        }
    }
    private static void swap(int[] arr, int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void print(int[] arr){
        System.out.print("[");
        for(int i=0;i<arr.length-1;i++){
            System.out.print(arr[i]+",");
        }
        System.out.print(arr[arr.length-1]+"]");
        System.out.print('\n');
    }
}
class ArrayToolsDemo4{
    public static void main(String[] args){
        int[] arr = {5,4,7,6,9,8,2,1,3,0};
        ArrayTools.print(arr);
        ArrayTools.selectSort(arr);
        ArrayTools.print(arr);
    }
}
/*
$ java ArrayToolsDemo4
[5,4,7,6,9,8,2,1,3,0]
[0,1,2,3,4,5,6,7,8,9]
*/
```

### 阶段五____私有化构造函数

该类不需要建立对象就可以使用，但是使用者可能会建立对象来使用，这只会白白地浪费空间，为了防止这种情况将类的构造函数私有化，不允许类外建立对象。

```java
class ArrayTools{
    private ArrayTools(){}
    public static int getMax(int[] arr){
        int maxIndex = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]>arr[maxIndex])
                maxIndex = i;
        }
        return arr[maxIndex];
    }
    public static void selectSort(int[] arr){
        for(int i=0;i<arr.length;i++){
            for(int j=i;j<arr.length;j++){
                if(arr[j] < arr[i])
                    swap(arr, i, j);
            }
        }
    }
    private static void swap(int[] arr, int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    public static void print(int[] arr){
        System.out.print("[");
        for(int i=0;i<arr.length-1;i++){
            System.out.print(arr[i]+",");
        }
        System.out.print(arr[arr.length-1]+"]");
        System.out.print('\n');
    }
}
class ArrayToolsDemo5{
    public static void main(String[] args){
        int[] arr = {5,4,7,6,9,8,2,1,3,0};
        ArrayTools.print(arr);
        ArrayTools.selectSort(arr);
        ArrayTools.print(arr);
    }
}
/*
$ java ArrayToolsDemo5
[5,4,7,6,9,8,2,1,3,0]
[0,1,2,3,4,5,6,7,8,9]
*/
```

### 阶段六____文档的使用

这个类我要是分享给别人使用的话，测试类ArrayToolsDemo肯定不用分享给别人，从没听过下载qq还附带qq的测试程序的，所以我们要将类ArrayTools单独写在一个文件里，为了文件外能够访问该类，要改变该类的权限为public，同时还要写文档来说明这个类里边都有哪些东西可用以及它们该怎么用

```java
/**
* 数组工具类，包含：求数组最大值、选择排序、打印数组功能
* @author geekavan
* @version v1.0
*/
public class ArrayTools{
    private ArrayTools(){}
    /**
     * 求数组最大值
     * @param arr 输入int[]类型数组
     * @return 该数组的最大值
    */
    public static int getMax(int[] arr){
        int maxIndex = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]>arr[maxIndex])
                maxIndex = i;
        }
        return arr[maxIndex];
    }
    /**
     * 选择排序
     * @param arr 需要排序的数组int[]类型
    */
    public static void selectSort(int[] arr){
        for(int i=0;i<arr.length;i++){
            for(int j=i;j<arr.length;j++){
                if(arr[j] < arr[i])
                    swap(arr, i, j);
            }
        }
    }
    private static void swap(int[] arr, int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    /**
     * 打印数组
     * @param arr 需要打印的数组int[]类型
    */
    public static void print(int[] arr){
        System.out.print("[");
        for(int i=0;i<arr.length-1;i++){
            System.out.print(arr[i]+",");
        }
        System.out.print(arr[arr.length-1]+"]");
        System.out.print('\n');
    }
}
/*
javadoc -encoding utf-8 -d myhelp ArrayTools.java //javadoc命令用于生成文档-d myhelp表示生成的文档存在于myhelp文件夹下，使用时请打开myhelp文件夹下的index.html文件
正在加载源文件ArrayTools.java...
正在构造 Javadoc 信息...
正在创建目标目录: "myhelp\"
标准 Doclet 版本 1.8.0_201
正在构建所有程序包和类的树...
正在生成myhelp\ArrayTools.html...
正在生成myhelp\package-frame.html...
正在生成myhelp\package-summary.html...
正在生成myhelp\package-tree.html...
正在生成myhelp\constant-values.html...
正在构建所有程序包和类的索引...
正在生成myhelp\overview-tree.html...
正在生成myhelp\index-all.html...
正在生成myhelp\deprecated-list.html...
正在构建所有类的索引...
正在生成myhelp\allclasses-frame.html...
正在生成myhelp\allclasses-noframe.html...
正在生成myhelp\index.html...
正在生成myhelp\help-doc.html...
*/
```

```java
class ArrayToolsDemo6{
    public static void main(String[] args){
        int[] arr = {5,4,7,6,9,8,2,1,3,0};
        ArrayTools.print(arr);
        ArrayTools.selectSort(arr);
        ArrayTools.print(arr);        
    }
}
/*
$ java ArrayToolsDemo6
[5,4,7,6,9,8,2,1,3,0]
[0,1,2,3,4,5,6,7,8,9]
*/
```


# 08_08Java中的单继承

单继承：一个类只有一个直接父类

多继承：一个类可以有多个直接父类

Java中只支持单继承，不支持多继承，但对C++中的多继承进行了改良

# 08_10_11子父类中的成员变量特点及内存图解

1.当类中成员变量和局部变量重名时，使用this关键字来区分

当子类成员和父类成员重名时，使用super关键字来区分

2.this关键字代表的是所属类的对象的引用

super关键字代表的是父类所在空间

接下来我们看一下下面这个函数的内存图解

```java
class ExtendsDemo{
    public static void main(String[] args){
        Zi z = new Zi();
        z.show();
    }
}
class Fu{
    String str = "fuStr";
}
class Zi extends Fu{
    String str = "ziStr";
    public void show(){
        System.out.println(this.str+"......"+super.str);
    }
}
```

1.当我们运行java ExtendsDemo这个命令时，就相当于执行ExtendsDemo.main()这个静态函数，所以说ExtendsDemo这个类先加载到内存(方法区)

2.随后该执行main函数，main函数入栈

3.用到了Zi类(指new Zi()语句)，Zi类有一个父类Fu，那么先将Fu加载到方法区，之后将子类Zi加载到方法区，子类Zi中有一个super指向父类Fu内存区

4.new关键字会在堆中开辟一片区域，建立Zi对象，在这一边区域中开辟两个小区域，一个用来储存Fu类中的成员变量str，其初始化为null，之后赋值为fuStr(如有构造代码块的话，赋值操作与构造代码块按语句先后顺序执行，两者都在构造函数之前执行)，之后调用Fu类构造函数；令一个用来存储Zi类中的成员变量str，其初始化为null，之后赋值为ziStr(如有构造代码块的话，赋值操作与构造代码块按语句先后顺序执行，两者都在构造函数之前执行)，之后调用Zi类构造函数

5.随后对象初始化完毕，将Zi对象的引用赋值给栈中的Zi类类型的变量z

6.调用子类的方法show，show方法进栈，根据show放里边的this在堆中查找Zi类型对象，输出this.str与super.str的值

7.show方法弹栈，main方法弹栈

# 08_12子父类中的成员函数特点

### 成员函数的覆盖

```java
class ExtendsDemo3{
    public static void main(String[] args){
        Zi z = new Zi();
        z.show1();
    }
}
class Fu{
    void show1(){
        System.out.println("Fu show run");
    }
}
class Zi extends Fu{
    void show2(){
        System.out.println("Zi show run");
    }
}
/* 
$ java ExtendsDemo3
Fu show run
*/
```

上述程序运行过程简写，如想看详细过程请参考__内存图解大综合__章节

1.ExtendsDemo3类加载到内存(方法区)

2.主函数main进栈

3.Fu类加载进内存

4.Zi类加载进内存，其super指向其父类Fu所在内存空间

5.堆内存中建立Zi类对象

6.在本类Zi中查找show1函数，本类没有

7.通过super在其父类中寻找show1函数，找到了，show1入栈

8.show1执行，show1弹栈

9.main弹栈

下面这段程序与上述程序的区别为下面这段程序的子父类成员函数名称都为show

```java
class ExtendsDemo3{
    public static void main(String[] args){
        Zi z = new Zi();
        z.show();
    }
}
class Fu{
    void show(){
        System.out.println("Fu show run");
    }
}
class Zi extends Fu{
    void show(){
        System.out.println("Zi show run");
    }
}
/* 
$ java ExtendsDemo3
Zi show run
*/
```

上述程序运行过程简写，如想看详细过程请参考__内存图解大综合__章节

1.ExtendsDemo3类加载到内存(方法区)

2.主函数main进栈

3.Fu类加载进内存

4.Zi类加载进内存，其super指向其父类Fu所在内存空间

5.堆内存中建立Zi类对象

6.在本类Zi中查找show函数，本类存在show函数，并不继续在其父类中寻找，show入栈

7.show执行，show弹栈

8.main弹栈

我们通过子类对象调用的都是子类的show方法，看起来父类的show方法就像被覆盖掉了一样，所以称之为覆盖，也称之为重写，覆写

# 09

# 09_01_02_03一个对象的实例化过程

一个对象实例化过程：

Person p = new Person();

1.JVM会读取指定目录下的Person.class文件并加载进内存，并先加载Person的父类(如果Person有直接父类的情况下)

2.在堆内存中开辟空间并分配地址

3.对对象进行默认初始化

4.执行子类Person的构造函数

5.在构造函数的第一行有一条默认的语句super();因此会先执行其父类的构造函数进行初始化

6.在父类初始化完毕后(类似子类初始化步骤)，**再执行子类的构造代码块初始化(10_18内容)**，再执行子类的显示初始化

7.执行子类的构造初始化

8.初始化完毕后，将地址值赋给引用变量

# 09_04final关键字

1.final关键字可以修饰类、方法、变量

2.final关键字修饰的类不可以不继承

3.final关键字不可以被覆盖

4.final修饰的变量不能被改变，成为常量，只能被赋值一次

    为什么要用final关键字修饰变量？
    在程序中如果一个数据是固定的，那么直接使用该数据就可以了，但是那样阅读性比较差，所以要给他起一个名字，又因为数据不可以改变，所以搞一个final关键字固定他

5.写法规范：所有字母均大写，多个单词的话中间使用下划线分隔

6.类中的常量一般是静态的，因为常量的话意味着所有对象的该值都一致，即该值被所有对象共享，所以为静态。

这里复习一下静态的特点：

    1.随着类的加载进入方法区的静态区中，优先于对象存在
    2.被该类的所有对象所共享
    3.可以由类名直接调用

# 09_05_06_07抽象类的特点和细节

抽象类的特点

    1.被abstract关键字修饰的类称为抽象类

    2.当函数没有方法体时，该函数就是抽象函数，只能被定义在抽象类中

    3.抽象类不能被实例化，因为即使有对象的话也不能调用其抽象方法

    4.抽象类的子类必须覆盖了抽象父类的所有抽象方法才能够成为一般类，不然也是一个抽象类

关于抽象类的五个问题：

1.抽象类有构造函数吗？

    有。虽然抽象类不能创建对象，但是其构造函数可以给子类对象初始化

2.抽象类里可以没有抽象方法吗？

    可以，但是很少见，为的就是不让其创建对象。ATW适配器类就是这种类

    一般地这种类中的方法有方法体，但是没有内容，如：

    class Demo(){
        void show()
        {}
        void print()
        {}
    }

3.abstract关键字不能和哪些关键字共存？

    private不行，因为抽象方法必须要由子类覆盖，而当该方法私有化之后子类不知道有该方法，也就不能够覆盖该方法

    static不行，因为static修饰之后意味着类名可以直接调用该方法，而该方法没有被覆盖前根本无方法体

    final不能，因为final修饰的方法不能被覆盖，而抽象方法又必须要被覆盖

4.抽象类和一般类的异同点？

    相同点：
    抽象类和一般类都是用来描述事物的，内部都定义了成员
    不同点：
    一般类有足够的信息描述事物，抽象类描述事物的信息不足
    一般类中不可以定义抽象方法，抽象类中即可以定义抽象方法，又可以定义非抽象方法
    一般类可以被实例化，抽象类不可以被实例化

# 09_09_10接口的定义与实现

### 09_09接口的定义

接口和抽象类很类似，只不过接口中的方法都是抽象的，不可以有非抽象方法；抽象类中既可以有抽象方法，又可以有非抽象方法

接口中成员的修饰符是固定的：

1.成员变量：public static final

2.成员函数：public abstract

不加的话编译器也会自动给你加上

```java
interface Demo{
    public static final NUM = 4;
    public abstract void show();
}
```

### 09_10接口的实现

类与类之间可以有继承关系，但是只能单继承；类与接口之间可以有实现关系；接口与接口之间可以有继承关系，并且接口支持多继承

接口不可以被实例化，只有当一个接口中的所有抽象方法均被其子类实现之后该子类才可以被实例化，否则该子类是一个抽象类

```java
interface Demo{
    public static final int NUM = 4;
    public abstract void show1();
    public abstract void show2();
}
class DemoImpl implements Demo{
    public void show1()
    {}
    public void show2()
    {}
}
class InterfaceDemo{
    public static void main(String[] args){
        DemoImpl d = new DemoImpl();
        System.out.println(d.NUM);
        System.out.println(DemoImpl.NUM);
        System.out.println(Demo.NUM);
    }
}
/*
$ java InterfaceDemo
4
4
4
*/
```

# 09_11_12接口的多实现_接口之间的多继承

```java
interface A{
    public abstract void showA();
}
interface B{
    public abstract void showB();
}
interface C extends A,B/*接口的多继承*/{
    public abstract void showC();
}
class Demo implements A,B/*接口的多实现*/{
    public void showA()
    {}
    public void showB()
    {}
}
```

为什么接口可以实现多继承(也是接口可以多实现的原因)，而类不可以多继承？

1.因为类多继承的话可以会出现调用的不确定性，示例程序如下，如果有类C同时继承了类A与类B的话，那么类C对象调用show方法的时候是调用类A的show方法还是类B的show方法呢？所以java不支持多继承(其实有其他的解决方式，使得python等支持多继承)

```java
class A{
    void show(){
    }
}
class B{
    void show(){
    }
}
```

2.但是如果是接口的话就不会出现调用的不确定性，示例如下，如果有接口C同时继承了接口A与接口B，那么有类D实现了接口C，类D对象调用show方法的时候也根本不会出现调用的不确定性，他只会老老实实地调用类D中show的实现方法。

```java
interface A{
    void show();
}
interface B{
    void show();
}
```

概括：

接口的多继承与多实现并不会使程序出现调用的不确定性

# 10

# 10_03多态的好处

何为多态？

    一个对象，两种形态，如：

    动物 kitty = new 猫();

    其中：

    ```java
    class 动物{}
    class 猫 extends 动物{}
    ```

    猫类对象kitty既有猫类特征，又具备动物类特征


多态的代码体现

    父类类型(或接口类型)引用变量可以指向其子类(或其实现类)的对象

多态的好处

    提高了代码的可扩展性，前期的代码可以使用后期的内容

多态好处演示示例：

前期的代码：

```java
class AlgorithmsSort{
    public static void exch(Comparable[] a, int i, int j){
        Comparable temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
    public static boolean less(Comparable i, Comparable j){
        return i.compareTo(j)<0;
    }
    public static boolean isSorted(Comparable[] a){
        for(int i=0;i<a.length-1;i++){
            if(!less(a[i],a[i+1]))
                return false;
        }
        return true;
    }
    public static void selectSort(Comparable[] a){
        int minIndex = 0;
        for(int i=0;i<a.length;i++){
            for(int j=i;j<a.length;j++){
                if(!less(a[i],a[j]))
                    minIndex = j;
            }
            exch(a, i, minIndex);
        }
    }
    public static void main(String[] args){
        Integer[] arr = {9,8,7,6,3,2,5,4,1,10,11,12,13,15,14,19,17,18,16};
        show(arr);
        selectSort(arr);
        assert isSorted(arr);
        show(arr);
    }
}
```

后期的代码，后期加入了Student类

```java
class Student implements Comparable{
    private final String name;
    private final int grade;
    Student(String name, int grade){
        this.name=name;
        this.grade=grade;
    }
    public String getName(){return this.name;}
    public int getGrade(){return this.grade;}
    public int compareTo(Student that){
        if(this.grade>that.grade) return 1;
        if(this.grade<that.grdee) return -1;
        return 0;
    }
}
```

后期的测试代码变为：

```java
    public static void main(String[] args){
        // Integer[] arr = {9,8,7,6,3,2,5,4,1,10,11,12,13,15,14,19,17,18,16};
        // show(arr);
        // selectSort(arr);
        // assert isSorted(arr);
        // show(arr);

        Student[] s = new Student[7];
        s[0] = new Student("张十五", 15);        
        s[1] = new Student("李六五", 65);
        s[2] = new Student("王三七", 37);
        s[3] = new Student("赵八九", 89);
        s[4] = new Student("何四七", 47);        
        s[5] = new Student("余五五", 55);        
        s[6] = new Student("廖二三", 23);
        selectSort(s);
        showS(s);
    }
    public static void showS(Student[] s){
        for(int i=0;i<s.length;i++){
            if(i==(s.length-1)){
                System.out.print(s[i].getName()+":"+s[i].getGrade());
                continue;
                }
            System.out.print(s[i].getName()+":"+s[i].getGrade()+",");
        }
    }
/*
$ java AlgorithmsSort
张十五:15,廖二三:23,王三七:37,何四七:47,余五五:55,李六五:65,赵八九:89
*/
```

点评：

1.后期的Student类实现了Comparable接口，使得后期的Student类可以使用前期定义的selectSort方法，这是由多态特性提供支持的

2.测试代码(main函数部分)其实和AlgorithmsSort类无关，应该抽离

3.我们所用的showS方法去打印一个Student类的数组，但是如何打印应该是Student类最清楚，也就是说打印的方法应该封装到Student类之中，但是要是打印一堆类，也就是上述代码中的一个数组的类该怎么封装到Student类之中呢？

# 10_05_06多态转型

```java
class 毕姥爷{
    void 讲课(){
        System.out.println("管理");
    }
    void 钓鱼(){
        System.out.println("钓鱼");
    }
}
class 毕老师 extends 毕姥爷{
    void 讲课(){
        System.out.println("讲课");
    }
    void 看电影(){
        System.out.println("看电影");
    }
}
class DuoTaiDemo{
    public static void main(String[] args){
        毕姥爷 b = new 毕老师();//向上转型，使得屏蔽了子类(或实现类)的特有方法
        b.讲课();//但是至始至终堆内存中只有一个对象毕老师，所以调用的是毕老师的讲课方法
        b.钓鱼();
        //b.看电影();//毕老师已经化妆成为毕姥爷，根本没有看电影方法
        /*
        $ javac -encoding utf-8 DuoTaiDemo.java
        DuoTaiDemo.java:22: 错误: 找不到符号
                b.看电影();
                 ^
        符号:   方法 看电影()
        位置: 类型为毕姥爷的变量 b
      1 个错误
        */
        毕老师 bb = (毕老师)b;//向下转型，使得可以调用子类(或实现类)的特有方法
        bb.看电影();
    }
}
/*
$ javac -encoding utf-8 DuoTaiDemo.java
$ java DuoTaiDemo
讲课
钓鱼
看电影
*/
```

# 10_08_09_10多态下的成员变量_成员函数(非静态)_静态函数

### 10_08多态下的成员变量

编译时：参考引用变量所属类的成员变量，有则编译通过，无则编译失败

运行时：参考引用变量所属类的成员变量，输出引用变量所属类的成员变量

简单说：编译看等号左边，运行也看等号左边

```java
class Fu{
    String name="Fu";
}
class Zi extends Fu{
    String name="Zi";

}
class DuoTaiDemo2{
    public static void main(String[] args){
        Fu f = new Zi();
        System.out.println(f.name);
    }
}
/*
$ java DuoTaiDemo2
Fu
*/
```

### 10_09多态下的成员函数非静态

编译时：参考引用变量所属类的成员函数，有则编译通过，无则编译失败

运行时：调用对象所属类的成员函数

简单说：编译看左边，运行看右边

```java
class Fu{
    public void show(){
        System.out.println("Fu show");
    }
}
class Zi extends Fu{
    public void show(){
        System.out.println("Zi show");
    }
}
class DuoTaiDemo3{
    public static void main(String[] args){
        Fu f = new Zi();
        f.show();
    }
}
/*
$ java DuoTaiDemo3
Zi show
*/
```

### 10_10多态下的静态函数

编译时：看引用变量所属类的静态成员函数，有则编译通过，无则编译失败

运行时：输出引用变量所属类的静态成员函数

简单说：编译看左边，运行也看左边

注意：其实一般说是对象的多态性，像静态函数的话，没必要创建对象去调用，也就没有调用的相关问题

```java
class Fu{
    public static void show(){
        System.out.println("Fu show");
    }
}
class Zi extends Fu{
    public static void show(){
        System.out.println("Zi show");
    }
}
class DuoTaiDemo4{
    public static void main(String[] args){
        //Fu.show();
        //Zi.show();
        Fu f = new Zi();
        f.show();
    }
}
/*
$ java DuoTaiDemo4
Fu show
*/
```

### 总结

总结：

1.多态下成员变量与静态函数在调用时，编译与运行看的都是等号左边，

2.多态下非静态成员函数在调用时，编译看的是等号左边，运行看的是等号右边

# 10_11内部类概述

### 内部类编译后生成的.class文件

```java
class Outer{
    class Inner{
    }
}
class InnerClassDemo{
    public static void main(String[] args){
    }
}
```

编译后生成的.class文件

![内部类编译后生成的.class文件](https://github.com/geekavan/BiXiangdong/blob/master/%E5%86%85%E9%83%A8%E7%B1%BB%E7%BC%96%E8%AF%91%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84.class%E6%96%87%E4%BB%B6.png)

注意内部类生成的文件为Outer$Inner.class

### 内部类访问的特点

内部类可以直接访问外部类的成员

外部类若想访问内部类的成员，需要建立内部类对象

```java
class Outer{
    private int num = 3;
    class Inner{
        void show(){
            System.out.println("num......"+num);//内部类可以直接访问外部类的成员
        }
    }
    public void method(){
        Inner in = new Inner();//外部类若想访问内部类的成员，需要建立内部类对象
        in.show();
    }
}
class InnerClassDemo2{
    public static void main(String[] args){
    }
}
```

### 10_12内部类修饰符

1.建立内部类(非静态)对象访问内部类成员(非静态)：

```java
class Outer{
    private int num = 4;
    class Inner{
        public void show(){
            System.out.println("show run ..."+num);
        }
    }
}
class InnerClassDemo121{
    public static void main(String[] args){
        /*Outer.Inner指明是Outer类的内部类Inner类类型的引用变量，
        因为内部类Inner相当于外部类Outer的成员，所以要建立对象访问(因为非静态)，
        因为要访问的是Inner类的成员，所以也需要建立内部类Inner类的对象
        */
        Outer.Inner in = new Outer().new Inner();
        in.show();
    }
}
```

2.建立内部类(静态)对象，访问内部类成员(非静态)以及访问静态内部类静态成员

```java
class Outer{
    private static int  num = 4;
    static class Inner{
        public void show(){
            System.out.println("show run ..."+num);
        }
        public static void method(){
            System.out.println("method run ..."+num);
        }
    }
}
class InnerClassDemo122{
    public static void main(String[] args){
        /*由于内部类Inner类是静态的，是随着Outer的加载而进入内存的，
        所以可以直接通过new Outer.Inner();来创建Inner类对象 
        */
        Outer.Inner in = new Outer.Inner();
        in.show();

        /*访问静态内部类静态成员可以直接使用
        外部类.内部类.静态成员 
        格式
        */
        Outer.Inner.method();
    }
}
/*
$ java InnerClassDemo122
show run ...4
method run ...4
*/
```

3.如果内部类成员是静态的，那么该内部类也必须是静态的

其实这一点很好理解，因为如果内部类成员是静态的，那么意味着该内部类成员可以使用内部类类名直接调用，而内部类是非静态的，无法通过外部类直接调用

### 10_13内部类细节

```java
class Outer{
    int num = 3;
    class Inner{
        int num = 4;
        void show(){
            int num = 5;
            System.out.println("num ..."+num);
            System.out.println("this.num ..."+this.num);
            System.out.println("Inner.this.num ..."+Inner.this.num);
            System.out.println("Outer.this.num ..."+Outer.this.num);
        }
    }
}
class InnerClassDemo13{
    public static void main(String[] args){
        Outer.Inner in = new Outer().new Inner();
        in.show();
    }
}
/*
$ java InnerClassDemo13
num ...5
this.num ...4
Inner.this.num ...4
Outer.this.num ...3
*/
```

### 10_15_16_17匿名内部类

内部类形式

```java
interface Demo{
    public abstract void show();
}
class Outer{
    class Inner{
        public void show(){
        }
    }
    public void method(){
        Inner in = new Inner();
        in.show();
    }
}
class InnerClassDemo15{
    public static void main(String[] args){
        new Outer().method();
    }
}
```

匿名内部类形式

```java
interface Demo{
    public abstract void show();
}
class Outer{
    //匿名内部类形势下就没有内部类了
    // class Inner{
    //     public void show(){
    //     }
    // }
    public void method(){
        //下面就是匿名内部类，实际上是接口(父类)的实现类(子类)的对象
        new Demo(){
            public void show(){}
        };

        //其调用show方法
        // new Demo(){
        //     public void show(){}
        // }.show();
    }
}
class InnerClassDemo152{
    public static void main(String[] args){
        new Outer().method();
    }
}
```

实际上就是创建对象的一种简写格式而已，避免书写接口的实现类，直接在建立接口对象时覆盖接口方法(实际上就是创建了接口的一个实现类的对象)(接口换为抽象类类似)

复习多态

```java
interface Demo{
    public abstract void show();
}
class Outer{
    public void method(){
        Demo d = new Demo(){//相当于对于接口Demo的一个匿名实现类进行了向上转型，就隐藏了
        //子类(实现类)特有方法，对于方法的多态来说，编译看左边，运行看右边
        //左边接口Demo中并没有function方法，所以会报错
            public void show(){}
            public void function(){}
        };
        d.show();
        d.function();
    }
}
class InnerClassDemo153{
    public static void main(String[] args){
        new Outer().method();
    }
}
/*
$ javac -encoding utf-8 InnerClassDemo153.java
InnerClassDemo153.java:11: 错误: 找不到符号
        d.function();
         ^
  符号:   方法 function()
  位置: 类型为Demo的变量 d
1 个错误
*/
```

请查看代码并考虑输出结果

```java
class InnerClassDemo154{
    class Inner{}
    public static void main(String[] args){
        new Inner();//因为Inner是内部类，相当于InnerClassDemo154类的成员
        //引用成员时为this.new Inner();但是static方法不能够持有this关键字
        //所以会报错
    }
    public void method(){
        new Inner();
    }
}
/*
$ javac -encoding utf-8 InnerClassDemo154.java 
InnerClassDemo154.java:4: 错误: 无法从静态上下文中引用非静态 变量 this
        new Inner();
        ^
1 个错误
*/
```

# 11

# 11_02异常体系

所有程序的异常类都继承于Throwable类，都具备可抛性

    Throwable——|---Error，一般不可以处理
               |---Exception，可以处理——|--编译时可以被检测异常
                                       |--RuntimeException

# 11_03_04_05异常的抛出

```java
class IDException extends Exception/*继承了异常类Exception，成为异常体系的一员*/{
    IDException(){}
    IDException(String s){
        //super(s);
        //printStackTrace();
    }
}

class Person{
    String name;//为了节约篇幅，这里不将name设为私有属性，免为其设置set与get方法，本博客多处不将类属性设置为私有
    private String ID;
    Person(String name){
       Person.this.name = name;
    }
    public void setID(String ID) throws IDException{/*该方法可能会抛出IDException异常*/
        String IDtrim = ID.trim();
        char[] IDCharArray = IDtrim.toCharArray();
        if(!isIDNumbersRight(IDCharArray))
            throw new IDException("身份证号码输入错误，请重新输入！");//当身份证号码不符合规范时，抛出IDException异常类对象
        this.ID = ID;
    }
    public String getID(){
        return this.ID;
    }
    private boolean isIDNumbersRight(char[] arr){
        int[] multiTable = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
        if(arr.length!=18)
            return false;
        int[] arrInt = new int[18];
        for(int i=0;i<17;i++){
            if(!Character.isDigit(arr[i]))
                return false;
            arrInt[i] = (int)(arr[i])-(int)('0');
        }
        char arr17 = arr[17];
        if(arr17=='1')
            arrInt[17] = 12;
        else if (arr17=='0')
            arrInt[17] = 11;
        else if(arr17=='X' || arr17=='x')
            arrInt[17]=10;
        else
            arrInt[17]=(int)(arr[17])-(int)('0');
        int sum = 0;
        for(int i=0;i<17;i++){
            sum += arrInt[i]*multiTable[i];
        }
        sum = 12 - (sum%11);
        if(sum==arrInt[17])
            return true;
        else
            return false;
    }
}

class ExceptionDemo03_04_05{
    public static void main(String[] args)throws IDException{
        Person x = new Person("小明");
        //当我要使用Person类中的setID方法时，从方法的签名我就知道该方法可能会抛出IDException的异常
        //那么当我调用该方法时，我就有两种选择，捕捉或者抛出，这里演示抛出，那么main函数就可能抛出异常
        //我们要在main函数签名上标识出来，main函数抛给虚拟机
        x.setID("012345678901234561");//012345678901234560正确的校验码
    }
}
/*
$ java ExceptionDemo03_04_05
Exception in thread "main" IDException
        at Person.setID(ExceptionDemo03_04_05.java:19)
        at ExceptionDemo03_04_05.main(ExceptionDemo03_04_05.java:62)
*/
```

# 11_06_07_08异常的捕捉

```java
class IDException extends Exception/*继承了异常类Exception，成为异常体系的一员*/{
    IDException(){}
    IDException(String s){
        super(s);
        printStackTrace();
    }
}
class Person{
    String name;//为了节约篇幅，这里不将name设为私有属性，免为其设置set与get方法，本博客多处不将类属性设置为私有
    private String ID;
    Person(String name){
       Person.this.name = name;
    }
    public void setID(String ID) throws IDException{/*该方法可能会抛出IDException异常*/
        String IDtrim = ID.trim();
        char[] IDCharArray = IDtrim.toCharArray();
        if(!isIDNumbersRight(IDCharArray))
            throw new IDException("身份证号码输入错误，请重新输入！");//当身份证号码不符合规范时，抛出IDException异常类对象
        this.ID = ID;
    }
    public String getID(){
        return this.ID;
    }
    private boolean isIDNumbersRight(char[] arr){
        int[] multiTable = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
        if(arr.length!=18)
            return false;
        int[] arrInt = new int[18];
        for(int i=0;i<17;i++){
            if(!Character.isDigit(arr[i]))
                return false;
            arrInt[i] = (int)(arr[i])-(int)('0');
        }
        char arr17 = arr[17];
        if(arr17=='1')
            arrInt[17] = 12;
        else if (arr17=='0')
            arrInt[17] = 11;
        else if(arr17=='X' || arr17=='x')
            arrInt[17]=10;
        else
            arrInt[17]=(int)(arr[17])-(int)('0');
        int sum = 0;
        for(int i=0;i<17;i++){
            sum += arrInt[i]*multiTable[i];
        }
        sum = 12 - (sum%11);
        if(sum==arrInt[17])
            return true;
        else
            return false;
    }
}
class ExceptionDemo{
    public static void main(String[] args){
        Person x = new Person("小明");
        //当我要使用Person类中的setID方法时，从方法的签名我就知道该方法可能会抛出IDException的异常
        //那么当我调用该方法时，我就有两种选择，捕捉或者抛出，这里先演示捕捉
        try{
            x.setID("012345678901234561");//012345678901234560正确的校验码
        }
        catch(IDException e){
            System.out.println("捕捉到异常，此处为处理代码");
        }
    }
}
/*
$ java ExceptionDemo
IDException: 身份证号码输入错误，请重新输入！
        at Person.setID(ExceptionDemo.java:19)
        at ExceptionDemo.main(ExceptionDemo.java:62)
捕捉到异常，此处为处理代码
*/
```

多catch情况，当一个函数可能抛出多个异常的时候，就需要我们对每个异常进行针对性的处理，就会出现多个catch的情况，示例程序如下(程序中我们异常类继承的是RuntimeException类，为运行时异常，异常情况其实java都已经考虑到了，我们只是为了示例，才选择此两类异常)：

```java
public class ExceptionDemo08{
    public static void main(String[] args){
        int[] arr = new int[3];
        try{findNumber(arr, 3);}
        catch(FuShuIndexException e){
            System.out.println("负索引异常");
        }
        catch(IndexOutOfLengthExcepion e){
            System.out.println("索引越界异常");
        }
    }
    static int findNumber(int[] arr,int index) throws FuShuIndexException,IndexOutOfLengthExcepion{
        if(index<0){
            throw new FuShuIndexException("索引非法！索引不可以小于0");
        }
        if(index>=arr.length){
            throw new IndexOutOfLengthExcepion("索引非法！索引不可以大于或等于数组长度");
        }
        return arr[index];
    }
}
class FuShuIndexException extends RuntimeException{
    FuShuIndexException(String s){super(s);}
}
class IndexOutOfLengthExcepion extends RuntimeException{
    IndexOutOfLengthExcepion(String s){super(s);}
}
/*
$ java ExceptionDemo08
索引越界异常
*/
```

# 11_09finally

finally一定会(其实也不一定)执行的代码块

```java
class ExceptionDemo09{
    static void show(int[] arr, int index) throws ArrayIndexOutOfBoundsException{
        if(index<0){
            throw new ArrayIndexOutOfBoundsException("越界啦!");
        }
    }
    public static void main(String[] args){
        int[] arr = new int[3];
        try{
            show(arr, -3);}
        catch(ArrayIndexOutOfBoundsException e){
            //处理代码
            System.out.println("catch");
            return;
        }
        finally{
            System.out.println("finally");
        }
    }
}
/*
$ java ExceptionDemo09
catch
finally
*/
```

进行下面改动之后，finally就没有执行

```java
class ExceptionDemo09{
    static void show(int[] arr, int index) throws ArrayIndexOutOfBoundsException{
        if(index<0){
            throw new ArrayIndexOutOfBoundsException("越界啦!");
        }
    }
    public static void main(String[] args){
        int[] arr = new int[3];
        try{
            show(arr, -3);}
        catch(ArrayIndexOutOfBoundsException e){
            //处理代码
            System.out.println("catch");
            System.exit(0);//退出jvm
        }
        finally{
            System.out.println("finally");
        }
    }
}
/*
$ java ExceptionDemo09
catch
*/
```

异常捕获关键字组合形式：

1.try_catch_finally组合

2.try_catch组合，这时候不需要关闭资源

3.try_finally组合，比较常见，问题本方法中处理不了，但是可能会在try中打开了资源，在抛出异常语句处
程序就要跳转了，我们必须在本方法内将打开的资源关闭，释放资源

# 11_10异常的应用

建议看本部分视频

我现在有数据，我要将数据添加到数据库之中，调用数据库的addData方法

```java
void addData(Data d){
    //连接数据库
    //添加数据
    //关闭连接
}
```

那么我如果添加失败怎么办？抛出一个异常就好了啊

```java
void addData(Data d) throws SQLException{
    //连接数据库
    //添加数据
    if(//添加失败)
        throw new SQLException();
    //关闭连接
}
```

但是这么做合适吗？调用者现在有数据，就是想将这些数据通过你的方法加入到数据库中，你给我来一个这个方法可能出现SQLException异常，调用者可能数据库基本命令都玩不转，怎么知道如何处理该异常呢？怎么处理恐怕还是该函数的编写者最清楚，那么最好还是在添加数据的函数内部将该异常捕捉并处理了

```java
void addData(Data d){
    try{
    //连接数据库
    //添加数据
    }
    catch(SQLException e){
        //连接失败的处理代码
    }
    finally{
        //关闭连接
    }
}
```

这么做就合适了吗？调用者通过该方法添加数据，但是添加失败了，该方法却没有任何回馈(对于该异常它内部捕捉并进行处理了)，调用者以为添加成功了，但是打开数据库一看，却发现并没有成功，这不太合适，这是对问题进行了隐藏。我们还是要通知调用者出现了异常

```java
class NoAddException{

}
void addData(Data d)throws NoAddException/*这称之为异常的转换*/{
    try{
    //连接数据库
    //添加数据
    }
    catch(SQLException e){
        //连接失败的处理代码
        throw new NoAddException();//这称之为异常的转换
    }
    finally{
        //关闭连接
    }
}
```

那么调用者发现该函数签名中有添加失败异常就可以处理了。该方法告知调用者，该方法可能会添加数据失败，添加数据失败后程序怎么处理的，没告诉你，你也不需要知道

# 11_11异常的注意事项

1.当子类重写父类方法时，该子类的该方法可以抛出的异常类只能是父类该方法抛出的异常类的子类或者子集

2.当子类重写父类方法时，该父类的该方法没有抛出异常，那么该子类的该覆盖方法不可以抛出异常

3.当子类重写父类方法时，该父类的该方法抛出了异常，那么该子类的该覆盖方法可以不抛出异常

为什么呢？示例如下：

```java
class AException extends Exception{}
class BException extends AException{}
class CException extends Exception{}
class Fu{
    void show()throws AException{}
}
class Zi extends Fu{
    void show()throws AException{}
}
class ExceptionDemo11_11{
    public static void main(String[] args){
        method(new Zi());
    }
    public static void method(Fu f){
        try{
            f.show();
        }
        catch(AException a){
        }
        finally{}
    }
}
```

在上述程序中，如果Zi类在覆盖Fu类中的show方法时，没有抛出父类该方法抛出的类或其子类，而是抛出了CException类，那么method方法传进来的可以是Fu类或其子类，如果传进来的参数为其子类Zi，那么f.show调用的是子类的show方法，抛出的是CException类，而这个异常类原程序中catch不到，程序就会出错，如下

```java
class AException extends Exception{}
class BException extends AException{}
class CException extends Exception{}
class Fu{
    void show()throws AException{}
}
class Zi extends Fu{
    void show()throws CException{}
}
class ExceptionDemo11_11_2{
    public static void main(String[] args){
        method(new Zi());
    }
    public static void method(Fu f){
        try{
            f.show();
        }
        catch(AException a){
        }
        finally{}
    }
}
/*
$ javac -encoding utf-8 ExceptionDemo11_11_2.java 
ExceptionDemo11_11_2.java:8: 错误: Zi中的show()无法覆盖Fu中的show()
    void show()throws CException{}
         ^
  被覆盖的方法未抛出CException
1 个错误
*/
```

# 11Object

### equals

Object中的equals方法为：

    public boolean equals(Object obj) {
        return (this == obj);
    }

```java
class Person{
    private String name;
    Person(String name){
        this.name = name;
    }
    public boolean equals(Object obj){
        if(!(obj instanceof Person)){
            throw new ClassCastException("类型错误");
        }
        if(this.name == ((Person)obj).name)
            return true;
        return false;
    }
}
class EqualsDemo{
    public static void main(String[] args){
        Person p1 = new Person("张三");
        Person p2 = new Person("张三");
        System.out.println(p1.equals(p2));
    }
}
/*
$ java EqualsDemo
true
*/
```

1.上述程序中Person类覆盖了Object类的equals方法，使得年龄相同的两个Person类对象即为相同

2.为什么当被比较的类不是Person不直接返回false而是抛出异常？

    返回false也是可以的，但是不合适。该方法输入一个Person类对象，当该对象与调用该方法的对象的年龄不同时该方法返回false，当该方法传入另一个类类型对象时，返回也是false有点不太合适，有点类似于==符号比较整数与字符串，返回了false一样，所以我们选择抛出异常

3.为什么抛出的是运行时异常，而不是编译时被检测异常？

    1.首先如果抛出的是被检测异常那么方法签名上就应该声明该异常，而该方法是覆盖其父类的方法，而父类该方法上没有该声明，子类没办法声明
    2.编译时被检测异常意味着要检测并在某个位置处理掉的，但是调用者误用该方法比较两个不同类别的对象，没必要做针对性处理，直接给程序停掉就可以了

4.注意当该方法被重写时，有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定规定相等的对象必须具有相等的哈希码

### hasCode

```java
class Person{
    private int age;
    Person(int age){
        this.age = age;
    }
    public boolean equals(Object obj){
        if(!(obj instanceof Person))
            throw new ClassCastException("类型错误");
        if(this.age==((Person)obj).age)
            return true;
        return false;
    }
}
class HashCodeDemo{
    public static void main(String[] args){
        Person p1 = new Person(20);
        Person p2 = new Person(20);
        System.out.println(p1);
        System.out.println(p1.hashCode());
        System.out.println(Integer.toHexString(p1.hashCode()));
    }
}
/*
$ java HashCodeDemo
Person@15db9742
366712642
15db9742
*/
```

1.Person@15db9742中Person为类名，15db9742为对象地址转换而来的哈希码值(16进制)，而对象的hashCode方法可以获得该对象的哈希码值(10进制)，通过Integer.toHexString方法可以将10进制转换为16进制

2.注意当equals方法被重写时，有必要重写hashCode方法，以维护hashCode方法的常规协定，该协定规定相等的对象必须具有相等的哈希码

### getClass

API中Class类的一段原话：Class 类的实例表示正在运行的 Java 应用程序中的类和接口

也就是说任何类或者说接口在Java中也是对象，是Class类的对象，既然Class类是所有类所抽象出来的类，那么它具有哪些属性呢？

1.首先所有类都具有name名字(通过getName方法获取)

2.field字段

3.constructor构造器

4.method方法等等

```java
class Person{
    private String name;
    Person(String name){
        this.name = name;
    }
}
class GetClassDemo{
    public static void main(String[] args){
        Person p1 = new Person("张三");
        Person p2 = new Person("李四");
        Class c1 = p1.getClass();//获取了Person.class字节码文件对象
        Class c2 = p2.getClass();
        System.out.println(c1==c2);
        System.out.println(c1.getName());
        System.out.println(c2.getName());
    }
}
/*
$ java GetClassDemo
true
Person
Person
*/
```

### toString

1.toString方法是将对象的一些信息变为字符串打印出来，当我们打印对象的引用变量的时候，就默认调用了对象的toString方法

2.API中toString方法的一段原文：返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 

```java
class Person{
    private String name;
    Person(String name){
        this.name = name;
    }
}
class ToStringDemo{
    public static void main(String[] args){
        Person p = new Person("张三");
        System.out.println(p);//隐式调用了toString方法
        System.out.println(p.toString());
        System.out.println(p.getClass().getName()+"$"+Integer.toHexString(p.hashCode()));
    }
}
/*
Person@15db9742
Person@15db9742
Person$15db9742
*/
```

# 12

# 12_01包概述

包就和windows下的文件夹概念一样，提供了多层的命名空间

```java
package mypack;
class PackageDemo{
    public static void main(String[] args){
        System.out.println("hello package!");
    }
}
```

上述程序段说明，PackageDemo这个类是存在于mypack这个包下的，而包这个概念在windows下就是文件夹，也就是说PackageDemo这个类文件是(应该是)存放于mypack这个文件夹下的，我们可以编译之后将PackageDemo.class这个类手动放在自己新建的mypack文件夹下，也可以通过java编译器自动完成这个功能，如下

```java
javac -d . PackageDemo.java//其中-d表示根据程序中包语句的指示生成相应的文件夹，. 符号表示将根据包指示而生成的文件夹放在当前路径下
```

执行语句变为：

```java
$ java mypack.PackageDemo//表示执行mypack包下边的PackageDemo.class文件
hello package!
```

类似于windows的多级目录，java支持多级包结构，定义，执行类似于：

```java
package mypack.hehe.haha.xixi;
```

```java
java mypack.hehe.haha.xixi
```

# 12_02_03包与包之间的访问_import关键字

1.public与protected关键字用于管理包与包之间的权限，被public关键字修饰的类或方法才可以被包外所访问，被protected关键字修饰的方法可以被包外的子类所使用，不可以被包外的其他类使用

2.public与protected关键字所管理的是包与包之间的权限，在包内两者并没有什么用(除了子类覆盖父类方法，子类该方法权限要大于等于父类方法权限的时候)

```java
                    public      protected       default     private
同一类中               ok            ok             ok          ok
同一包中               ok            ok             ok
不同包子类中            ok            ok
不同包中               ok
```

上表中default指的是默认权限，即没有权限修饰符时候的权限，上表只要记住public与protected只在包之间起作用，在同一个包内不起作用就可以了(除了子类覆盖父类方法的时候)

```java
package mypack12_02a;
public class DemoA{
    public void show(){
        System.out.println("DemoA show run !");
    }
}
```

如下面的程序，当需要用到上述的DemoA类的时候，需要在DemoA类前加上包的名字，这点很好理解，就比如说我要找毕老师，哪个毕老师啊？传智的毕老师还是央视的毕老师啊？你需要指明，mypack12_02a.就相当于在毕老师前加上限定词---传智的，这样jvm就清晰地知道我们要找的是mypack12_02a包下的(传智的)DemoA这个类(毕老师)

在没有接触到包的概念以前，程序也有默认包，那就是当前工作路径，类都存在于同一个包下，所以使用类的时候前面没有包名

```java
package mypack;
public class Demo{
    public static void main(String[] args){
        mypack12_02a.DemoA demoa = new mypack12_02a.DemoA();
        demoa.show();
    }
}
```

上述程序段需要先编译DemoA这个类，没有包的概念以前，我们直接可以编译Demo这个类，当用到DemoA类的时候，jvm在本工作路径下找DemoA.class文件，当没有找到的时候会寻找DemoA.java这个文件进行编译，但是有了包的概念之后，DemoA在包mypack12_02a下，jvm会在这个包下寻找DemoA.class这个文件，当不存在时也会在这个包下寻找DemoA.java文件，如果均没有，那么就会报错

```java
$ javac -d . Demo.java
Demo.java:4: 错误: 程序包mypack12_02a不存在
        mypack12_02a.DemoA demoa = new mypack12_02a.DemoA();
                    ^
Demo.java:4: 错误: 程序包mypack12_02a不存在
        mypack12_02a.DemoA demoa = new mypack12_02a.DemoA();
                                                   ^
2 个错误
```

这么看有了包以后，类的调用都变得复杂了，为了使调用简单，java给出了import关键字，它用于**导入类**

```java
package mypack;
import mypack12_02a.DemoA;
public class Demo{
    public static void main(String[] args){
        DemoA demoa = new DemoA();
        demoa.show();
    }
}
/*
$ javac -d . Demo.java
$ java mypack.Demo
DemoA show run !
*/
```

# 12_04Jar工具

注意该节的题目为Jar包，但是.jar文件根本就不是一个包，.jar更类似于.rar文件是一种压缩格式，包是文件夹，.jar是压缩文件两者并不是一回事，所以博主将本节的题目改为Jar工具

Jar工具是java的一种压缩(解压缩)工具，类似于2345解压软件，好压软件等等只不过Jar是DOS命令行工具没有图形化界面

当你输入jar并回车的时候，会显示出jar的用法

```java
$ jar
用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files ...
选项:
    -c  创建新档案
    -t  列出档案目录
    -x  从档案中提取指定的 (或所有) 文件
    -u  更新现有档案
    -v  在标准输出中生成详细输出
    -f  指定档案文件名
    -m  包含指定清单文件中的清单信息
    -n  创建新档案后执行 Pack200 规范化
    -e  为捆绑到可执行 jar 文件的独立应用程序
        指定应用程序入口点
    -0  仅存储; 不使用任何 ZIP 压缩
    -P  保留文件名中的前导 '/' (绝对路径) 和 ".." (父目录) 组件
    -M  不创建条目的清单文件
    -i  为指定的 jar 文件生成索引信息
    -C  更改为指定的目录并包含以下文件
如果任何文件为目录, 则对其进行递归处理。
清单文件名, 档案文件名和入口点名称的指定顺序
与 'm', 'f' 和 'e' 标记的指定顺序相同。

示例 1: 将两个类文件归档到一个名为 classes.jar 的档案中:
       jar cvf classes.jar Foo.class Bar.class
示例 2: 使用现有的清单文件 'mymanifest' 并
           将 foo/ 目录中的所有文件归档到 'classes.jar' 中:
       jar cvfm classes.jar mymanifest -C foo/ .
````

如：我们现在想将mypack这个包(文件夹)压缩为haha.jar文件我们就可以输入：

```java
$ jar -cf haha.jar mypack
//其中c参数表示创建一个新的.jar文件(或许c代表着create)，f代表着要指定压缩后的文件名称(这里指定为haha.jar或许f代表着filename)
```

之后当前工作路径下出现：

![jar工具](https://github.com/geekavan/BiXiangdong/blob/master/jar%E5%B7%A5%E5%85%B7.png)

这样的话Demo这个类就在haha.jar下的mypack包中，使用的时候就要设置jvm工作路径

![set_classpath](https://github.com/geekavan/BiXiangdong/blob/master/set_classpath.png)

# 练习4_01

### 习题7

```java
interface Inter{
    public void show(int a, int b);
    public void func();
}
class Demo12_4_01_07{
    public static void main(String[] args){
        //补足代码，调用两个函数，要求使用匿名内部类
    }
}
```

```java
interface Inter{
    public void show(int a, int b);
    public void func();
}
class Demo12_4_01_07{
    public static void main(String[] args){
        //补足代码，调用两个函数，要求使用匿名内部类
        new Inter(){
            public void show(int a, int b){
                System.out.println(a+"......"+b);
            }
            public void func(){
                System.out.println("func run !");
            }
        }.show(1,2);
        new Inter(){
            public void show(int a, int b){
                System.out.println(a+"......"+b);
            }
            public void func(){
                System.out.println("func run !");
            }
        }.func();
    }
}
```

思路(或者说是记忆窍门)：

1.首先new Inter()后面肯定不能加分号，加了分号就是创建接口对象类，而接口不能创建对象

2.所以加了个{}，在其中覆写show方法与func方法

3.之后的new Inter(){}的一个整体就是一个对象了，该对象是Inter类的一个实现类的对象，它若想调用某方法直接.方法名就可以了

### 习题8

```java
class TD{
    int y = 3;
    class Inter{
        static int y = 4;
        void show(){
            System.out.println(y);
        }
    }
}
class Demo{
    public static void main(String[] args){
        TD.Inter ti = new TD().new Inter();
        ti.show();
    }
}
```

答案：编译会失败，因为内部类中若想定义静态成员，内部类必须也是静态的

### 习题9

在做习题9之前，请研读以下几个程序段

程序段1

```java
class Demo12_4_01_09{
    public static void main(String[] args){
        show(4);
    }
    static void show(double a){
        System.out.println("double");
    }
    static void show(int a){
        System.out.println("int");
    }
}
/*
$ java Demo12_4_01_09
int
*/
```

程序段2

```java
class Demo12_4_01_09{
    public static void main(String[] args){
        show(4.0);
    }
    static void show(double a){
        System.out.println("double");
    }
    static void show(int a){
        System.out.println("int");
    }
}
/*
$ java Demo12_4_01_09
double
*/
```

程序段3

```java
class Demo12_4_01_09{
    public static void main(String[] args){
        show(4);
    }
    static void show(double a){
        System.out.println("double");
    }
    // static void show(int a){
    //     System.out.println("int");
    // }
}
/*
$ java Demo12_4_01_09
double
*/
```

程序段4

```java
class Demo12_4_01_09{
    public static void main(String[] args){
        show(4.0);
    }
    // static void show(double a){
    //     System.out.println("double");
    // }
    static void show(int a){
        System.out.println("int");
    }
}
/*
$ javac Demo12_4_01_09.java
Demo12_4_01_09.java:3: 错误: 不兼容的类型: 从double转换到int可能会有损失
        show(4.0);
             ^
注: 某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出
1 个错误
*/
```

读完上述程序段请思考：

我们知道当调用子类对象的方法时，会先在子类对象中找，如果子类对象中没有则在其父类中寻找，那么我将show(int a)定义在父类中，show(double a)定义在子类中，调用时show(4)，那么会调用哪一个方法呢？

1.如果考虑子类里相当于有父类的全部方法，就跟写在子类里一样，那么肯定调用的就是show(int a)

2.如果先在子类中找，子类没有的话再在其父类中找，可能就会调用show(double a)

3.其实写到这里，博主已经考虑明白了，如果2成立的话就相当于子类覆盖了父类方法啊，但是覆盖父类方法要求方法签名一致，包括：返回值类型，方法名称，参数类型，参数个数，所以说肯定是调用了show(int a)，程序示例如下：

```java
class Demo12_4_01_09{
    public static void main(String[] args){
        Zi.show(4);
    }
}
class Fu{
    static void show(int a){
        System.out.println("int");
    }
}
class Zi extends Fu{
    static void show(double a){
        System.out.println("double");
    }

}
/*
$ java Demo12_4_01_09
int
*/
```

习题9题目：

写出下列选项能否在Demo的子类中存在，并写出错误理由

```java
class Demo{
    int show(int a, int b){return 0;}
}
A public int show(int a, int b){return 0;}//可以，覆盖父类方法
B private int show(int a, int b){return 0;}//不可以，覆盖父类方法时，子类该方法权限要大于等于父类该方法权限
C private int show(int a, long b){return 0;}//可以，参数类型不同，不是覆盖，这个是子类特有方法
D public short show(int a, int b){return 0;}//不可以，会出现调用的不确定性
E static int show(int a, int b){return 0;}//不可以静态方法只能覆盖静态方法
```

### 习题11

```java
class Fu{
    int num = 4;
    void show(){
        System.out.println("Fu show run !");
    }
}
class Zi extends Fu{
    int num = 5;
    void show(){
        System.out.println("Zi show run !");
    }
}
class Demo{
    public static void main(String[] args){
        Fu f = new Zi();
        Zi z = new Zi();
        System.out.println(f.num);//4
        System.out.println(z.num);//5
        f.show();//Zi show run !
        z.show();//Zi show run !
    }
}
```

总结：

1.对于成员变量来说，编译和运行都看左边 参考:[多态下的成员变量](#10_08多态下的成员变量)

2.对于成员函数(非静态)来说，编译看左边，运行看右边 参考:[多态下的成员函数非静态](#10_09多态下的成员函数非静态)

3.补充：对于静态成员函数来说，编译看左边，运行看左边 参考:[多态下的静态函数](#10_10多态下的静态函数)


### 习题13

```java
class Demo12_4_01_13{
    public static void main(String[] args){
        try{
            showExce();
            System.out.println("A");
        }
        catch(Exception e){
            System.out.println("B");
        }
        finally{
            System.out.println("C");
        }
        System.out.println("D");
    }
    public static void showExce() throws Exception{
        throw new Exception();
    }
}
/*
$ java Demo12_4_01_13
B
C
D
*/
```

现在看起来throw这个关键字起名字起的很有艺术，throw抛出，意味着程序跳转，所以"A"并没有输出来，catch异常输出"B"，finally后输出"C"，接着按程序的执行顺序输出"D"

### 习题14

```java
class Fu{
    int i = 0;
    Fu(String s){
        i = 1;
    }
}
class Zi extends Fu{
    Zi(String s){
        i=2;
    }
}
class Demo{
    public static void main(String[] args){
        Zi z = new Zi("yes");
        System.out.println(z.i);
    }
}
```

编译失败，因为Zi类构造函数里边有一个隐式的super();但是父类中并没有空参的构造函数，所以编译失败

### 习题16

```java
class Demo{
    static void func(){
        try{
            throw new Exception();
            System.out.println("A");
        }
        catch(Exception e){
            System.out.println("B");
        }
    }
    public static void main(String[] args){
        try{
            func();
        }
        catch(Exception e){
            System.out.println("C");
        }
        System.out.println("D");
    }
}
```

该程序会编译失败，因为func方法中已经明确标识throw new Exception();那么在它下面的System.out.println("A");就是标准的废话，永远也执行不到，所以会编译失败

有人可能会有疑问，为什么13题中没有编译失败呢？因为在13题中throw new Exception封装在了函数内部，函数内部没有类似于16题的问题，在函数外部我们只知道它可能有问题(因为函数签名中标明了该函数可能会抛出异常)，但是它一定有问题吗？不一定，所以13题中showExce();下面的并不是废话，可以正常编译

### 习题18

```java
class Exc0 extends Exception{}
class Exc1 extends Exc0{}
class Demo{
    public static void main(String[] args){
        try{
            throw new Exc1();
        }
        catch(Exception e){
            System.out.println("A");
        }
        catch(Exc0 e){
            System.out.println("B");
        }
    }
}
```

编译失败，多catch的情况，父类异常捕获一定要放在子类异常捕获下面，否则子类的异常捕获就成为了废话

### 习题20

```java
class Demo12_4_02_20{
    public static String output="";
    public static void foo(int i){
        try{
            if(i==1)
                throw new Exception();
            output+="1";
        }
        catch(Exception e){
            output+="2";
            return ;
        }
        finally{
            output+="3";
        }
        output+="4";
    }
    public static void main(String[] args){
        foo(0);
        System.out.println(output);
        foo(1);
        System.out.println(output);
    }
}
/*
$ java Demo12_4_02_20
134
13423
*/
```

注意：

1.output为静态变量，两次调用都是用的同一个静态变量output，所以第二次输出前面就有134

2.因为catch中有return返回语句，所以执行完finally程序就结束了

# 12_01_02_03_04多线程概述

1.进程：正在进行中的程序，如网易云音乐，谷歌浏览器等等，进程意味着在内存中开辟空间

2.线程：正在执行的程序单元，如在网易云音乐听歌是一个线程，在听歌的同时浏览其他的东西也是一个线程，一个进程至少有一个线程，可以有多个线程

3.注意：多线程"看起来"像是同时执行，但是很有可能不是，道理很简单，当只有一个cpu在忙这个进程的时候，所谓的多线程同时执行，只不过是cpu在各个线程之间在做着快速切换罢了，或者说只有一个cpu在忙多个进程的时候，所谓多个进程同时执行，也只不过是cpu在各个进程之间在做快速切换罢了

4.JVM虚拟机在启动的时候就开启了多条线程，比如说一条线程为主线程，用于执行main函数，另一条线程为垃圾回收线程，用于回收内存中的垃圾

5.主线程结束之后，JVM并不结束，示例如下：

```java
class Demo{
    public void finalize(){
        System.out.println("finalize run!");
    }
}
class ThreadDemo12_03{
    public static void main(String[] args){
        new Demo();
        new Demo();
        new Demo();
        System.gc();
        System.out.println("hello world !");
    }
}
/*
$ java ThreadDemo12_03
hello world !
finalize run!
finalize run!
*/
```

其中finalize为Object类中的方法，匿名对象创建之后就会变为垃圾，垃圾回收器会调用此方法进行与垃圾回收相关的操作，我们对此进行覆写，以便知道JVM什么时候进行了垃圾回收或者是否进行了垃圾回收

    protected  void finalize() 
            当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 

由于垃圾回收机制回收的时间是不确定的，我们为了看到一些效果要对其进行强制回收，相关函数如下是位于System类下的静态函数

    static void gc() 
            运行垃圾回收器 

1.我们看到由于垃圾回收线程与主线程是"同时运行"的两个线程("同时执行"打引号是因为两者其实在微观上并不是同时执行的，同一个cpu怎么会同时执行两个线程呢，只是cpu在两个线程之间进行快速切换而已)，所以虽然垃圾回收器运行语句在主函数输出语句之前，但是主函数输入语句却是先执行了

2.该程序段说明主线程结束之后，JVM并没有结束，此例中看出至少还执行了垃圾回收线程

3.从此例中我们还知道，垃圾回收线程没有执行完(因为还有一个finalize run!没有打印出来)，JVM就结束了

# 12_05Thread类

如何自己创建多线程呢？方式之一为继承Thread类，以下文字来源于JAVA的API文档

创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。例如，计算大于某一规定值的质数的线程可以写成： 



--------------------------------------------------------------------------------

     class PrimeThread extends Thread {
         long minPrime;
         PrimeThread(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
              . . .
         }
     }
 
--------------------------------------------------------------------------------

然后，下列代码会创建并启动一个线程： 


     PrimeThread p = new PrimeThread(143);
     p.start();

看了上述一段之后，我们可能会有问题：

1.为什么非要继承Thread类呢？

    我们要知道线程是由jvm所在的操作系统创建的，那么我们要在windows下java程序中创建多线程的话，难道还要再学习windows的相关知识吗，并不需要，java中已经提供了和底层这些东西打交道的Thread类供我们使用，我们只要使我们的类成为Thread类的子类就可以了

2.我们为什么要覆写run方法？

    我们创建多线程的目的是使多段程序"同时执行"，在主线程中执行的代码要放在main函数中，那么要在其它线程中执行的代码应该放在哪里呢？答案就是run方法中

3.调用run方法与start方法有什么不同？

    我们从API文档中可以清楚地知道，启动线程需要调用start方法，而调用run方法只是相当于调用了一个普通的函数而已，我们在调用start方法的时候，会自动帮我们调用我们覆写好的run方法

例子：

```java
class Demo extends Thread{
    private String name;
    Demo(String name){
        this.name = name;
    }
    public void run(){
        for(int i=0;i<5;i++){
            System.out.println("name......"+name+i);
        }
    }
}
class ThreadDemo12_05{
    public static void main(String[] args){
        Demo d1 = new Demo("如花");
        Demo d2 = new Demo("xiaoqiang");
        d1.start();
        d2.start();
        System.out.println("hehehehehehe!");
    }
}
/*
$ java ThreadDemo12_05
hehehehehehe!
name......xiaoqiang0
name......xiaoqiang1
name......如花0
name......xiaoqiang2
name......如花1
name......xiaoqiang3
name......如花2
name......如花3
name......如花4
name......xiaoqiang4
*/
/*
$ java ThreadDemo12_05
hehehehehehe!
name......xiaoqiang0
name......xiaoqiang1
name......如花0
name......如花1
name......xiaoqiang2
name......如花2
name......如花3
name......xiaoqiang3
name......如花4
name......xiaoqiang4
*/
```

我们看到多次运行的结果并不相同，这就是因为该段程序中包含3个线程，cpu在其间切换的时间不同导致结果不同

# 12_06Thread类中的方法及线程名称

Thread类的构造方法中有：

    Thread(String name) 
          分配新的 Thread 对象

Thread类的方法中有：

    String getName() 
          返回该线程的名称 

即线程是有名称的，可以自定义线程的名称，例子如下：

```java
class Demo extends Thread{
    private String name;
    Demo(String name){
        this.name = name;
    }
    public void run(){
        for(int i=0;i<5;i++){
            System.out.println("name......"+name+"......"+i+"......"+getName());
        }
    }
}
class ThreadDemo12_06{
    public static void main(String[] args){
        Demo d1 = new Demo("如花");
        Demo d2 = new Demo("xiaoqiang");
        d1.start();
        d2.start();
        System.out.println("hehehehehehe!");
    }
}
/*
$ java ThreadDemo12_06
hehehehehehe!
name......如花......0......Thread-0
name......xiaoqiang......0......Thread-1
name......xiaoqiang......1......Thread-1
name......如花......1......Thread-0
name......如花......2......Thread-0
name......xiaoqiang......2......Thread-1
name......如花......3......Thread-0
name......xiaoqiang......3......Thread-1
name......如花......4......Thread-0
name......xiaoqiang......4......Thread-1
*/
```

我们看到线程不指定名字时，默认名字为Thread-0，Thread-1等等，指定名字的程序段如下

```java
class Demo extends Thread{
    Demo(String name){
        super(name);
    }
    public void run(){
        for(int i=0;i<5;i++){
            System.out.println(i+"......"+getName());
        }
    }
}
class ThreadDemo12_06{
    public static void main(String[] args){
        Demo d1 = new Demo("如花");
        Demo d2 = new Demo("xiaoqiang");
        d1.run();
        d2.run();
        System.out.println("hehehehehehe!");
    }
}
/*
$ java ThreadDemo12_06
0......如花
1......如花
2......如花
3......如花
4......如花
0......xiaoqiang
1......xiaoqiang
2......xiaoqiang
3......xiaoqiang
4......xiaoqiang
hehehehehehe!
*/
```

我们看到我们指定了线程的名字为"如花"，"xiaoqiang"，我们创建了这两个线程，但是我们并没有启动它们，因为我们执行的是run方法而不是start方法，所以自始至终程序中只有一个主线程，我们通过Thread类的：

    static Thread currentThread() 
            返回对当前正在执行的线程对象的引用 

currentThread()静态方法就可以获取当前正在执行的线程对象的引用

```java
class Demo extends Thread{
    Demo(String name){
        super(name);
    }
    public void run(){
        for(int i=0;i<5;i++){
            System.out.println(i+"......"+currentThread().getName());
        }
    }
}
class ThreadDemo12_06{
    public static void main(String[] args){
        Demo d1 = new Demo("如花");
        Demo d2 = new Demo("xiaoqiang");
        d1.run();
        d2.run();
        System.out.println("hehehehehehe!");
    }
}
/*
$ java ThreadDemo12_06
0......main
1......main  
2......main  
3......main  
4......main  
0......main  
1......main  
2......main  
3......main  
4......main  
hehehehehehe!
*/
```

我们看到自始至终程序中只有main线程

# 13

# 13_09创建线程的第二种方式

以下文字来源于API文档:

创建���程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。采用这种风格的同一个例子如下所示： 



--------------------------------------------------------------------------------

     class PrimeRun implements Runnable {
         long minPrime;
         PrimeRun(long minPrime) {
             this.minPrime = minPrime;
         }
 
         public void run() {
             // compute primes larger than minPrime
              . . .
         }
     }
 
--------------------------------------------------------------------------------

然后，下列代码会创建并启动一个线程： 


     PrimeRun p = new PrimeRun(143);
     new Thread(p).start();

# 13_12多线程_卖票示例

需求:三个窗口分别卖票，同时进行

### 通过继承Thread类实现

```java
class Window extends Thread{
    private static int TicketNum = 100;
    public void run(){
        sell();
    }
    public void sell(){
        while(true){
            if(TicketNum>0){
                System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
            }
        }
    }
}
class TicketDemo{
    public static void main(String[] args){
        Window w0 = new Window();
        Window w1 = new Window();
        Window w2 = new Window();
        w0.start();
        w1.start();
        w2.start();
    }
}
/*部分输出
Thread-0......4
Thread-1......6
Thread-1......2
Thread-1......1
Thread-2......7
Thread-0......3
*/
```

我们看到通过继承Thread类实现多线程方式的步骤为:

1.子类继承Thread类

2.覆盖run方法，将子类中需要多线程执行的任务放置在run方法中

3.创建子类对象，调用子类对象的start方法(该start方法是从Thread类继承而来的)

该种实现多线程方式的缺点为:

1.为了将类中的某些方法以多线程的方式执行，从而使这个类继承Thread类，成为Thread体系的一部分，不能够再继承其它的类，这种做法有些"得不偿失"

2.而且继承最好不是因为要用父类的一些东西，而是因为本身两个类就属于一个体系，或者说子类就是属于父类的体系，这样程序才能更加清晰，易懂

这里我们将TicketNum放在了静态方法区，那么我们可以将其放置在堆中，使得多个窗口仍然卖的是同一种票吗？

### 通过Runnable接口实现

```java
class Window implements Runnable{
    private int TicketNum = 100;
    public void run(){
        sell();
    }
    public void sell(){
        while(true){
            if(TicketNum>0){
                System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
            }
        }
    }
}
class TicketDemo2{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
/*部分输出
Thread-1......8
Thread-2......5
Thread-2......3
Thread-0......6
Thread-2......2
Thread-1......4
Thread-0......1
*/
```

我们看到通过Runnable接口实现多线程方式的步骤为:

1.线程任务类实现Runnable接口

2.创建线程任务类对象

3.创建线程对象，并且传入线程任务类对象

4.启动线程

我们需要知道:

1.通过Runnable接口实现多线程的方式，既实现了特定任务的多线程执行，又避免了继承Thread类，成为其体系的一部分

2.通过Runnable接口实现多线程的方式，其中TicketNum存储在了堆中

3.在创建Thread类对象传入Runnable接口的实现类对象中，实现类对象就"隐藏了"类中其它的方法，只"暴露"了run方法

4.通过Runnable接口实现多线程的方式是我们经常采用的多线程实现方式

# 13_13线程安全问题

在13_12节的程序中，如果当TicketNum=1的时候，线程0执行到if(TicketNum>0)并且进入if代码块内，此时，线程1获得cpu的执行权，当线程1执行到if(TicketNum>0)并且进入if代码块内，此时，线程2获得cpu的执行权，当线程2执行到if(TicketNum>0)并且进入if代码块内

此时，线程0获得cpu的执行权，输出堆内存中TicketNum此时的值1，并且将其减去1，赋值为0，之后线程1获得cpu的执行权，输出堆内存中TicketNum此时的值0，并且将其减去1，赋值为-1，之后线程2获得cpu的执行权，输出堆内存中TicketNum此时的值-1，并且将其减去1，赋值为-2

程序如下，为了让上述过程更有可能发生，我们调用了线程类的sleep函数，通过这个例子我们看到了多线程程序中的安全隐患问题

```java
class Window implements Runnable{
    private int TicketNum = 100;
    public void run(){
        sell();
    }
    public void sell(){
        while(true){
            if(TicketNum>0){
                try{
                    Thread.sleep(10);
                }
                catch(InterruptedException e){
                    System.out.println("现在我也不会处理啊，随便写写吧");
                }
                System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
            }
        }
    }
}
class TicketDemo13_13{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
/*部分输出
Thread-0......3
Thread-2......2
Thread-1......2
Thread-0......1
Thread-2......0
Thread-1......-1
*/
```

我们看到输出了0号票与-1号票，这就是线程不安全问题造成的

# 13_14线程安全问题产生的原因

原因(前提):

1.多个线程操作共享数据

2.操作共享数据的代码有多条(只有一条时还可能不会出事)

# 13_15_16_17同步代码块_同步的好处和弊端_同步的前提

我们要怎么解决多线程产生的安全隐患呢？我们现在已经知道安全隐患产生的原因为在一个需要同一个线程一起执行完的代码段中，其它线程参与了进来，那么我们将需要同一个线程一起执行完的代码段"圈起来"，在某个线程执行它的时候，不让其它线程参与进来不就可以了吗，在java中这种想法通过synchronized关键字来实现，具体格式为:

```java
synchronized(/*对象*/){
    //需要同步的代码段
}
```

所以就可以将线程不安全的卖票程序改写为(为节约篇幅，以下都将sleep方法处的代码简写为一行):

```java
class Demo{}
class Window implements Runnable{
    private int TicketNum = 100;
    Demo d = new Demo();
    public void run(){
        sell();
    }
    public void sell(){
        while(true){
            synchronized(d){
                if(TicketNum>0){
                    try{Thread.sleep(10);}catch(InterruptedException e){}
                    System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
                }
            }
        }
    }
}
class TicketDemo15_16_17{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
/*部分输出
Thread-1......10
Thread-2......9
Thread-2......8
Thread-2......7
Thread-0......6
Thread-0......5
Thread-0......4
Thread-0......3
Thread-0......2
Thread-0......1
*/
```

上述程序新建了一个Demo类，以Demo类对象作为synchronized格式中的参数，即以Demo类对象d作为同步锁

或者我们可以将线程不安全的卖票程序改写为:

```java
class Window implements Runnable{
    private int TicketNum = 100;
    Object obj = new Object();
    public void run(){
        sell();
    }
    public void sell(){
        while(true){
            synchronized(obj){
                if(TicketNum>0){
                    try{Thread.sleep(10);}catch(InterruptedException e){}
                    System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
                }
            }
        }
    }
}
class TicketDemo15_16_17_2{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
/*部分输出
Thread-0......6
Thread-0......5
Thread-0......4
Thread-0......3
Thread-2......2
Thread-2......1
*/
```

我们看到，这里将上帝类Object类的对象obj作为了同步锁

我们接下来再看一个程序:

```java
class Window implements Runnable{
    private int TicketNum = 100;
    public void run(){
        sell();
    }
    public void sell(){
        Object obj = new Object();
        while(true){
            synchronized(obj){
                if(TicketNum>0){
                    try{Thread.sleep(10);}catch(InterruptedException e){}
                    System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
                }
            }
        }
    }
}
class TicketDemo15_16_17_3{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
/*部分输出
Thread-0......3
Thread-2......2
Thread-0......1
Thread-1......0
Thread-2......-1
*/
```

通过以上三个例子我们明白了，目前来看同步锁只要是个对象就行(但是猜想后面肯定会讲同步锁所用的对象的意义)，但是若想要多个线程不互相干扰，那么这多个线程必须用同一个锁，这是同步的前提，也是上述最后一个例子出现0及-1的输出票号的原因

同步的好处:避免了线程安全问题

同步的弊端:相对降低了效率，因为同步外的线程都会判断锁(同步外的线程当获得cpu执行权的时候会判断是否能获得同步锁)

# 13_18_19_20同步函数_验证同步函数的锁_验证静态同步函数的锁

同步函数:

```java
class Window implements Runnable{
    private int TicketNum = 100;
    public void run(){
        sell();
    }
    public void sell(){
        while(true){
            synSell();
        }
    }
    public synchronized void synSell(){
        if(TicketNum>0){
            try{Thread.sleep(10);}catch(InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
        }
    }
}
class TicketDemo18_19_20{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
/*部分输出
Thread-0......5
Thread-0......4
Thread-0......3
Thread-2......2
Thread-2......1
*/
```

我们看到将synShow方法以synchronized关键字修饰也可以达到同步的目的，那么它持有的锁是什么呢？它由该类对象调用，那么哪个对象调用它就持有哪个对象的锁呗，所以它的锁为this

那么静态同步方法的锁是什么呢？静态方法里边没有this，但我们知道静态方法可以由类名直接调用，而类在java中也是对象，所以静态同步方法持有的锁为该静态方法所属的字节码文件对象，这段话下边我们会代码演示，在演示之前，我们需要知道:

持有同一个对象即持有同一把锁的同步代码块和同步方法在程序中是"同步的"，意思就是这些**持相同锁的同步代码块和同步方法中同时只能有一个线程来访问**，**只有等该线程**执行同步代码段完毕，**释放锁之后，其它的某一个线程才能够访问该同步代码段**

为了涉及较少的函数，我们将上述代码段改写为如下代码段，并且在如下代码段基础上进行一系列的改写

```java
class Window implements Runnable{
    private int TicketNum = 100;
    public void run(){
        while(true){
            synSell();
        }
    }
    public synchronized void synSell(){
        if(TicketNum>0){
            try{Thread.sleep(10);}catch(InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
        }
    }
}
class TicketDemo18_19_20{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        Thread t2 = new Thread(w0);
        t0.start();
        t1.start();
        t2.start();
    }
}
```

### 代码段1_非静态同步方法持有的锁为this

```java
class Window implements Runnable{
    private int  TicketNum = 100;
    public boolean flag = true;
    public void run(){
        if(flag)
            while(true)
                synSell();
        else{
            while(true){
                synchronized(this){
                    if(TicketNum>0){
                        try{Thread.sleep(10);}catch(InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
                    }
                }
            }
        }
    }
    public synchronized void synSell(){
            if(TicketNum>0){
                try{Thread.sleep(10);}catch(InterruptedException e){}
                System.out.println(Thread.currentThread().getName()+"...sell..."+TicketNum--);

            }
    }
}
class TicketDemo18_19_20_2{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        t0.start();
        try{Thread.sleep(20);}catch(InterruptedException e){}
        w0.flag = false;
        t1.start();
    }
}
/*部分输出
Thread-0...sell...9
Thread-0...sell...8
Thread-1......7
Thread-1......6
Thread-1......5
Thread-0...sell...4
Thread-0...sell...3
Thread-0...sell...2
Thread-0...sell...1
*/
```

输出特点:线程安全

原因:

1.同步方法synShow持有的锁是this，上述程序中同步代码块持有的锁也是this，所以它们最终持有的锁都是Window类的对象w0

2.假如在线程0进入同步代码段执行的时候，获取了锁，那么线程1就获取不到锁，进入不了同步代码段，当线程0执行完毕释放锁之后，且cpu切换到线程1的时候，线程1得到锁，进入同步代码段执行，执行完毕后又释放锁

3.接下来cpu也是切换到线程0或者线程1都有可能，比如说又切换到了线程1，线程1进入同步代码段开始执行并获取了锁，比如线程1还没有执行完同步代码段，这时cpu切换到了线程0，但是线程0获取不了锁(因为线程1还没有释放锁)，所以线程0执行不了同步代码段，直到线程1执行完释放锁，线程0才可能执行同步代码段(注:同步代码段指的是同步方法或同步代码块)，综上得知上述代码线程安全(简言之是因为操作共享数据TicketNum的代码段是同步的(持有相同的锁))

### 代码段2_静态方法持有的锁为静态方法所属的字节码文件对象

```java
class Window implements Runnable{
    private static int  TicketNum = 100;
    public boolean flag = true;
    public void run(){
        if(flag)
            while(true)
                synSell();
        else{
            while(true){
                synchronized(this.getClass()/*换成Window.class也是一样的*/){
                    if(TicketNum>0){
                        try{Thread.sleep(10);}catch(InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
                    }
                }
            }
        }
    }
    public synchronized static void synSell(){
            if(TicketNum>0){
                try{Thread.sleep(10);}catch(InterruptedException e){}
                System.out.println(Thread.currentThread().getName()+"...sell..."+TicketNum--);

            }
    }
}
class TicketDemo18_19_20_3{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        t0.start();
        try{Thread.sleep(20);}catch(InterruptedException e){}
        w0.flag = false;
        t1.start();
    }
}
/*部分输出
Thread-0...sell...5
Thread-0...sell...4
Thread-1......3
Thread-1......2
Thread-1......1
*/
```

输出特点:线程安全

原因:静态方法所有的锁为其所属的字节码文件对象，而代码中同步代码块的锁也是该字节码文件对象，操作共享数据的同步代码段持有同一把锁，所以线程安全了

### 代码段3_检验

```java
class Window implements Runnable{
    private static int  TicketNum = 100;
    public boolean flag = true;
    public void run(){
        if(flag)
            while(true)
                synSell();
        else{
            while(true){
                synchronized(this){
                    if(TicketNum>0){
                        try{Thread.sleep(10);}catch(InterruptedException e){}
                        System.out.println(Thread.currentThread().getName()+"......"+TicketNum--);
                    }
                }
            }
        }
    }
    public synchronized static void synSell(){
            if(TicketNum>0){
                try{Thread.sleep(10);}catch(InterruptedException e){}
                System.out.println(Thread.currentThread().getName()+"...sell..."+TicketNum--);

            }
    }
}
class TicketDemo18_19_20_3{
    public static void main(String[] args){
        Window w0 = new Window();
        Thread t0 = new Thread(w0);
        Thread t1 = new Thread(w0);
        t0.start();
        try{Thread.sleep(20);}catch(InterruptedException e){}
        w0.flag = false;
        t1.start();
    }
}
/*部分输出
Thread-0...sell...3
Thread-1......2
Thread-0...sell...1
Thread-1......0
*/
```

输出特点:打印出0号票，线程不安全

原因:静态方法所有的锁为其所属的字节码文件对象，而代码中同步代码块的锁为this，操作共享数据的同步代码段持有不同的锁，所以线程不安全

# 13_21单例模式中涉及的线程安全问题

```java
/**
 * 单例模式_饿汉式
 */
class Single{
    private static final Single s = new Single();
    private Single(){}
    public static Single getInstance(){
        return s;
    }
}

/**
 * 单例模式_懒汉式
 */
class Single{
    private static Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(s==null)
            s = new Single();
        return s;
    }
}
```

饿汉式线程安全，懒汉式是线程不安全的，当线程0进入if代码块内部之后线程1获得cpu的执行权也进入if代码块的内部，随后线程0新建立了一个对象并赋值给成员变量s，线程1随后又会再建立一个对象并赋值给成员变量s，这就不是单例设计模式了，因为这就有多个实例了

更改为:

```java
class Single{
    private static Single s = null;
    private Single(){}
    public synchronized static Single getInstance(){
        if(s==null)
            s = new Single();
        return s;
    }
}
```

这样是线程安全的，但是每调用一次getInstance方法就会判断一次锁效率不高

继续修改为:

```java
class Single{
    private static Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(s==null){
            synchronized(Single.class){
                if(s==null)
                    s = new Single();
            }
        }
        return s;
    }
}
```

这样就不用每次调用都判断锁了，效率比较高

一般地，可能都不会用同步方法而是采用同步代码块，从上边例子我们也看到，同步代码块效率更高一些

# 13_22死锁

```java
class Demo implements Runnable{
    private boolean flag;
    Demo(boolean flag){this.flag = flag;}
    public void run(){
        if(flag){
            while(true)
                synchronized(Lock.locka){
                    System.out.println(Thread.currentThread().getName()+"...if...locka");
                    synchronized(Lock.lockb){
                        System.out.println(Thread.currentThread().getName()+"...if...lockb");
                    }
                }
        }
        else{
            while(true)
            synchronized(Lock.lockb){
                System.out.println(Thread.currentThread().getName()+"...else...lockb");
                synchronized(Lock.locka){
                    System.out.println(Thread.currentThread().getName()+"...else...locka");
                }
            }
        }
    }
}
class Lock{
    public static Object locka = new Object(); 
    public static Object lockb = new Object(); 
}
class DeadLockDemo{
    public static void main(String[] args){
        Demo d1 = new Demo(true);
        Demo d2 = new Demo(false);
        Thread t1 = new Thread(d1);
        Thread t2 = new Thread(d2);
        t1.start();
        try{Thread.sleep(10);}catch(Exception e){}
        t2.start();
    }
}
/*未执行完毕，程序锁死
$ java DeadLockDemo
Thread-0...if...locka
Thread-0...if...lockb
Thread-0...if...locka
Thread-0...if...lockb
Thread-0...if...locka
Thread-0...if...lockb
Thread-1...else...lockb
Thread-0...if...locka
*/
```

从输出我们看到线程0获取locka锁，获取lockb锁，释放lockb锁，释放locka锁，，，线程1进入执行，获取了lockb锁，想要获取locka锁，但是线程0已经获取了locka锁，想要或取lockb锁，两个线程锁死

# 14

# 14_26线程间通信

在13节中，我们涉及的例子为多线程操作同一个资源，多线程为相同任务(都为卖票)，引出了同步代码块的知识点

在本节中，我们涉及的例子为多线程操作同一个资源，但是多线程之间为不同任务，这将涉及多线程间通信问题

经典讲解多线程间通信问题的例子为生产者与消费者问题，生产者生产产品，消费者消费产品，只有生产者生产出产品了，消费者才能够消费，生产者与消费者是两个线程，这就涉及多线程间的通信问题

```java
class Resource{
    private String name;
    private int count=1;
    boolean flag=false;
    public synchronized void set(String name){
        //如果标志位为真，意味着已经生产好商品，生产线程可以等待了
        if(flag)
            //持有此对象监视器的线程进入此对象监视器的等待集(此对象监视器的线程池)中，释放锁
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.count++;
        System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name+this.count);
        flag = true;
        //唤醒此对象监视器的等待集中的一个线程，至于是哪个线程是随机的
        this.notify();
    }
    public synchronized void out(){
        if(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(Thread.currentThread().getName()+".....................消费者..."+this.name+this.count);
        flag = false;
        this.notify();
    }
}
class Producer implements Runnable{
    Resource r;
    Producer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.set("烤鸭");
    }
}
class Consumer implements Runnable{
    Resource r;
    Consumer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.out();
    }
}
class Demo14_26{
    public static void main(String[] args){
        //创建资源
        Resource r = new Resource();
        //封装任务
        Producer p = new Producer(r);
        Consumer c = new Consumer(r);
        //创建路径，执行任务
        Thread t0 = new Thread(p);
        Thread t1 = new Thread(c);
        //开始路径，执行任务
        t0.start();
        t1.start();
    }
}
/*
Thread-0...生产者...烤鸭1170
Thread-1.....................消费者...烤鸭1170
Thread-0...生产者...烤鸭1171
Thread-1.....................消费者...烤鸭1171
Thread-0...生产者...烤鸭1172
Thread-1.....................消费者...烤鸭1172
Thread-0...生产者...烤鸭1173
Thread-1.....................消费者...烤鸭1173
Thread-0...生产者...烤鸭1174
Thread-1.....................消费者...烤鸭1174
Thread-0...生产者...烤鸭1175
Thread-1.....................消费者...烤鸭1175
Thread-0...生产者...烤鸭1176
*/
```

监视器方法有(所有涉及到的名词后边都会有解释):

wait()        使当前线程(调用此方法的线程)在对象监视器的等待集中等待，当前线程必须持有此对象监视器
notify()      唤醒在此对象监视器等待集中的一个线程，具体哪一个线程是随机的
notifyAll()   唤醒在此对象监视器等待集中的所有线程

以上三个方法都必须定义在同步代码段中

由于很多名词都是第一次出现，并且有些采用了和13节不同的名词，所以这里有必要说明一下，囿于初学关系，这里的解释并不专业，甚至可能存在错误，出发点为帮助我们更好理解和使用多线程技术

1.同步代码段是指同步代码块或者同步函数

2.对象监视器是什么？

```java
synchronized(对象 o){
    同步代码
}
```

上述代码中我们将对象o称作"对象监视器"或者"锁"，但是你必须要知道，"对象监视器"和"锁"并不是同一种东西

当某一个线程执行到上述同步代码块里边时，我们说"该线程获取了该对象(指对象o)监视器"或者说"该线程获取了(该)锁"，或者我们说"该线程持有该对象监视器"(没听到过)，"该线程持有(该)锁"，当该线程执行完同步代码块时，我们说"该线程释放了(该)锁"，"该线程释放了该对象监视器"(没听到过)，"该线程不再持有该对象监视器"等等

总的来说就是"对象监视器"与"锁"混用，虽然两者还是有差别的，"获取"与"持有"类同，虽然也有点差别

3.调用此方法的线程是什么意思？

对象在调用方法，但是调用此方法的线程也不难理解，就是在说在某个线程中，这个对象监视器调用了方法(wait方法等)，那么"调用此方法的线程"就是指这个某线程

4.对象监视器的等待集？

即某对象监视器的线程池

上述代码中，我们只有一个生产者与一个消费者，如果我们有多个生产者与消费者，代码应该怎么写呢？

```java
class Resource{
    private String name;
    private int count=0;
    boolean flag=false;
    public synchronized void set(String name){
        //如果标志位为真，意味着已经生产好商品，生产线程可以等待了
        if(flag)
            //持有此对象监视器的线程进入此对象监视器的等待集(此对象监视器的线程池)中，释放锁
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.count++;
        System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name+this.count);
        flag = true;
        //唤醒此对象监视器的等待集中的一个线程，至于是哪个线程是随机的
        this.notify();
    }
    public synchronized void out(){
        if(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(Thread.currentThread().getName()+".....................消费者..."+this.name+this.count);
        flag = false;
        this.notify();
    }
}
class Producer implements Runnable{
    Resource r;
    Producer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.set("烤鸭");
    }
}
class Consumer implements Runnable{
    Resource r;
    Consumer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.out();
    }
}
class Demo14_26_2{
    public static void main(String[] args){
        Resource r = new Resource();

        Producer p0 = new Producer(r);
        Producer p1 = new Producer(r);
        Consumer c0 = new Consumer(r);
        Consumer c1 = new Consumer(r);

        Thread t0 = new Thread(p0);
        Thread t1 = new Thread(p1);
        Thread t2 = new Thread(c0);
        Thread t3 = new Thread(c1);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
/*部分输出
Thread-0...生产者...烤鸭121
Thread-1...生产者...烤鸭122
Thread-0...生产者...烤鸭123
Thread-1...生产者...烤鸭124
Thread-0...生产者...烤鸭125
Thread-1...生产者...烤鸭126
Thread-2.....................消费者...烤鸭126
*/
```

我们看到，输出已经不再符合我们的预期了(生产一只消费一只)，那么是哪里出现了问题呢？

我们知道线程0与线程1是生产者，线程2与线程3是消费者，比如当flag为假，线程0输出了生产者烤鸭1，此时count为2，之后将flag置为1，释放(该)锁，线程0继续获得cpu的执行权，获取锁，判断flag为真执行了wait方法进入资源对象r监视器的等待集(线程池)中，释放锁，这时线程1获得了cpu的执行权，获取到了资源对象r监视器(获取了资源对像r的锁)，判断flag为真，进入资源对象r监视器的等待集(线程池)中，释放锁

这时线程2获取到了cpu的执行权，获取锁，输出了消费者烤鸭1，将flag置为假，之后唤醒该锁(对象监视器)等待集上的一个线程，释放锁，比如唤醒了线程0，**注意:**线程0从wait之后开始执行，不再判断flag标志位，输出生产者烤鸭2，此时count为3，将flag设置为真，唤醒一个线程(唤醒了线程1)，释放锁

接下来线程0继续获得cpu的执行权，获取锁，判断flag进入该锁的等待集中，释放锁，这时比如线程1获取cpu的执行权，获取锁，**注意:**同样线程1从wait之后执行，不再判断flag标志位，输出生产者烤鸭3，我们看到此时已经出现问题，接连生产了烤鸭23并没有消费烤鸭2

究其原因，是唤醒线程之后没有判断标志位，我们将if改为while即可

```java
class Resource{
    private String name;
    private int count=0;
    boolean flag=false;
    public synchronized void set(String name){
        //如果标志位为真，意味着已经生产好商品，生产线程可以等待了
        while(flag)
            //持有此对象监视器的线程进入此对象监视器的等待集(此对象监视器的线程池)中，释放锁
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.count++;
        System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name+this.count);
        flag = true;
        //唤醒此对象监视器的等待集中的一个线程，至于是哪个线程是随机的
        this.notify();
    }
    public synchronized void out(){
        while(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(Thread.currentThread().getName()+".....................消费者..."+this.name+this.count);
        flag = false;
        this.notify();
    }
}
class Producer implements Runnable{
    Resource r;
    Producer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.set("烤鸭");
    }
}
class Consumer implements Runnable{
    Resource r;
    Consumer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.out();
    }
}
class Demo14_26_3{
    public static void main(String[] args){
        Resource r = new Resource();

        Producer p0 = new Producer(r);
        Producer p1 = new Producer(r);
        Consumer c0 = new Consumer(r);
        Consumer c1 = new Consumer(r);

        Thread t0 = new Thread(p0);
        Thread t1 = new Thread(p1);
        Thread t2 = new Thread(c0);
        Thread t3 = new Thread(c1);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
/*陷入死锁，截断输出
Thread-0...生产者...烤鸭1
Thread-3.....................消费者...烤鸭1
Thread-1...生产者...烤鸭2
Thread-3.....................消费者...烤鸭2
Thread-0...生产者...烤鸭3
*/
```

怎么会陷入死锁呢？(过程简写)(可能情况之一)

线程0-->输出生产者烤鸭1-->进入线程池

线程1-->flag为真-->进入线程池

线程3-->输出消费者烤鸭1-->进入线程池-->唤醒线程1

线程2-->flag为假-->进入线程池

线程1-->输出生产者烤鸭2-->进入线程池-->唤醒线程3

线程3-->输出消费者烤鸭2-->进入线程池-->唤醒线程0

线程0-->输出生产者烤鸭1-->进入线程池-->唤醒线程1

线程1-->flag为真-->进入线程池   就是说大家都在线程池里呆着了

解决的方式为，唤醒所有线程！

```java
class Resource{
    private String name;
    private int count=0;
    boolean flag=false;
    public synchronized void set(String name){
        //如果标志位为真，意味着已经生产好商品，生产线程可以等待了
        while(flag)
            //持有此对象监视器的线程进入此对象监视器的等待集(此对象监视器的线程池)中，释放锁
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.count++;
        System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name+this.count);
        flag = true;
        //唤醒此对象监视器的等待集中的一个线程，至于是哪个线程是随机的
        this.notifyAll();
    }
    public synchronized void out(){
        while(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(Thread.currentThread().getName()+".....................消费者..."+this.name+this.count);
        flag = false;
        this.notifyAll();
    }
}
class Producer implements Runnable{
    Resource r;
    Producer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.set("烤鸭");
    }
}
class Consumer implements Runnable{
    Resource r;
    Consumer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.out();
    }
}
class Demo14_26_3{
    public static void main(String[] args){
        Resource r = new Resource();

        Producer p0 = new Producer(r);
        Producer p1 = new Producer(r);
        Consumer c0 = new Consumer(r);
        Consumer c1 = new Consumer(r);

        Thread t0 = new Thread(p0);
        Thread t1 = new Thread(p1);
        Thread t2 = new Thread(c0);
        Thread t3 = new Thread(c1);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
```

每次的唤醒操作改为唤醒所有线程，只要保证唤醒了另一种任务的线程，就不会出现所有线程都在线程池里的情况了

# 14_28_31线程间通信_JDK5_0新特性

在JDK1.5或者说是JDK5.0版本以前，我们实现多生产者与多消费者我们使用的是synchronized关键字与Object的监视器方法(wait，notify，notifyAll)，代码如下:

```java
class Resource{
    private String name;
    private int count=0;
    boolean flag=false;
    public synchronized void set(String name){
        //如果标志位为真，意味着已经生产好商品，生产线程可以等待了
        while(flag)
            //持有此对象监视器的线程进入此对象监视器的等待集(此对象监视器的线程池)中，释放锁
            try{this.wait();}catch(InterruptedException e){}
        this.name = name;
        this.count++;
        System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name+this.count);
        flag = true;
        //唤醒此对象监视器的等待集中的一个线程，至于是哪个线程是随机的
        this.notifyAll();
    }
    public synchronized void out(){
        while(!flag)
            try{this.wait();}catch(InterruptedException e){}
        System.out.println(Thread.currentThread().getName()+".....................消费者..."+this.name+this.count);
        flag = false;
        this.notifyAll();
    }
}
class Producer implements Runnable{
    Resource r;
    Producer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.set("烤鸭");
    }
}
class Consumer implements Runnable{
    Resource r;
    Consumer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.out();
    }
}
class Demo14_26_3{
    public static void main(String[] args){
        Resource r = new Resource();

        Producer p0 = new Producer(r);
        Producer p1 = new Producer(r);
        Consumer c0 = new Consumer(r);
        Consumer c1 = new Consumer(r);

        Thread t0 = new Thread(p0);
        Thread t1 = new Thread(p1);
        Thread t2 = new Thread(c0);
        Thread t3 = new Thread(c1);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
```

程序中有一点效率不高的地方就是，我们每回都是唤醒监视器上的所有线程(notifyAll)，其实我们只要唤醒对方线程就可以了，这一点该如何解决呢？在JDK的新版本中，给出来这种问题的解决方案

### 1锁_Lock接口_显式获取与释放锁

首先将锁抽象为接口Lock，接口Lock的出现用于替代synchronized关键字

```java
Object obj = new Object();
synchronized(obj){
    //隐式地获取锁
    同步代码
    //隐式地释放锁
}
```

替换为：

```java
Lock lo = new ReentrantLock()/*接口Lock的一个实现类*/;
lo.lock();//显式获取锁
同步代码
lo.unlock();//显式释放锁
```

但是考虑到如果同步代码中如果抛出了异常，那么释放锁就执行不到了，其它线程就没办法再访问此处资源，所以显式获取锁之后一定要释放锁，所以上述伪代码应该改为:

```java
Lock lo = new ReentrantLock()/*接口Lock的一个实现类*/;
lo.lock();//显式获取锁
try{
    同步代码
}
finally{
    lo.unlock();//显式释放锁
}
```

下面是Lock的API文档原话:

    public interface LockLock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。 

    锁是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问。一次只能有一个线程获得锁，对共享资源的所有访问都需要首先获得锁。不过，某些锁可能允许对共享资源并发访问，如 ReadWriteLock 的读取锁。 

    synchronized 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁。 

    虽然 synchronized 方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用 "hand-over-hand" 或 "chain locking"：获取节点 A 的锁，然后再获取节点 B 的锁，然后释放 A 并获取 C，然后释放 B 并获取 D，依此类推。Lock 接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。 

    随着灵活性的增加，也带来了更多的责任。不使用块结构锁就失去了使用 synchronized 方法和语句时会出现的锁自动释放功能。在大多数情况下，应该使用以下语句： 

        Lock l = ...; 
        l.lock();
        try {
            // access the resource protected by this lock
        } finally {
            l.unlock();
        }
    锁定和取消锁定出现在不同作用范围中时，必须谨慎地确保保持锁定时所执行的所有代码用 try-finally 或 try-catch 加以保护，以确保在必要时释放锁。 

### 2监视器_Condition接口_锁上可建多个监视器

原来我们之所以不能够唤醒对方线程(对方线程是指:当当前线程为生产者线程时，对方线程为消费者线程，当当前线程为消费者线程时，对方线程为生产者线程)，可以认为的一个原因为一个锁上只有一个监视器，该监视器监视所有的双方线程，唤醒时唤醒任意双方线程中的一个(notify)，或者该监视器上的所以线程(notifyAll)，那么我们在一个锁上建立多个监视器不就可以解决问题吗？将生产者线程放在一个监视器中，将消费者线程放在另一个监视器中，当生产者线程要唤醒消费者线程，那么监视消费者线程的监视器调用唤醒方法就可以了，消费者线程要唤醒生产者线程类似

如图为:

![锁上建立多个监视器](https://github.com/geekavan/BiXiangdong/blob/master/Condition.png)

其中t0与他t1为生产者线程，t2与t3为消费者线程，在Synchronized关键字与Object的监视器方法的方式下，四个线程只能在同一个监视器下，所以没有办法指定类别唤醒，比如说指定唤醒消费者线程t2或t3，在JDK5.0之后，一个锁下可以建立多个监视器对象，每一个监视器可以监视一种类别的线程，就可以做到指定唤醒

锁上建立监视器的方法为:

    public interface Condition
    
    Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用

    Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法

从上边的API我们知道监视器接口为Condition，锁上建立监视器的方法为newCondition()


```java
Lock lo = new ReentrantLock()/*接口Lock的一个实现类*/;
Condition c0 = lo.newCondition();//在锁对象lo上建立了一个监视器对象c0
Condition c1 = lo.newCondition();//在锁对象lo上又建立了一个监视器对象c1
lo.lock();//显式获取锁
try{
    同步代码
}
finally{
    lo.unlock();//显式释放锁
}
```

那么监视器对象里肯定有一些方法来控制监视器监视的线程状态，包括:

1.await()方法，相当于Object监视器方法中的wait()方法，将**调用此方法的线程放入此监视器对象中**，如:

    Lock lo = new ReentrantLock()/*接口Lock的一个实现类*/;
    Condition c0 = lo.newCondition();//在锁对象lo上建立了一个监视器对象c0
    Condition c1 = lo.newCondition();//在锁对象lo上又建立了一个监视器对象c1
    lo.lock();//显式获取锁
    try{
        while(...)
            try(c0.await())catch(...){...}
        同步代码
    }
    finally{
        lo.unlock();//显式释放锁
    }

那么调用上述while代码中的语句c0.await()的线程就会被放在监视器c0中

2.signal()方法，相当于Object监视器方法中的notify()方法，**唤醒调用此方法的监视器对象中的一个线程**，如:

    Lock lo = new ReentrantLock()/*接口Lock的一个实现类*/;
    Condition c0 = lo.newCondition();//在锁对象lo上建立了一个监视器对象c0
    Condition c1 = lo.newCondition();//在锁对象lo上又建立了一个监视器对象c1
    lo.lock();//显式获取锁
    try{
        while(...)
            try(c0.await())catch(...){...}
        同步代码
        c1.signal();
    }
    finally{
        lo.unlock();//显式释放锁
    }

上述代码中c1.signal()的意思就是，无论哪个线程执行了这就话，都会将c1监视器对象监视的某一个线程唤醒

### 3JDK5_0下生产者与消费者问题的代码形式

综上，生产者与消费者的代码可以改写为:

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;
class Resource{
    private String name;
    private int count=0;
    boolean flag=false;
    Lock lo = new ReentrantLock();
    Condition producerCon = lo.newCondition();
    Condition consumerCon = lo.newCondition();
    public void set(String name){
        lo.lock();
        //如果标志位为真，意味着已经生产好商品，生产线程可以等待了
        try{
            while(flag)
                //持有此对象监视器的线程进入此对象监视器的等待集(此对象监视器的线程池)中，释放锁
                try{producerCon.await();}catch(InterruptedException e){}
            this.name = name;
            this.count++;
            System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name+this.count);
            flag = true;
            //唤醒此对象监视器的等待集中的一个线程，至于是哪个线程是随机的
            consumerCon.signal();
        }
        finally{
            lo.unlock();
        }
    }
    public void out(){
        lo.lock();
        try{
            while(!flag)
                try{consumerCon.await();}catch(InterruptedException e){}
            System.out.println(Thread.currentThread().getName()+".....................消费者..."+this.name+this.count);
            flag = false;
            producerCon.signal();
        }
        finally{
            lo.unlock();
        }

    }
}
class Producer implements Runnable{
    Resource r;
    Producer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.set("烤鸭");
    }
}
class Consumer implements Runnable{
    Resource r;
    Consumer(Resource r){
        this.r = r;
    }
    public void run(){
        while(true)
            r.out();
    }
}
class Demo14_28_31{
    public static void main(String[] args){
        Resource r = new Resource();

        Producer p0 = new Producer(r);
        Producer p1 = new Producer(r);
        Consumer c0 = new Consumer(r);
        Consumer c1 = new Consumer(r);

        Thread t0 = new Thread(p0);
        Thread t1 = new Thread(p1);
        Thread t2 = new Thread(c0);
        Thread t3 = new Thread(c1);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
/*部分输出
$ java Demo14_28_31
Thread-0...生产者...烤鸭1
Thread-2.....................消费者...烤鸭1
Thread-0...生产者...烤鸭2
Thread-2.....................消费者...烤鸭2
Thread-1...生产者...烤鸭3
Thread-3.....................消费者...烤鸭3
Thread-0...生产者...烤鸭4
Thread-2.....................消费者...烤鸭4
Thread-1...生产者...烤鸭5
Thread-3.....................消费者...烤鸭5
Thread-0...生产者...烤鸭6
*/
```

Q&A：

Q1.我们说新版本下(即JDK5.0)，一个锁上可以建立多个监视器，每个监视器可以监视多个线程，从而达到更灵活的控制，从上述代码的结果看，我们肯定是将生产者的t0与t1线程放在了producerCon监视器对象(监视的线程)中，将消费者的t2与t3线程放在了consumerCon监视器对象(监视的线程)中，但是我们似乎没有写将他们放进去的代码，程序又是怎么知道，哪些线程该放进哪个监视器中呢？

A1.通过代码在运行的时候告诉程序的，只要某线程执行了consumerCon.await()方法，那么该线程就会被放入consumerCon监视器监视的线程中，只要某线程执行了producerCon.await()方法，那么该线程就会被放入producerCon监视器监视的线程中；

唤醒线程的时候，不论哪一个线程执行了consumerCon.signal()方法，都会唤醒consumerCon监视器所监视的线程中的某一个，不论哪一个线程执行了producerCon.signal()方法，都会唤醒producerCon监视器所监视的线程中的某一个

# 14_32wait方法与sleep方法的区别

主要区别:

wait方法释放执行权，释放锁

sleep方法释放执行权，不释放锁

# 14_34停止线程的方式

请大家查看下列程序的输出

```java
class Demo implements Runnable{
    boolean flag = true;
    public synchronized void run(){
        while(flag){
            try{wait();}catch(Exception e){}
        }
        System.out.println(Thread.currentThread().getName()+"run");
    }
}
class Demo14_34{
    public static void main(String[] args){
        Demo d = new Demo();

        Thread t0 = new Thread(d);
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        Thread t3 = new Thread(d);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
    }
}
```

很明显，线程0到线程3都会到监视器的等待集中，没有输出，4个线程都进入了冻结状态，这时如果想要唤醒某个线程就可以使用interrupt方法

```java
class Demo implements Runnable{
    boolean flag = true;
    public synchronized void run(){
        while(flag){
            try{wait();}catch(Exception e){ flag = false;}
        }
        System.out.println(Thread.currentThread().getName()+"run");
    }
}
class Demo14_34{
    public static void main(String[] args){
        Demo d = new Demo();

        Thread t0 = new Thread(d);
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        Thread t3 = new Thread(d);

        t0.start();
        t1.start();
        t2.start();
        t3.start();
        t0.interrupt();
    }
}
/*输出之一，卡死
$ java Demo14_34
Thread-0run
Thread-3run
Thread-2run
*/

/*输出之一，全部的输出了，程序正常结束
$ java Demo14_34
Thread-0run
Thread-3run
Thread-1run
Thread-2run
*/
```

interrupt方法会使调用它的线程从冻结状态转换为有执行资格的状态，同时因为不是类似于notify的正常方法的唤醒，会使使他进入冻结状态的wait方法抛出InterruptedException异常

我们分析第一种输出，线程1获得cpu的执行权进入等待集，线程0获得执行权进入等待集，主线程中线程0调用了interrupt方法，程序捕捉异常将flag设置为假，判断为假，程序输出为线程0，线程3获得执行权判断flag为假，输出线程3，线程2获得执行权判断flag为假，输出线程2，线程1一直在等待集中冻结，线程不能结束

第二种情况线程0先获得了执行权并interrupt了，将flag设置为假，所以后面就各个线程都输出了

# 14_35守护线程

守护线程可以称之为后台线程，通过setDeamon(true)方法将一个线程设置为守护线程，后台线程意味着，一旦非后台线程执行完毕，不用管后台线程是否执行完毕，JVM就退出了

```java
class Demo implements Runnable{
    boolean flag = false;
    public synchronized void run(){
        if(flag){
            try{wait();}catch(Exception e){}
        }
        System.out.println(Thread.currentThread().getName()+"run");
        flag = true;
    }
}
class Demo14_35{
    public static void main(String[] args){
        Demo d = new Demo();

        Thread t0 = new Thread(d);
        Thread t1 = new Thread(d);

        t0.start();
        t1.start();
    }
}
/*程序卡死，强制退出
$ java Demo14_35
Thread-0run
*/
```

我们看到一旦一个线程进入输出，另一个线程肯定就会进入等待集中，导致程序卡死

我们可以将其中一个线程，如线程1设置为后台程序，那么当线程0执行完run函数线程结束之后，由于线程1是后台线程所以JVM也会退出

```java
class Demo implements Runnable{
    boolean flag = false;
    public synchronized void run(){
        if(flag){
            try{wait();}catch(Exception e){}
        }
        System.out.println(Thread.currentThread().getName()+"run");
        flag = true;
    }
}
class Demo14_35{
    public static void main(String[] args){
        Demo d = new Demo();

        Thread t0 = new Thread(d);
        Thread t1 = new Thread(d);

        t0.start();
        t1.setDaemon(true);
        t1.start();
    }
}
/*程序正常结束
$ java Demo14_35
Thread-0run
*/
```

当然这段代码中如果守护线程先执行了，还是会卡死，这点很好理解

# 14_36join方法

```java
class Demo implements Runnable{
    public void run(){
        for(int i = 0;i<5;i++)
            System.out.println(Thread.currentThread().getName()+"......."+i);
    }
}
class Demo14_36{
    public static void main(String[] args) throws Exception{
        Demo d = new Demo();
        Thread t0 = new Thread(d);
        Thread t1 = new Thread(d);

        t0.start();
        t0.join();
        t1.start();

        for(int i=0;i<5;i++){
            System.out.println("main"+i);
        }
    }
}
/*
$ java Demo14_36
Thread-0.......0
Thread-0.......1
Thread-0.......2
Thread-0.......3
Thread-0.......4
main0
main1
Thread-1.......0
main2
Thread-1.......1
main3
main4
Thread-1.......2
Thread-1.......3
Thread-1.......4
*/
```

输出特点:无论运行多少遍，都是线程0先运行完毕

这是因为当主线程运行到t0.join()时候，主线程释放执行权与执行资格进入冻结状态，不继续向下执行了，等待线程0结束才从新获得执行资格，而后等cpu的时间切片，获得执行权继续向下执行

### toString方法

```java
class Demo implements Runnable{
    public void run(){
        for(int i = 0;i<5;i++)
            System.out.println(Thread.currentThread().toString()+"......."+i);
    }
}
class Demo14_36{
    public static void main(String[] args) throws Exception{
        Demo d = new Demo();
        Thread t0 = new Thread(d);
        Thread t1 = new Thread(d);

        t0.start();
        t0.join();
        t1.start();

        for(int i=0;i<5;i++){
            System.out.println("main"+i);
        }
    }
}
/*
$ java Demo14_36
Thread[Thread-0,5,main].......0
Thread[Thread-0,5,main].......1
Thread[Thread-0,5,main].......2
Thread[Thread-0,5,main].......3
Thread[Thread-0,5,main].......4
main0
main1
main2
Thread[Thread-1,5,main].......0
main3
main4
Thread[Thread-1,5,main].......1
Thread[Thread-1,5,main].......2
Thread[Thread-1,5,main].......3
Thread[Thread-1,5,main].......4
*/
```

该方法返回了线程名称，线程的优先级，线程组

线程优先级分为1-10，级别越高获得cpu的执行权的可能越大，默认执行权优先级为5

# 15

# 15_01常用对象String类特点

1.String类一旦创建就不可以改变，是一个不可变类

2.String类会有一个字符串常量池，如果一个String对象在字符串常量池中就不会再次新建，而是返回已经建立的String对象的地址

```java
class Demo15_01{
    public static void main(String[] args){
        String s0 = "abc";
        String s1 = "abc";
        System.out.println(s0==s1);
    }
}
/*
$ java Demo15_01
true
*/
```

==符号比较的是对象的地址，两者是同一个地址

# 15_2字符串的构造方法

1.public String()

    String
    public String()初始化一个新创建的 String 对象，使其表示一个空字符序列。注意，由于 String 是不可变的，所以无需使用此构造方法。

```java
String s = new String();//等效于String s = "";
```

2.public String(String original)

    String
    public String(String original)初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。由于 String 是不可变的，所以无需使用此构造方法，除非需要 original 的显式副本。 

    参数：
    original - 一个 String

```java
String s = "abc";//等效于String s = new String("abc");注意这句话建立了两个对象
```

3.public String(char[] value)

    String
    public String(char[] value)分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。该字符数组的内容已被复制；后续对字符数组的修改不会影响新创建的字符串。 

    参数：
    value - 字符串的初始值

4.public String(char[] value, int offset, int count)

    String
    public String(char[] value,
                int offset,
                int count)分配一个新的 String，它包含取自字符数组参数一个子数组的字符。offset 参数是子数组第一个字符的索引，count 参数指定子数组的长度。该子数组的内容已被复制；后续对字符数组的修改不会影响新创建的字符串。 

    参数：
    value - 作为字符源的数组。
    offset - 初始偏移量。
    count - 长度。 
    抛出： 
    IndexOutOfBoundsException - 如果 offset 和 count 参数索引字符超出 value 数组的范围

```java
class Demo15_02{
    public static void main(String[] args){
        String s0 = "";
        String s1 = new String();
        System.out.println("s0==s1........."+(s0==s1));
        System.out.println("s0.equals(s1)......"+s0.equals(s1));

        String s2 = "abc";
        String s3 = new String("abc");
        System.out.println("s2==s3........."+(s2==s3));
        System.out.println("s2.equals(s3)......"+s2.equals(s3));

        char[] arr = {'a','b','c','1'};
        String s4 = new String(arr);
        System.out.println("s4......"+s4);

        char[] arr = {'a','b','c','1'};
        String s5 = new String(arr,2,2);//从index为2处开始取2个字符构成String类对象
        System.out.println("s5......"+s5);
    }
}
/*
$ java Demo15_02
s0==s1.........false
s0.equals(s1)......true
s2==s3.........false   
s2.equals(s3)......true
s4......abc1
s5......c1
*/
```

# 15_3_4_5String类_常见功能_获取与转换

```java
class Demo15_3_4_5{
    public static void main(String[] args){
        /**
         * 1.获取
         *      1.1获取字符串的长度
         *          int length();
         *      1.2获取指定index的字符
         *          char charAt(int index);
         *      1.3获取第一次出现某字符的位置
         *          从前向后看第一次出现
         *          int indexOf(int ch);
         *          int indexOf(int ch,int fromIndex);从指定index开始第一次出现的字符
         *          int indexOf(String str);
         *          int indexOf(String str,int fromIndex);
         * 
         *          从后向前看第一次出现
         *          int lastIndexOf(int ch);
         *          int lastIndexOf(int ch,int fromIndex);从指定index开始从后向前数的第一次出现的字符
         *          int lastIndexOf(String str);
         *          int lastIndexOf(String str,int fromIndex);
         *      1.4获取子串
         *          String substring(int beginIndex, int endIndex);
         *          String substring(int beginIndex);
         * 2.转换
         *      2.1将字符串变为字符串数组
         *          String[] split(String regex);涉及正则表达式
         *      2.2将字符串变为字节数组
         *          char[] toCharArray();
         *      2.3将字符串变为字节数组
         *          byte[] getBytes();
         *      2.4将字符串中的字母转变大小写
         *          String toUpperCase();
         *          String toLOwerCase();
         *      2.5将字符串中的内容进行替换
         *          String replace(char oldch,char newch);
         *          String replace(String s1,String s2);
         *      2.6将字符串两端的空格去除
         *          String trim();
         *      2.7将字符串进行连接
         *          String concat(String str);
         * 
         */

        String s0 = "张三,李四,王五";
        String[] arrS0 = s0.split(",");
        for(int i=0;i<arrS0.length;i++){
            System.out.println(arrS0[i]);
        }

        System.out.println("-------------------------");
        
        String s1 = "张三.李四.王五";
        String[] arrS1 = s1.split(".");
        for(int i=0;i<arrS1.length;i++){
            System.out.println(arrS1[i]);
        }
        System.out.println("over");
    }
}
/*
张三
李四
王五
-------------------------
over
*/
```

比较简单，不一一说明

1.split参数内传入的是规则，.符号是正则表达式中比较特殊的符号，有着特别的意义，所以后面没有我们想要的输出

2.trim方法用于去除字符串两端的空白，比较常用，比如用户输入用户名的时候，容易将后边加入空格，这样要是我们直接获取用户名就会也获取到空白符号，这样用户就不能正常登陆了，所以要做trim处理

3.indexOf方法的参数并不是我们想的参数为char类型，它会将char类型转换为int类型，这样的话int类型也可以接收

4.英文字节占一个字节，汉语一般占两个字节(好像也有占据四个字节的)

# 15_6_7String类_常见功能_判断与比较

```java
class Demo15_6_7{
    public static void main(String[] args){
        /**
         * 3.判断
         *      3.1两个字符串是否相同
         *          boolean equals(Object anObject);
         *          boolean equalsIgnoreCase(String anotherString);
         *      3.2字符串中是否包含指定字符串
         *          boolean contains(charSequence s)
         *      3.3字符串是否以指定字符串开头，是否以指定字符串结尾
         *          boolean startsWith(String prefix);
         *          boolean endsWith(String suffix);
         * 4.比较
         *      compareTo
         *      public int compareTo(String anotherString)按字典顺序比较两个字符串  
         */
    }
}
```

# 15_9练习1_字符串数组排序

1.给定一个字符串数组，按照字典顺序从小到大排序

```java
class Demo15_9{
    public static void main(String[] args){
        String[] s = {"nba","abc", "cba", "zz", "qq","haha"};
        selectedSort(s);
        for(int i=0;i<s.length;i++){
            System.out.print(s[i]+" ");
        }
    }
    public static void selectedSort(String[] args){
        if(args==null || args.length==0)
            return;
        int index = 0;
        for(int i=0;i<args.length;i++){
            index = i;
            for(int j=i;j<args.length;j++){
                if(args[j].compareTo(args[index])<0)
                    index = j;
            }
            swap(args,i,index);
        }
    }
    public static void swap(String[] args, int i, int j){
        String temp = args[i];
        args[i] = args[j];
        args[j] = temp;
    }
}
```

说明，其它练习不做了，包括这一个应该说都比较简单，该题函数参数以函数内都可以使用Comparable接口以达到函数复用的目的

# 15_9_10StringBuffer容器的增删改查

1.增:

    StringBuffer append(data);
    StringBuffer append(index,data);

2.删:

    StringBuffer delete(start, end);
    StringBuffer deleteCharAt(int index);

3.改:

    StringBuffer replace(start, end, string);

4.查:

    char charAt(index);
    int indexOf(string);
    int lastIndexOf(string);

# 15_11StringBuffer类_可变长度字符序列

    StringBuffer() 
            构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符
    StringBuffer(int capacity) 
          构造一个不带字符，但具有指定初始容量的字符串缓冲区

从StringBuffer类的构造函数我们看到，空参的构造函数初始容量为16个字符，那么请问可不可以存入40个字符？

答案是可以的，那么这个容量是什么意思呢？表示我们建造这个容器对象的时候(内部是数组，长度不可变)，预定的是16个字节，如果存入的长度超过了16个字节，那么JVM就要自动再次建立一个容器对象，一般容量为其原来的1倍或1.5等，比如又建立了一个容器对象容量为32，**先将原来容器对象的16个字符复制过来，再将第17个字符添加到容器里边**，所以为了提高效率，我们最好根据要存入的数据有多少，预定容器容量

# 15_12_13StringBuilder类

    一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快

很简单，和StringBuffer类一样，只不过这个类线程不安全，是JDK5.0才出现的核心类

如果不能想到这两个类的区别地方的小伙伴可以看一下如下代码：

```java
class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length) 
         notFull.await();
       items[putptr] = x; 
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();
     } finally {
       lock.unlock();
     }
   }

   public Object take() throws InterruptedException {
     lock.lock();
     try {
       while (count == 0) 
         notEmpty.await();
       Object x = items[takeptr]; 
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally {
       lock.unlock();
     }
   } 
 }

```

上述代码是Condition接口的API描述里边的一段代码，这个容器类就是线程安全的(就我们所看到的put和take方法来说)，所以StringBuffer类肯定是将涉及线程安全问题的方法都进行了类似的处理，它是一个线程安全类，但是每次使用方法都要判断锁，肯定效率不高，为了提高效率，后期在5.0版本添加了StringBuilder类，在单线程下其安全且高效

# 16

# 16_02包装类_字符串转为基本数字类型

基本类型--->字符串

    1.基本类型数值+""

    2.String类的静态函数valueOf()

字符串--->基本类型

    1.包装类中的静态方法parseXxx()

        int parseInt(intstring);

        long parseLong(longstring);等等只有Character没有parse方法

```java
class Demo16_02{
    public static void main(String[] args){
        //基本类型--->字符串，方式1
        int num1 = 1;
        String snum1 = num1+"";
        System.out.println("+\"\"方式......"+snum1);

        //基本类型--->字符串，方式2
        int num2 = 1;
        String snum2 = String.valueOf(num2);
        System.out.println("valueOf方式......"+snum2);

        //字符串--->基本类型
        String snum3 = "1";
        int num3 = Integer.parseInt(snum3);
        System.out.println("字符串--->基本类型......"+num3);
    }
}
```

# 16_04自动装箱和自动拆箱

自动装箱:把基本数字类型自动转换为对应的包装类型，称为自动装箱

自动拆箱:把包装类型自动转换为对应的基本数字类型，称为自动拆箱

自动装箱与自动拆箱是JDK5.0出现的，目的是为了简化书写

```java
class Demo16_04{
    public static void main(String[] agrs){
        int num1 = 1;
        Integer inum1 = num1;//自动装箱，相当于Integer inum1 = Integer.valueOf(num1);

        Integer inum2 = 2;//自动装箱，相当于Integer inum2 = Integer.valueOf(2);
        int num2 = inum2;//自动拆箱，相当于int num2 = inum2.intValue(inum2);
    }
}
```

# 16_01_02集合框架概述_共性功能

集合特点:

1.用于装对象

2.不可以装基本数据类型

集合框架有很多种，最上层为一个接口Collection，具有功能有:

    1.添加
        boolean add(E e);
        boolean addAll(Collection coll);

    2.删除

        boolean remove(Object obj);
        boolean removeAll(Collection coll);
        void clear(Collection coll);

    3.判断

        boolean contains(Object obj);
        boolean containsAll(Collection coll);
        boolean isEmpty(Object obj);

    4.获取

        int size();
        Iterator iterator();

# 16_03_04集合框架方法演示

```java
import java.util.ArrayList;
import java.util.Collection;

class Demo16_03_04{
    public static void main(String[] args){
        Collection co1 = new ArrayList();
        Collection co2 = new ArrayList();

        co1.add("abc1");
        co1.add("abc2");
        co1.add("abc3");

        co2.add("abc1");
        co2.add("abc3");
        co2.add("abc5");
        co2.add("abc7");

        // co1.addAll(co2);
        //[abc1, abc2, abc3, abc1, abc3, abc5, abc7]

        // co1.removeAll(co2);
        //[abc2]

        // co1.retainAll(co2);
        //[abc1, abc3]

        System.out.println(co1);
    }
}
```

注意:addAll方法并不会像集合一样去掉重复元素

# 16_05_06迭代器

Iterator<E> iterator() 
          返回在此 collection 的元素上进行迭代的迭代器 

接口Collection的实现类都是容器，容器是用来装对象的，装完之后我们肯定是要取出来用的，不同容器内部的结构不同，取出的方式也不同，为了以统一的方式遍历容器内的元素，java提供了Iterator接口，只要是容器就要实现能够获取到Iterator(实现类)对象的方法iterator()，那么我们就可以利用接口内的hasNext()方法与next()方法遍历容器内元素

演示:

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

class Demo16_05_06 {
    public static void main(String[] args){
        Collection coll = new ArrayList();
        
        coll.add("abc1");
        coll.add("abc2");
        coll.add("abc3");

        for(Iterator it = coll.iterator();it.hasNext();)
            System.out.println(it.next());

        Iterator it = coll.iterator();
        while(it.hasNext())
            System.out.println(it.next());
    }
}
/*
$ java Demo16_05_06
abc1
abc2
abc3
abc1
abc2
abc3
*/
```

hasNext()方法用于判定是否还有下一个元素，next()方法用于取出下一个元素

for循环和while循环都可以实现遍历，小区别在于for循环结束后it变量也不复存在，对于遍历之后不再需要it的应用场景来说可以节省一点点空间

# 16_07List_Set

List与Set为Collection接口的子类但也是接口

1.List体系有序(怎么存怎么取)，可以有重复元素，元素都有角标索引

2.Set体系无序，无重复元素，无角标索引

# 16_08List集合的常见方法

List接口为Collection接口的子接口，除了具有Collection接口的方法外，还具有(共性特点为都可以操作角标):

1.添加:

    void add(index, element);
    void add(index, collection);

2.删除:

    Object remove(index);

3.更改:

    Object set(index, element);

4.获取:

    Object get(index);
    int indexOf(Object);
    int lastIndeOf(Object);
    List subList(from, to);

# 16_09ListIterator接口

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

class Demo16_09 {
    public static void main(String[] args) {
        List lt = new ArrayList();

        lt.add("abc1");
        lt.add("abc2");
        lt.add("abc3");

        Iterator it = lt.iterator();
        while(it.hasNext()){
            Object obj = it.next();
            if(obj=="abc2")
                lt.add("abc9");
            else
                System.out.println("next......"+obj);
        }
        System.out.println(lt);
        }
}
/*
$ java Demo16_09
next......abc1
Exception in thread "main" java.util.ConcurrentModificationException
        at java.util.ArrayList$Itr.checkForComodification(Unknown Source)
        at java.util.ArrayList$Itr.next(Unknown Source)
        at Demo16_09.main(Demo16_09.java:15)
*/
```

我们调用lt的itrator方法时，lt内部只有3的元素，当调用lt的add方法添加对象时，迭代器对象并不知道，所以会报错，要想实现上述操作，List接口提供了listItrator方法

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

class Demo16_09_2 {
    public static void main(String[] args) {
        List lt = new ArrayList();

        lt.add("abc1");
        lt.add("abc2");
        lt.add("abc3");

        ListIterator it = lt.listIterator();
        while(it.hasNext()){
            Object obj = it.next();
            if(obj=="abc2")
                it.add("abc9");
            else
                System.out.println("next......"+obj);
        }
        System.out.println(lt);
        }
}
/*
$ java Demo16_09_2
next......abc1
next......abc3
[abc1, abc2, abc9, abc3]
*/
```

# 16_10List常用实现类的特点

List

    |--Verctor底层数组实现，线程安全；因为线程安全，造成增删，改查都比较慢，已经被ArrayList类取代
    |--ArrayList底层数组实现，线程不安全，取代了Vector需要线程安全时使用ArrayList加锁，查询比较快
    |--LinkedList底层链表实现，线程不安全，增删比较快

需要知道的点:

1.Verctor与ArrayList底层都是数组实现的，数组是固定长度的，而两者实现可变长度的原因是，一旦添加的元素个数超过了初始化的容量，两者就会申请新的数组，长度变为原来的2倍(Verctor)或1.5倍(ArrayList)，将原数组元素复制到新数组，再在新数组上继续执行操作

2.由于数组数据结构在内存的地址是连续的，所以底层是数组数据结构实现的容器查询速度较快，但是增加删除都会牵扯后续数组中元素的移动，所以增删的效率不高

3.链表的数据结构在内存中的地址是不连续的，所以它的查询速度较慢，但是它的增加与删除操作不涉及后续元素的移动，所以底层是链表数据结构实现的容器增删速度比较快

# 17

# 17_12Vector集合

我们前面提到Vector集合已经被ArrayList集合取代，那么这里为什么还要介绍Vector集合呢？Vector集合是JDK1.0版本就出现的集合，而它是在JDK1.2版本Collection集合体系出现后才归为Collection集合里面的，所以它有很多特有的操作名称，并且存在一个特别的已经被Iterator迭代器取代的遍历集合容器的工具

```java
import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

class Demo17_01{
    public static void main(String[] args){
        Vector v = new Vector();
        v.addElement("abc1");//就相当于add()方法
        v.addElement("abc2");
        v.addElement("abc3");

        Enumeration e = v.elements();//该遍历方式已经被迭代器方式取代
        while(e.hasMoreElements())
            System.out.println(e.nextElement());

        Iterator it = v.iterator();
        while(it.hasNext())
            System.out.println(it.next());
    }
}
```

# 17_14LinkedList集合

addFirst()

addLast()

JDK1.6以后又出现

offerFirst()

offerLast()

-----------------------------------------------------------------------------------------

getFirst()获取但不移除，当集合为空的时候抛出NoSuchElementException

getLast()

JDK1.6以后又出现

peekFirst()获取但不移除，当集合为空的时候返回null

peekLast()

-----------------------------------------------------------------------------------------

removeFirst()获取并移除，当集合为空的时候抛出NosuchElementException

removeLast()

JDK1.6以后又出现

pollFirst()获取并移除，当集合为空的时候返回null

pollLast()

# 17_16HashSet集合

Set

    |---HashSet
    |---TreeSet

HashSet底层是哈希表实现的，不同步

何为哈希表？

正常比如说我们使用数组存储元素，来一个元素我们依据现在索引所到达的位置依次继续存储元素，哈希表并不是这样子的，在元素存入数组之前，哈希表会根据存入元素的hashCode()方法计算有关于该元素的一个int类型的值，根据该值将该元素存入该int索引位置，这样做的好处是显而易见的，每当查找一个元素时，我们先调用该元素的hashCode方法，得到int类型值，再去int值索引处找该元素，再根据该元素的equals方法判断是否相等，相等则返回该索引，提高了查找的效率

```java
import java.util.HashSet;

public class Demo17_16{
    public static void main(final String[] args) {
        final HashSet hs = new HashSet();
        hs.add(new Person("张三",13));
        hs.add(new Person("李四",14));
        hs.add(new Person("李四",14));
        hs.add(new Person("王五",15));
    }
}
class Person{
	Person(String name, int age){
		this.name = name;
		this.age = age;
	}
    private String name;
    private int age;
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return this.age;
    }
    @Override
    public int hashCode(){
        System.out.println("hashCode()......run!");
        return this.name.hashCode()+this.age;
    }
    @Override
    public boolean equals(Object obj){
        System.out.println("equals()......run!");
        Person p  = (Person)obj;
        return this.name.equals(p.getName()) && this.age==p.getAge();
    }
}
/*
$ java Demo17_16
hashCode()......run!
hashCode()......run!
hashCode()......run!
equals()......run!
hashCode()......run!
*/
```

添加Person("张三",13)时，计算了该对象的hashCode值；添加Person("李四",14)时，计算了该对象的hashCode值；再次添加Person("李四",14)时，计算该对象的hashCode值，发现该hashCode值已经存储过了，于是调用equals方法进行比较，发现对象相等，便继续添加下一个元素(对象相等是覆盖还是不再管了和容器具体设计有关)；Person("王五",15)继续调用hashCode方法

为了提高效率与防御性，Person类中的equals方法可以优化为:

```java
    @Override
    public boolean equals(Object obj){
        if(this==obj)//如果传入的是同一个对象直接返回true
            return true;
        if(!(obj instanceof Person))//如果传入的不是Person对象，抛出运行时异常
            throw new ClassCastException("类型转换异常");
        System.out.println("equals()......run!");
        Person p  = (Person)obj;
        return this.name.equals(p.getName()) && this.age==p.getAge();
    }
```

小插曲:

Set可以保证唯一，但是是无序的(插入与取出顺序不一致)，如果既想要唯一又想要有序该怎么办呢？

LinkedHashSet集合可以既唯一又有序

# 17_22TreeSet集合

TreeSet底层是二叉树实现，或者更较为准确的说是二叉搜索树实现，二叉搜索树特点:左子节点小于根节点，右子节点大于根节点，这样就具有了类似于二分查找的优点，也是线程不安全的

TreeSet集合可以实现对添加的元素的排序，有两种方式:

1.添加的元素实现Comparable接口，覆盖compareTo方法

2.建立TreeSet对象的时候，传入指定比较器

1.实现Comparable接口的演示

```java
import java.util.Iterator;
import java.util.TreeSet;

public class Demo17_22 {
    public static void main(final String[] args) {
        TreeSet ts = new TreeSet();
        ts.add(new Person("张三",13));
        ts.add(new Person("王五",15));
        ts.add(new Person("李四",14));
        ts.add(new Person("李四",14));

        for(Iterator it = ts.iterator();it.hasNext();){
            Person p = (Person)it.next();
            System.out.println(p.getName()+"......"+p.getAge());
        }
        
    }
}
class Person implements Comparable{
	Person(String name, int age){
		this.name = name;
		this.age = age;
	}
    private String name;
    private int age;
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return this.age;
    }
    @Override
    public int compareTo(Object obj){
        if(this==obj)
            return 0;
        if(!(obj instanceof Person))
            throw new ClassCastException();
        Person p  = (Person)obj;
        return this.age - p.age;
    }
}
```

这里博主仅仅是将Person类的年龄进行了比较，不是很合适，因为这样只要年龄一致就会认定为相等的对象而不进行存储

从打印结果我们看到年龄小的先输出，符合我们在Person内compareTo方法中进行的定义

2.传入指定比较器

```java
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;


class Demo17_22_2{
    public static void main(String[] args){
        TreeSet ts = new TreeSet( new ComparatorImp());
        ts.add(new Person("张三",13));
        ts.add(new Person("王五",15));
        ts.add(new Person("李四",14));
        ts.add(new Person("李四",14));

        for(Iterator it = ts.iterator();it.hasNext();){
            Person p = (Person)it.next();
            System.out.println(p.getName()+"......"+p.getAge());
        }
    }
}

class Person{
	Person(String name, int age){
		this.name = name;
		this.age = age;
	}
    private String name;
    private int age;
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return this.age;
    }
}

class ComparatorImp implements Comparator{

    @Override
    public int compare(Object o1, Object o2) {
        Person p1 = (Person)o1;
        Person p2 = (Person)o2;
        return p1.getAge()-p2.getAge();
    }
}
```

第一种方式为存储的元素自身具备比较性，容器根据存入的元素的比较方法进行元素的排序

第二种方式为容器自身具备比较方法，其调用自身的比较方法对存入的元素进行排序

# 18

# 18_01泛型

介绍泛型有很多种方式，一般地，我们所见到的引入方式为:

```java
import java.util.ArrayList;
import java.util.Iterator;

class Demo18_01 {
    public static void main(String[] args){
        ArrayList al  = new ArrayList();
        al.add("abc1");
        al.add("abc2");
        al.add("abc3");

        for(Iterator it = al.iterator();it.hasNext();){
            String str = (String)it.next();
            System.out.println(str);
        }
    }
}
```

如果我们在ArrayList对象al中加入了其他类型，就会出现错误，并且是编译器不能够检查的错误，在运行期间才会暴漏出来，这给使用带来了不安全性，那要怎么办呢？我们知道数组也是容器，比如说一个int类型的数组，我们写下:

int[] arr = new int[6];

arr[0] = 9.0;

编译器就会报错，因为定义容器arr的时候我们就规定了他只能装载int类型的数字，那么我们也做类似规定不就可以了吗？要怎么规定呢？小括号被方法的参数等用了，大括号被方法体等用了，方括号被数组等用了，最终我们选择了尖括号来标识容器中要存入什么东西

ArrayList<String> al = new ArrayList<String>();

这就标识了容器al中只能存入String类型，如果存入了其它类型，编译器就会报错，这就是我们所说的泛型，加入了泛型机制，上述的程序就可以改为:

```java
import java.util.ArrayList;
import java.util.Iterator;

class Demo18_01_01 {
    public static void main(String[] args){
        ArrayList<String> al  = new ArrayList<String>();
        al.add("abc1");
        al.add("abc2");
        al.add("abc3");

        for(Iterator<String> it = al.iterator();it.hasNext();){
            String str = (String)it.next();
            System.out.println(str);
        }

    }
}
```

我们迭代器迭代的也是String类型，所以迭代器接口后边也加入了<String>，我怎么知道Iterator后边需要加入<String>呢？查阅API有<>的我们就需要明确<>中的内容

我们现在初识了java的泛型机制，我们现在知道了一些类后边会有<>比如说ArrayList类，那么这个又代表什么意思呢？请看下面的一段代码:

```java
public class ArrayList<E> extends AbstractList<E>{
    public void add(E e){

    }
    public E get(int index){

    }
}
```

联系ArrayList的泛型用法，我们知道<>中的E只是一个"占位符"，可以替换为任何类，比如说传进来是一个String那么，E就是String，传入的是一个Integer那么E就是Integer

# 18_02java中泛型的实现

并不是所有语言都有泛型机制，每个有泛型机制的语言的泛型机制实现方式也不尽相同，如在C++中泛型是通过"类型膨胀"来完成的，ArrayList<String>与ArrayList<Integer>对应的是不同的类，无论在编译时期还是在运行时期，它们都是不同的，它们对应着ArrayList_String与ArrayList_Integer两个类，但是在java中泛型是通过"类型擦除"来完成的，ArrayList<String>与ArrayList<Integer>在运行时期对应的都是同一个类，在编译时期编译器将参数化的类型String与Integer都去掉了，它们对应的都是ArrayList这一个类

但是为什么java设计团队会将java的泛型实现机制设计成这样呢？可能是因为实现简单的原因(因为JVM根本就不用改动了)，也可能是为了向下兼容，就是以前的代码(没加入泛型部分代码)在新版本的JDK中仍然能顺利编译运行

# 18_04泛型类

在JDK5.0以前，泛型还没有出现的时候，都是通过Object与类型强制转换来实现参数类型的任意化的

```java
class Demo18_04{
    public static void main(String[] args){
        Tool t = new Tool("abc1");
        // Tool t = new Tool(4);
        String s = (String)t.getObject();
        System.out.println(s);
    }
}
class Tool{
    private Object obj;
    Tool(Object obj){
        this.obj = obj;
    }
    public void setObject(Object obj){
        this.obj = obj;
    }
    public Object getObject(){
        return this.obj;
    }
}
```

我们看到在Tool类中，为了能够让Tool类能够操作任意对象，我们将它内部的属性类型定义为了Object，因为Object是所有类的父类，这样所有类就都可以向上转型为Object类了，有了泛型机制后，我们其实可以这样定义Tool类，也可以达到Tool类操作任意对象的目的

```java
class Demo18_04_2{
    public static void main(String[] args){
        Tool<String> t = new Tool<String>("abc1");
        String s = t.getObject();
        System.out.println(s);
    }
}
class Tool<BMW>{
    private BMW obj;
    Tool(BMW obj){
        this.obj = obj;
    }
    public void setObject(BMW obj){
        this.obj = obj;
    }
    public BMW getObject(){
        return this.obj;
    }
}
```

利用泛型机制，我们将BMW作为占位符，传入什么类型，它就代表什么类型，上例中，BMW占位符代表了String类，**这是在实例化Tool类时指明的**，我们也看到在引入泛型机制后我们不必再强制转型

# 18_05泛型方法

```java
class Demo18_05{
    public static void main(String[] args){
        Tool<String> t = new Tool<String>();//show只能操作Sting类了
        t.show("str");
    }
}
class Tool<BMW>{
    public void show(BMW bb){
        System.out.println("show"+bb.toString());
    }
}
```

我们看到一旦实例化了Tool类，BMW所代表的类确定了以后，那么show方法所能操作的类就固定了，那么怎么让他们操作的参数类型不一样呢？再利用泛型机制就可以了

public void show(CC bb){}

类似于这样子呢？把CC作为类型参数的形式参数，但是这不就相当于用了变量x却没有声明变量x吗？我们要声明CC为泛型参数的，直接在方法上声明就可以了

public <CC> void show(CC bb){}

注意**我们要将泛型的声明写在修饰符后面，返回值类型的前面**

还有一点要注意的是，如果一个类里边有静态方法的话，那么静态方法是不能够用类的泛型参数来作为自己的泛型参数的，这一点很好理解，因为类的泛型参数要在类的实例化阶段明确，而静态方法直接类名就可以调用，这个时候泛型参数还不明确呢，如下:

```java
class Demo18_05{
    public static void main(String[] args){
        Tool<String> t = new Tool<String>();//show只能操作Sting类了
        t.show("str");
    }
}
class Tool<BMW>{
    public static void show(BMW bb){//静态方法不可以使用类的泛型参数
        System.out.println("show"+bb.toString());
    }
}
```

# 18_06泛型接口

程序1:

```java
interface Inter<T>{
    public void show(T t); 
}
class InterImple implements Inter<String>{
    public void show(String s){}
}
```

在程序1中，我们看到接口Inter是一个泛型接口，有一个类型参数<T>，在它的一个实现类InterImple中，我们就明确了这个类型参数T为String，这么编写程序是没有问题的，那么如果我们在实现Inter接口的时候仍然没有明确参数类型呢？请看程序2

程序2:

```java
interface Inter<T>{
    public void show(T t); 
}
class InterImple<T> implements Inter<T>{
    public void show(T s){}
}
```

程序2和程序1一样都是被允许的编程方式，都是没问题的程序，与程序1不同的是在程序2中我们在实现接口时依然没有明确类型参数T的值

那么我们可不可以写成这样呢？

class InterImple implements Inter<T>{}

就是说Inter泛型类的是实现类InterImple后边没有写<T>，在程序2中是不行的，因为程序2中在实现接口时我们还没有明确类型参数T的值，那么要等到什么时候明确了呢？只能等到实例化InterImple类的时候才能明确，怎么明确呢？还不是要在<>中填入类型参数，所以类后边当然要写<T>了啊

# 18_07泛型_上限

### 泛型下的继承关系

泛型下的继承关系1:

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;

class Demo18_07 {
    public static void main(String[] args){
        ArrayList<String> arr1 = new ArrayList<String>();
        arr1.add("abc1");
        arr1.add("abc2");
        arr1.add("abc3");
        show(arr1);

        LinkedList<String> arr2 = new LinkedList<String>();
        arr2.add("abc4");
        arr2.add("abc5");
        arr2.add("abc6");
        show(arr2);

    }
    public static void show(Collection<String> arr){
        Iterator<String> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
/*
$ java Demo18_07
abc1
abc2
abc3
abc3
abc4
abc5
*/
```

我们看到show的参数类型为Collection<String>接收了ArrayList<String>与LinkedList<String>类型的参数，说明**可以理解为ArrayList<String>与LinkedList<String>仍然是Collection<String>的子类**，这里不加泛型前，ArrayList与LinkedList为Collection的子类(实现类)

泛型下的继承关系2:

```java
import java.util.ArrayList;
import java.util.Iterator;

class Demo18_07_2 {
    public static void main(String[] args){
        ArrayList<Person> arr1 = new ArrayList<Person>();
        arr1.add(new Person("张1",11));
        arr1.add(new Person("张2",12));
        arr1.add(new Person("张3",13));
        show(arr1);

        ArrayList<Student> arr2 = new ArrayList<Student>();
        arr2.add(new Student("张4",14));
        arr2.add(new Student("张5",15));
        arr2.add(new Student("张6",16));
        show(arr2);
    }

    public static void show(ArrayList<Person> arr){
        Iterator<Person> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class Person{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    public String toString(){
        return name+"..."+age;
    }
}
class Student extends Person{
    Student(){}
    Student(String name, int age){
        super(name, age);
    }
}
class Worker extends Person{
    Worker(){}
    Worker(String name, int age){
        super(name, age);
    }
}
/*
$ javac -encoding utf-8 Demo18_07_2.java 
Demo18_07_2.java:16: 错误: 不兼容的类型: ArrayList<Student>无法转换为ArrayList<Person>
        show(arr2);
             ^
*/
```

我们看到程序报错，**可以理解为虽然Student为Person的子类，但是ArrayList<Student>却不是ArrayList<Person>的子类**，比较好理解，如果ArrayList<Student>为ArrayList<Person>的子类，那么有:

ArrayList<Person> al = new ArrayList<Student>();
al.add(new Worker("name", 13));

这就违背了泛型机制加入的初衷，原本只想要加入Student对象的容器却也加入了Worker对象

### 泛型下的通配符

我们来看如下程序:

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;

class Demo18_07 {
    public static void main(String[] args){
        ArrayList<String> arr1 = new ArrayList<String>();
        arr1.add("abc1");
        arr1.add("abc2");
        arr1.add("abc3");
        show(arr1);

        LinkedList<String> arr2 = new LinkedList<String>();
        arr2.add("abc4");
        arr2.add("abc5");
        arr2.add("abc6");
        show(arr2);

    }
    public static void show(Collection<String> arr){
        Iterator<String> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
```

show方法为一个打印集合中元素的方法，但是现在只能够打印装了String对象的集合中的元素，怎么才能让无论集合中装了什么元素都能够打印呢？我们可以将Collection<String>中的String更改为?即通配符符号，这样无论集合中装的是什么元素就都可以打印了

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;

class Demo18_07_3 {
    public static void main(String[] args){
        ArrayList<String> arr1 = new ArrayList<String>();
        arr1.add("abc1");
        arr1.add("abc2");
        arr1.add("abc3");
        show(arr1);

        LinkedList<Integer> arr2 = new LinkedList<Integer>();
        arr2.add(4);
        arr2.add(5);
        arr2.add(6);
        show(arr2);

    }
    public static void show(Collection<?> arr){
        Iterator<?> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
/*
$ java Demo18_07_3
abc1
abc2
abc3
4
5
6
*/
```

### API中泛型下的通配符体现

    boolean contains(Object o) 
        如果此 collection 包含指定的元素，则返回 true。 
    boolean containsAll(Collection<?> c) 
        如果此 collection 包含指定 collection 中的所有元素，则返回 true 

查看包不包含，我们调用的是存入对象的equals方法，而equals方法是定义在上帝类中的，每一个类对象都具有，所以contains的参数为Object而containsAll的参数只要是集合就可以，其中装入什么对象没所谓

### 泛型上限

现在我建立一个集合，只可以存入Person类对象和Person类的子类对象，该怎么操作？借助extends关键字

Collection<? extends Person>这样集合中装入的元素就必须是Person类对象或它的子类对象了

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

class Demo18_07_4 {
    public static void main(String[] args){
        ArrayList<Person> arr1 = new ArrayList<Person>();
        arr1.add(new Person("张1",11));
        arr1.add(new Person("张2",12));
        arr1.add(new Person("张3",13));
        show(arr1);

        HashSet<Student> arr2 = new HashSet<Student>();
        arr2.add(new Student("张4",14));
        arr2.add(new Student("张5",15));
        arr2.add(new Student("张6",16));
        show(arr2);
    }

    public static void show(Collection<? extends Person> arr){
        Iterator<? extends Person> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class Person{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    public String toString(){
        return name+"..."+age;
    }
}
class Student extends Person{
    Student(){}
    Student(String name, int age){
        super(name, age);
    }
}
class Worker extends Person{
    Worker(){}
    Worker(String name, int age){
        super(name, age);
    }
}
/*
$ java Demo18_07_4
张1...11
张2...12
张3...13
张6...16
张4...14
张5...15
*/
```

### API中泛型上限的体现

    boolean addAll(Collection<? extends E> c) 
        将指定 collection 中的所有元素都添加到此 collection 中（可选操作）

该方法为Collection体系中的共性方法，将另一集合中元素全部添加到本集合，另一个集合的要求为装的是类E对象，或者是类E的子类对象，为什么这么设计呢？

一种角度看，无论集合中装的是类E或者是类E的子类，取出时都可以用其父类E进行接收，不会出现ClassCastException

另一种角度看:

    boolean add(E e) 
        确保此 collection 包含指定的元素（可选操作）

Collection集合体系中add方法参数为类E对象，那么操作类E或者类E的子类也是可以的，那么添加一个集合必然也是要求这个集合中装的是类E或其子类对象了

# 18_08泛型_下限

对应于泛型的上限，如果我们希望使用Person及Person的子类型我们使用泛型的上限

Collection<? extends Person>

那么如果我们想使用如Student即Student的父类型呢？我们使用泛型的下限，通过super关键字完成

Collection<? super Student>

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;

class Demo18_08 {
    public static void main(String[] args){
        ArrayList<Person> arr1 = new ArrayList<Person>();
        arr1.add(new Person("张1",11));
        arr1.add(new Person("张2",12));
        arr1.add(new Person("张3",13));
        show(arr1);

        HashSet<Student> arr2 = new HashSet<Student>();
        arr2.add(new Student("张4",14));
        arr2.add(new Student("张5",15));
        arr2.add(new Student("张6",16));
        show(arr2);

        HashSet<Worker> arr3 = new HashSet<Worker>();
        arr3.add(new Worker("张4",14));
        arr3.add(new Worker("张5",15));
        arr3.add(new Worker("张6",16));
        show(arr3);
    }

    public static void show(Collection<? super  Student> arr){
        Iterator<? super Student> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class Person{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    public String toString(){
        return name+"..."+age;
    }
}
class Student extends Person{
    Student(){}
    Student(String name, int age){
        super(name, age);
    }
}
class Worker extends Person{
    Worker(){}
    Worker(String name, int age){
        super(name, age);
    }
}
/*
$ javac -encoding utf-8  Demo18_08.java
Demo18_08.java:24: 错误: 不兼容的类型: HashSet<Worker>无法转换为Collection<? super Student>
        show(arr3);
             ^
*/
```

Collection<? super Student>只能接收Student及Student的父类型

### API中泛型下限的体现

    TreeSet(Comparator<? super E> comparator) 
        构造一个新的空 TreeSet，它根据指定比较器进行排序

我们知道TreeSet集合的底层实现为一棵二叉搜索树，需要对存入的元素进行比较来确定其存入的位置，所以要求存入的对象类有compareTo方法，TreeSet会根据对象的compareTo方法进行元素的排序，但是也可以通过传入comparator对象来确定比较规则，示例如下:

```java
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

class Demo18_08_2 {
    public static void main(String[] args){

        TreeSet<Student> arr2 = new TreeSet<Student>(new ComparatorImp());
        arr2.add(new Student("张4",14));
        arr2.add(new Student("张5",15));
        arr2.add(new Student("张4",13));
        show(arr2);
    }

    public static void show(Collection<? extends Person> arr){
        Iterator<? extends Person> it = arr.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class ComparatorImp implements Comparator<Student>{
    @Override
    public int compare(Student o1, Student o2) {
        int temp = o1.name.compareTo(o2.name);
        return temp==0?(o1.age-o2.age):temp;
    }
    
}
class Person{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    public String toString(){
        return name+"..."+age;
    }
}
class Student extends Person{
    Student(){}
    Student(String name, int age){
        super(name, age);
    }
}
class Worker extends Person{
    Worker(){}
    Worker(String name, int age){
        super(name, age);
    }
}
/*
$ java Demo18_08_2
张4...13
张4...14
张5...15
*/
```

类 TreeSet<E>

    TreeSet(Comparator<? super E> comparator) 
        构造一个新的空 TreeSet，它根据指定比较器进行排序

类TreeSet中存入的是类E的对象，例子中存入的是Student的对象，在建立TreeSet集合的时候我们传入的是实现了Comparator接口的对象，泛型参数为Student那么在TreeSet集合进行比较的时候是调用了Comparator接口对象中的compareTo方法，参入的接收类型为Student其实我们知道接受类型也可以为Student的父类型，所以这里为<? super E>

# 18_12集合使用技巧

集合这么多，怎么选择用哪个呢？

1.元素需要唯一吗？

    不需要--->List

    需要--->Set

2.List下

    频繁查询--->ArrayList

    频繁增删--->linkedList

3.Set下

    元素需要排序--->TreeSet
    元素需要快速查找--->HashSet
    元素需要输出与输入同一个顺序--->LinkedHashSet



怎么知道集合的数据结构及所属的框架呢

List

    |--ArrayList
    |--LinkedList

Set

    |--TreeSet
    |--HashSet


后缀名就是集合所属的体系

前缀名就是集合的数据结构

看到Array就要想到数组，就要想到查询快，因为存储地址连续

看到Linked就要想到链表，就要想到增删快，就要想到add、get、remove+first、last方法

看到Hash既要想到哈希表，就要想到可能需要覆盖父类的hashCode方法与equals方法

看到Tree就要想到树、二叉树、就要想到Comparable与Comparator接口，其中Compara接口是要实现compareTo方法，Comparator接口是要实现compare方法

# 18_01Map集合特点_常用方法

Collection集合一次存入一个元素，Map集合一次存入一对元素

常用方法:

1.存

    value put(key, value)返回该key原来对应的元素，若没有返回null

2.获取

    value get(key)若key值不存在则返回null

    int size()获取Map中的键值对个数

3.判断

    boolean containsKey(key)
    boolean containsValue(value)
    boolean isEmpty()

4.删除

    void clear()

    value remove(key)

Map体系:

    |--Hashtable，是哈希表实现的，JDk1.0就出现，同步，key与value不能够为null
    |--HashMap，是哈希表实现的，不同步，key与value可以为null
    |--TreeMap，是二叉树实现的，不同步，可以实现对key的排序

# 18_03Map集合的遍历方式1_keySet方法

```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

class Demo18_03 {
    public static void main(String[] args){
        Map<Integer, String> map  = new  HashMap<Integer, String>();
        
        map.put(1,"zhangyi");
        map.put(5,"wangwu");
        map.put(4,"zhaosi");
        map.put(2,"suner");

        Set<Integer> keySet = map.keySet();
        Iterator<Integer> it = keySet.iterator();
        while(it.hasNext()){
            Integer id = it.next();
            String name = map.get(id);
            System.out.println(id+"......"+name);
        }
    }
}
/*
$ java Demo18_03
1......zhangyi
2......suner
4......zhaosi
5......wangwu
*/
```

通过Map集合的keySet方法来获取Map集合中的键值key的集合，通过集合的迭代器来遍历Map集合的键值，通过Map集合的get方法来获取每个key键值对应的value

# 18_04Map集合的遍历方式2_entrySet方法

1.Set<Map.Entry<K,V>> entrySet() 
          返回此映射中包含的映射关系的 Set 视图

2.接口 Map.Entry<K,V>

    K getKey() 
        返回与此项对应的键。 
    V getValue() 
        返回与此项对应的值。 

我们看到entrySet()方法返回的是一个Set集合对象，而其中存的是Map.Entry<K,V>类的对象，而我们通过Set集合的迭代器就可以遍历Set结合中的Map.Entry<K,V>对象，而每个对象都有getKey与getValue方法，所以这种方式也可以遍历Map集合中的元素

```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;


class MapDemo18_04 {
    public static void main(String[] args0){
        Map<Integer, String> map  = new  HashMap<Integer, String>();
        
        map.put(1,"zhangyi");
        map.put(5,"wangwu");
        map.put(4,"zhaosi");
        map.put(2,"suner");

        Set<Map.Entry<Integer,String>> keySet = map.entrySet();
        Iterator<Map.Entry<Integer,String>> it = keySet.iterator();
        while(it.hasNext()){
            Map.Entry<Integer,String> me = it.next();
            Integer id = me.getKey();
            String name = me.getValue();
            System.out.println(id+"......"+name);
        }
    }
}
/*
$ java MapDemo18_04
1......zhangyi
2......suner
4......zhaosi
5......wangwu
*/
```

事实上，Map.Entry<K,V>为Map集合的内部类，或者说是内部接口

```java
interface Map{
    public static interface Entry{
        void get();
    }
}
就相当于我们学习过的内部类
class Outer{
    static class Inter{
        void get(){}
    }
}
Outer.Inter oi = new Outer.Inter();
```

# 18_05Map集合values方法演示

    Collection<V> values() 
        返回此映射中包含的值的 Collection 视图

```java
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

class MapDemo18_05 {
    public static void main(String[] args){
        Map<Integer, String> map  = new  HashMap<Integer, String>();
        
        map.put(1,"zhangyi");
        map.put(5,"wangwu");
        map.put(4,"zhaosi");
        map.put(2,"suner");

        Collection<String> mapValues = map.values();
        Iterator<String> it = mapValues.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
/*
$ java MapDemo18_05
zhangyi
suner
zhaosi
wangwu
*/
```

# 18_07HashMap存储自定义对象

和HashSet体系类似，HashMap底层为哈希表实现，可以选择覆盖hashCode方法与equals方法

```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

class MapDemo18_07 {
    public static void main(String[] args){
        Map<Person, String> map = new HashMap<Person, String>();

        map.put(new Person("bca",11), "北京");
        map.put(new Person("abc",14), "上海");
        map.put(new Person("cba",16), "大连");
        map.put(new Person("cba",16), "黑龙江");
        map.put(new Person("zhangsan",13), "成都");

        Iterator<Person> it = map.keySet().iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class Person{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public int hashCode(){
        return this.name.hashCode()+this.age*39;
    }
    @Override
    public boolean equals(Object obj){
        if(this==obj)
            return true;
        if(!(obj instanceof Person))
            return false;
        Person p = (Person)obj;
        boolean temp = this.name.equals(p.name);
        return temp?(this.age==p.age):temp;
    }
    @Override
    public String toString(){
        return (this.name+"......"+this.age);
    }
}
```

1.我们再说一下这个过程，首先存入HashMap中Person("cba",16),"大连"的时候，HashMap会根据Person的HashCode方法计算该元素应该存入的位置，发现该位置没有元素，则直接存入

再次存入Person("cba"),"黑龙江"的时候，HashMap对象会根据Person的HashCode方法计算该元素应该存入的位置，发现该位置有元素了，此时调用Person元素的equals方法比较两个元素，发现相同则不再存入(不同则找位置继续存入)

2.打印元素的时候实际上是调用对象的toString方法，所以上述程序为了更加清晰地显示结果，我们覆写了Object的toString方法

# 18_08TreeMap存储自定义对象

### 实现Comparable接口进行元素_Key的比较

```java
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Map;

class MapDemo18_08 {
    public static void main(String[] args){
        Map<Person, String> map = new TreeMap<Person, String>();

        map.put(new Person("bca",11), "北京");
        map.put(new Person("abc",14), "上海");
        map.put(new Person("cba",16), "大连");
        map.put(new Person("cba",16), "黑龙江");
        map.put(new Person("zhangsan",13), "成都");

        Iterator<Person> it = map.keySet().iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class Person implements Comparable{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public int hashCode(){
        return this.name.hashCode()+this.age*39;
    }
    @Override
    public boolean equals(Object obj){
        if(this==obj)
            return true;
        if(!(obj instanceof Person))
            throw new RuntimeException("");
        Person p = (Person)obj;
        boolean temp = this.name.equals(p.name);
        return temp?(this.age==p.age):temp;
    }
    @Override
    public String toString(){
        return (this.name+"......"+this.age);
    }
    public int compareTo(Object obj){
        if(this==obj)
            return 0;
        if(!(obj instanceof Person))
            throw new RuntimeException("");
        Person p = (Person)obj;
        return (this.age-p.age);
        // int temp = this.name.compareTo(p.name);
        // return temp==0?(this.age-p.age):temp;
    }
}
/*compareTo函数如果按年龄比较的话
$ java MapDemo18_08
bca......11
zhangsan......13
abc......14
cba......16
*/
/*compareTo函数如果先按姓名再按年龄比较的话
$ java MapDemo18_08
abc......14
bca......11
cba......16
zhangsan......13
*/
```

1.Map集合不可以存储重复元素，该重复元素是指键值来说的，所以TreeMap也会调用equals方法来进行比较

2.TreeMap需要调用compareTo方法进行元素的比较，类需要先实现Comparable接口

### 传入指定比较器进行元素_Key的比较

```java
import java.util.TreeMap;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;

class MapDemo18_08_2 {
    public static void main(String[] args){
        Map<Person, String> map = new TreeMap<Person, String>(new ComparatorImpl());

        map.put(new Person("bca",11), "北京");
        map.put(new Person("abc",14), "上海");
        map.put(new Person("cba",16), "大连");
        map.put(new Person("cba",16), "黑龙江");
        map.put(new Person("zhangsan",13), "成都");

        Iterator<Person> it = map.keySet().iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
class ComparatorImpl implements Comparator{

    @Override
    public int compare(Object o1, Object o2) {
        if(!(o1 instanceof Person) || !(o2 instanceof Person))
            throw new RuntimeException("");
        Person p1 = (Person)o1;
        Person p2 = (Person)o2;
        int temp = p1.name.compareTo(p2.name);
        return temp==0?(p1.age-p2.age):temp;
    }

}
class Person implements Comparable{
    String name;
    int age;
    Person(){}
    Person(String name, int age){
        this.name = name;
        this.age = age;
    }
    @Override
    public int hashCode(){
        return this.name.hashCode()+this.age*39;
    }
    @Override
    public boolean equals(Object obj){
        if(this==obj)
            return true;
        if(!(obj instanceof Person))
            throw new RuntimeException("");
        Person p = (Person)obj;
        boolean temp = this.name.equals(p.name);
        return temp?(this.age==p.age):temp;
    }
    @Override
    public String toString(){
        return (this.name+"......"+this.age);
    }
    public int compareTo(Object obj){
        if(this==obj)
            return 0;
        if(!(obj instanceof Person))
            throw new RuntimeException("");
        Person p = (Person)obj;
        return (this.age-p.age);
    }
}
/*
$ java MapDemo18_08_2
abc......14
bca......11
cba......16
zhangsan......13
*/
```

传入比较器比较的是先姓名再年龄，实现Comparable接口比较的是年龄,我们看到传入比较器的优先级更高一些

# 19

# 19_01LinkedHashMap

```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

class Demo19_01 {
    public static void main(String[] args){
        HashMap<Integer, String> hm = new HashMap<Integer, String>();

        hm.put(1,"zhaoyi");
        hm.put(7,"liqi");
        hm.put(2,"wanger");
        hm.put(3,"zhangsan");

        Iterator<Map.Entry<Integer,String>> it = hm.entrySet().iterator();
        while(it.hasNext()){
            Map.Entry<Integer,String> en = it.next();
            Integer key = en.getKey();
            String value = en.getValue();
            System.out.println(key+"......"+value);
        }
    }
}
/*
$ java Demo19_01
1......zhaoyi
2......wanger
3......zhangsan
7......liqi
*/
```

我们说Set或者说Map无序指的是取出的顺序和存入的顺序不一致

这里我们看到HashMap取出和存入的顺序不一致，其实它是根据Key(Integer)的hashCode排序的，而Integer的hashCode方法就是值的大小，所以我们看到的输出顺序与数字大小一致

而LinkedHashMap就是使得取出和存入顺序一致

```java
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;

class Demo19_01_2 {
    public static void main(String[] args){
        HashMap<Integer, String> hm = new LinkedHashMap<Integer, String>();

        hm.put(1,"zhaoyi");
        hm.put(7,"liqi");
        hm.put(2,"wanger");
        hm.put(3,"zhangsan");

        Iterator<Map.Entry<Integer,String>> it = hm.entrySet().iterator();
        while(it.hasNext()){
            Map.Entry<Integer,String> en = it.next();
            Integer key = en.getKey();
            String value = en.getValue();
            System.out.println(key+"......"+value);
        }
    }
}
/*
$ java Demo19_01_2
1......zhaoyi
7......liqi
2......wanger
3......zhangsan
*/
```

# 19_13工具类Collections_排序

### 自然排序

工具类Collections内全部为静态方法，提供了操作各种容器的方法，我们先来查看sort方法

    static <T extends Comparable<? super T>> void sort(List<T> list) 
        根据元素的自然顺序 对指定列表按升序进行排序。 

举一个栗子:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Demo19_13 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("cb");
        
        System.out.println(list);

        Collections.sort(list);

        System.out.println(list);

    }
}
/*
$ java Demo19_13
[a, cb, bc, nba, dcba, cb]
[a, bc, cb, cb, dcba, nba]
*/
```

要说的点:

1.List为Collection的子类，取出元素可以使用迭代器方法，直接打印List的对象为什么也能够打印出集合中的元素?

    这一点很好理解，我们在自己的程序中也不断使用过这一个知识点，我们打印对象的时候默认的是调用对象的toString方法，ArrayLisy类很显然覆写了这一个方法，让这一个方法打印出其中的元素

2.我们自己怎么实现这一个方法？

作为一个工具类，包外可以访问--->public

又用不到对象的什么东西，传入一个参数就可以使用--->static

无返回值--->void

List内可以存入任意对象？--->List<T>

声明T是什么东西，修饰符后返回值前public static<T> void mySort(List<T> list){}

public static <T> void mySort(List<T> list){

}

但是List内真的可以存入任意对象吗？我们注意这个方法是用于比较List内对象大小的，要是存入的对象之间没有大小关系怎么办？所以存入的对象必须要具有compareTo方法，也就是说必须要继承Comparable接口，又有public static<T extends Comparable<>> void mySort(List<T> list){}

我们注意Comparable接口中也具有泛型，那么这里应该填写什么呢？我们来看一下Comparable接口中的泛型是做什么的？从API中我们知道用于接收compareTo的形式参数，也就是说我们List的集合中比较元素T的时候，调用的格式为T.compareTo(T')，从这里我们知道compareTo的参数类型要想能够接收T'必须为类型T或为其父类，所以Comparable的接口内应该填入？super T

    int compareTo(T o) 
          比较此对象与指定对象的顺序 

综上自己定义排下序算法时的方法签名为:

public static  <T extends Comparable<? super T>> void mySort(List<T> list){} 

上面的例子改写为:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Demo19_13_2 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("cb");

        System.out.println(list);

        MyCollections.mySort(list);

        System.out.println(list);

    }
}
class MyCollections{
    public static  <T extends Comparable<? super T>> void mySort(List<T> list){
        for(int i=0;i<list.size();i++){
            for(int j = i+1; j<list.size();j++){
                if(list.get(i).compareTo(list.get(j))>0)
                    Collections.swap(list, i, j);
            }
        }
    } 
}
```

### 自定义排序

    static <T> void sort(List<T> list, Comparator<? super T> c) 
        根据指定比较器产生的顺序对指定列表进行排序

其实这个很好理解，因为和TreeSet与TreeMap类一样可以通过Comparator接口自定义排序

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Demo19_13_3 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("cb");

        System.out.println(list);

        Collections.sort(list, new ComparatorImpl());

        System.out.println(list);


    }
}
class ComparatorImpl implements Comparator<String>{

    @Override
    public int compare(String o1, String o2) {
        int temp = o1.length()-o2.length();
        return temp==0?o1.compareTo(o2):temp;
    }
    
}
/*
$ java Demo19_13_3
[a, cb, bc, nba, dcba, cb]
[a, bc, cb, cb, nba, dcba]
*/
```

# 19_14工具类Colections_折半查找_最值

折半查找:查找前必须已经实现了排序

    static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) 
        使用二分搜索法搜索指定列表，以获得指定对象。 
    static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) 
        使用二分搜索法搜索指定列表，以获得指定对象 

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Demo19_14 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("cb");

        Collections.sort(list);

        System.out.println(list);

        int temp = Collections.binarySearch(list, "nba");

        System.out.println(temp);


    }
}
/*
$ java Demo19_14
[a, bc, cb, cb, dcba, nba]
5
*/
```

# 19_15工具类Collections_逆序_替换

### 逆序

逆序工具:

    static <T> Comparator<T> reverseOrder(Comparator<T> cmp) 
        返回一个比较器，它强行逆转指定比较器的顺序 

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Demo19_15 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("cb");

        
        Collections.sort(list, new ComparatorImpl());

        System.out.println(list);

        Collections.sort(list, Collections.reverseOrder(new ComparatorImpl()));

        System.out.println(list);


    }
}
class ComparatorImpl implements Comparator<String>{

    @Override
    public int compare(String o1, String o2) {
        int temp = o1.length()-o2.length();
        return temp==0?o1.compareTo(o2):temp;
    }
    
}
/*
$ java Demo19_15
[a, bc, cb, cb, nba, dcba]
[dcba, nba, cb, cb, bc, a]
*/
```

    static <T> Comparator<T> reverseOrder() 
        返回一个比较器，它强行逆转实现了 Comparable 接口的对象 collection 的自然顺序。

例子: 

```java
import java.util.Collections;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;


class Demo19_15_2{
    public static void main(String[] args){
        Set<String> s = new TreeSet<String>(Collections.reverseOrder());

        s.add("abc");
        s.add("cba");
        s.add("bac");
        s.add("zac");
        s.add("nac");

        Iterator<String> it = s.iterator();
        while(it.hasNext()){
            System.out.print(it.next()+" ");
        }

    }
}
/*
$ java Demo19_15_2
zac nac cba bac abc 
*/
```

实现原理:

int compareTo(T o1, T o2){}

调用的时候o1与o2调一下就可以了

### 替换

    static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) 
        使用另一个值替换列表中出现的所有某一指定值。 

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Demo19_15_3 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("nba");
        list.add("cb");

        System.out.println(list);

        Collections.replaceAll(list, "nba","xixi");//主要原理list.set(list.indexOf("nba"),"xixi")

        System.out.println(list);

    }
}
/*
$ java Demo19_15_3
[a, cb, bc, nba, dcba, nba, cb]
[a, cb, bc, xixi, dcba, xixi, cb]
*/
```

# 19_16工具类Collections其它方法_将非同步容器转换为同步容器

### 其他方法

fill方法

    static <T> void fill(List<? super T> list, T obj) 
        使用指定元素替换指定列表中的所有元素 

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Demo19_16 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("nba");
        list.add("cb");

        System.out.println(list);

        Collections.fill(list,"xixi");

        System.out.println(list);

    }
}
/*
$ java Demo19_16
[a, cb, bc, nba, dcba, nba, cb]
[xixi, xixi, xixi, xixi, xixi, xixi, xixi]
*/
```

shuffle方法

    static void shuffle(List<?> list) 
        使用默认随机源对指定列表进行置换 

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Demo19_16_2 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        list.add("a");
        list.add("cb");
        list.add("bc");
        list.add("nba");
        list.add("dcba");
        list.add("nba");
        list.add("cb");

        System.out.println(list);

        Collections.shuffle(list);

        System.out.println(list);

    }
}
/*
$ java Demo19_16_2
[a, cb, bc, nba, dcba, nba, cb]
[bc, nba, cb, nba, dcba, cb, a]
*/
/*
$ java Demo19_16_2
[a, cb, bc, nba, dcba, nba, cb]
[cb, bc, nba, nba, dcba, a, cb]
*/
```

### 将非同步容器转换为同步容器

首先我们需要认识到我们学到的很多容器都是线程不安全的,为了线程安全,我们必须要手动加锁,比如:

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

class Demo19_16_3 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();

        AddSession1 addSession1 = new AddSession1(list);
        AddSession2 addSession2 = new AddSession2(list);

        Thread t1 = new Thread(addSession1);
        Thread t2 = new Thread(addSession2);

        t1.start();
        t2.start();

        try{Thread.sleep(100);}catch(Exception e){}

        for(int i = 0;i<list.size();i++)
            System.out.println("第"+i+"号索引元素"+list.get(i));
    }
}
class AddSession1 implements Runnable{
    private List<String> list;
    AddSession1(){}
    AddSession1(List<String> list){
        this.list = list;
    }
    @Override
    public void run() {
        for(int i = 0;i<10;i++){
            this.list.add(""+i);
            System.out.println("add"+i);
        }
    }
}
class AddSession2 implements Runnable{
    private List<String> list;
    AddSession2(){}
    AddSession2(List<String> list){
        this.list = list;
    }
    @Override
    public void run() {
        for(int i = 100;i<110;i++){
            this.list.add(""+i);
            System.out.println("add"+i);

        }
    }
}
/*输出情况1
第0号索引元素0
第1号索引元素101
第2号索引元素1
第3号索引元素102
第4号索引元素2
第5号索引元素103
第6号索引元素3
第7号索引元素4
第8号索引元素104
第9号索引元素105
第10号索引元素5
第11号索引元素106
第12号索引元素6
第13号索引元素107
第14号索引元素7
第15号索引元素108
第16号索引元素8
第17号索引元素109
第18号索引元素9
*/
/*输出情况2
第0号索引元素null
第1号索引元素0
第2号索引元素1
第3号索引元素101
第4号索引元素2
第5号索引元素102
第6号索引元素103
第7号索引元素3
第8号索引元素104
第9号索引元素4
第10号索引元素105
第11号索引元素5
第12号索引元素106
第13号索引元素6
第14号索引元素107
第15号索引元素7
第16号索引元素8
第17号索引元素108
第18号索引元素9
第19号索引元素109
*/
```

我们本意是想在集合list中添加0-10(含左不含右)与100-110(含左不含右)共计20个数字，但是由于ArrayList容器的线程不安全出现了我们不想看到的情况，怎么解决这种问题呢？我们需要将涉及到线程安全的容器操作加上锁，比如说我们需要在多线程下向容器中添加元素，那么我们就可以将add方法上锁，上述例子改写如下:

```java
import java.util.ArrayList;
import java.util.List;

class Demo19_16_4 {
    public static void main(String[] args){
        List<String> list = new MyArrayList<String>();

        AddSession1 addSession1 = new AddSession1(list);
        AddSession2 addSession2 = new AddSession2(list);

        Thread t1 = new Thread(addSession1);
        Thread t2 = new Thread(addSession2);

        t1.start();
        t2.start();

        try{Thread.sleep(1000);}catch(Exception e){}

        for(int i = 0;i<list.size();i++)
            System.out.println("第"+i+"号索引元素"+list.get(i));
    }
}
class AddSession1 implements Runnable{
    private List<String> list;
    AddSession1(){}
    AddSession1(List<String> list){
        this.list = list;
    }
    @Override
    public void run() {
        for(int i = 0;i<10;i++){
            this.list.add(""+i);
            System.out.println("add"+i);
        }
    }
}
class AddSession2 implements Runnable{
    private List<String> list;
    AddSession2(){}
    AddSession2(List<String> list){
        this.list = list;
    }
    @Override
    public void run() {
        for(int i = 100;i<110;i++){
            this.list.add(""+i);
            System.out.println("add"+i);

        }
    }
}
class MyArrayList<E> extends ArrayList<E>{
    private ArrayList<E> arrayList;
    MyArrayList(){
        arrayList = new ArrayList<E>();
    }
    public synchronized boolean add(E e){
        return arrayList.add(e);
    }
    public E get(int index){
        return arrayList.get(index);
    }
    public int size(){
        return arrayList.size();
    }
}
/*
第0号索引元素0
第1号索引元素100
第2号索引元素1
第3号索引元素101
第4号索引元素2
第5号索引元素102
第6号索引元素3
第7号索引元素103
第8号索引元素4
第9号索引元素104
第10号索引元素5
第11号索引元素105
第12号索引元素6
第13号索引元素106
第14号索引元素7
第15号索引元素107
第16号索引元素108
第17号索引元素8
第18号索引元素109
第19号索引元素9
*/
```

我们看到上述程序通过MyArrayList的自建类把ArrayList的方法进行了封装，并将add方法进行了同步化，所以输出并没有出现问题，这里使用的是同步函数，使用同步函数是类似的(多线程任务段使用了匿名函数)

```java
import java.util.ArrayList;
import java.util.List;

class Demo19_16_5 {
    public static void main(String[] args){
        List<String> list = new MyArrayList<String>();

        AddSession2 addSession2 = new AddSession2(list);

        new Thread(){
            @Override
            public void run() {
                for(int i = 0;i<10;i++){
                    list.add(""+i);
                    System.out.println("add"+i);
                }
            }
        }.start();

        
        Thread t2 = new Thread(addSession2);

        t2.start();

        try{Thread.sleep(1000);}catch(Exception e){}

        for(int i = 0;i<list.size();i++)
            System.out.println("第"+i+"号索引元素"+list.get(i));
    }
}
class AddSession2 implements Runnable{
    private List<String> list;
    AddSession2(){}
    AddSession2(List<String> list){
        this.list = list;
    }
    @Override
    public void run() {
        for(int i = 100;i<110;i++){
            this.list.add(""+i);
            System.out.println("add"+i);

        }
    }
}
class MyArrayList<E> extends ArrayList<E>{
    private ArrayList<E> arrayList;
    MyArrayList(){
        arrayList = new ArrayList<E>();
    }
    public boolean add(E e){
        synchronized(this){
            return arrayList.add(e);
        }
    }
    public E get(int index){
        return arrayList.get(index);
    }
    public int size(){
        return arrayList.size();
    }
}
```

事实上，工具类中提供了将线程不安全的容器转变为线程安全的容器的方法

    static <T> Collection<T> synchronizedCollection(Collection<T> c) 
        返回指定 collection 支持的同步（线程安全的）collection。 
    static <T> List<T> synchronizedList(List<T> list) 
        返回指定列表支持的同步（线程安全的）列表。 
    static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) 
        返回由指定映射支持的同步（线程安全的）映射。 
    static <T> Set<T> synchronizedSet(Set<T> s) 
        返回指定 set 支持的同步（线程安全的）set 

这样利用此工具，上述程序可以转变为:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Demo19_16_6 {
    public static void main(String[] args){
        List<String> list = Collections.synchronizedList(new MyArrayList<String>());

        new Thread(){
            @Override
            public void run() {
                for(int i = 0;i<10;i++){
                    list.add(""+i);
                    System.out.println("add"+i);
                }
            }
        }.start();

        
        new Thread(){
            @Override
            public void run() {
                for(int i = 100;i<110;i++){
                    list.add(""+i);
                    System.out.println("add"+i);
        
                }
            }
        }.start();

        try{Thread.sleep(1000);}catch(Exception e){}

        for(int i = 0;i<list.size();i++)
            System.out.println("第"+i+"号索引元素"+list.get(i));
    }
}
class MyArrayList<E> extends ArrayList<E>{
    private ArrayList<E> arrayList;
    MyArrayList(){
        arrayList = new ArrayList<E>();
    }
    public boolean add(E e){
        return arrayList.add(e);
    }
    public E get(int index){
        return arrayList.get(index);
    }
    public int size(){
        return arrayList.size();
    }
}
/*
第0号索引元素0
第1号索引元素1
第2号索引元素2
第3号索引元素3
第4号索引元素4
第5号索引元素100
第6号索引元素5
第7号索引元素6
第8号索引元素7
第9号索引元素8
第10号索引元素101
第11号索引元素102
第12号索引元素103
第13号索引元素104
第14号索引元素9
第15号索引元素105
第16号索引元素106
第17号索引元素107
第18号索引元素108
第19号索引元素109
*/
```

上述程序中我们利用Collections工具类中的方法将线程不安全的容器变为了线程安全的容器，另外上述程序中我们将两个线程任务都封装成了匿名对象

# 工具类Arrays的toString方法及其源码

此类包含用来操作数组（比如排序和搜索）的各种方法。此类还包含一个允许将数组作为列表来查看的静态工厂。

toString方法:

```java
import java.util.Arrays;

class Demo19_17{
    public static void main(String[] args){
        int[] arr = new int[]{1,2,3,4,5,6};
        System.out.println(Arrays.toString(arr));
    }
    //Arrays类中toString方法源码类似于
    public static String myToString(int[] a){
        if(a==null)
            return "null";
        int iMax = a.length-1;
        if(iMax==-1)
            return "[]";
        StringBuilder b = new StringBuilder();
        b.append("[");
        for(int i=0;;i++){
            b.append(a[i]);
            if(i==iMax)
                return b.append("]").toString();
            b.append(", ");
        }
    }
}
/*
$ java Demo19_17
[1, 2, 3, 4, 5, 6]
*/
```

从源码中我们发现:

1.获取数组长度的方法只调用了一次，一定程度上提高了效率

2.for循环中中间位置的循环条件没有写，减少了判断的次数，一定程度上也提高了效率


# 19_18工具类Arrays的asList方法

    static <T> List<T> asList(T... a) 
        返回一个受指定数组支持的固定大小的列表。

```java
import java.util.Arrays;
import java.util.List;

class Demo19_17_2{
    public static void main(String[] args){
        String[] arr = {"xixi","haha","hiahia"};
        List<String> list = Arrays.asList(arr);
        System.out.println(list.contains("haha"));
    }
}
/*
$ java Demo19_17_2
true
*/
``` 

注意当数组中存储的是对象，转变为集合的时候，会将数组中的元素作为集合中的元素进行存储

当数组中存储的是基本数据类型，转变为集合的时候，会将数组作为集合中的元素进行存储

```java
import java.util.Arrays;
import java.util.List;

class Demo19_17_2{
    public static void main(String[] args){
        String[] arr = {"xixi","haha","hiahia"};
        List<String> list = Arrays.asList(arr);
        System.out.println(list.contains("haha"));

        int[] arr1 = {1, 2, 3, 4, 5, 6};
        System.out.println(arr1);
        List<int[]> list1 = Arrays.asList(arr1);//注意其泛型类型
        System.out.println(list1);

        Integer[] arr2 = {1, 2, 3, 4, 5, 6};
        List<Integer> list2 = Arrays.asList(arr2);
        System.out.println(list2);
    }
}
/*
$ java Demo19_17_2
true
[I@15db9742
[[I@15db9742]
[1, 2, 3, 4, 5, 6]
*/
```

Arrays工具类提供了将数组转变为集合的方法，这样我们就可以使用集合中的很多方法，注意改变数组长度的方法不可以用

```java
import java.util.Arrays;
import java.util.List;

class Demo19_17_3{
    public static void main(String[] args){

        Integer[] arr2 = {1, 2, 3, 4, 5, 6};
        List<Integer> list2 = Arrays.asList(arr2);
        System.out.println(list2.add(5));
    }
}
/*
$ java Demo19_17_3
Exception in thread "main" java.lang.UnsupportedOperationException
        at java.util.AbstractList.add(Unknown Source)
        at java.util.AbstractList.add(Unknown Source)
        at Demo19_17_3.main(Demo19_17_3.java:9)
*/
```

我们看到转为集合之后一旦涉及到改变数组长度的方法时，会抛出UnsupportedOperationException异常

# 19_19接口Collection的toArray方法

注意区分:集合的两个工具类为Collections与Arrays都有s，Collection不带s的是集合接口

    Object[] toArray() 
        返回包含此 collection 中所有元素的数组。 
    <T> T[] toArray(T[] a) //这是一个泛型方法，类型参数T在方法调用的时候才会明确
        返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。 
    参数：
        a - 存储此 collection 元素的数组（如果其足够大）；否则，将为此分配一个具有相同运行时类型的新数组。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Demo19_19 {
    public static void main(String[] args){
        List<String> list = new ArrayList<String>();
        list.add("haha");
        list.add("xixi");
        list.add("hiahia");
        list.add("heihei");

        String[] arr = list.toArray(new String[5]);//[haha, xixi, hiahia, heihei, null]

        String[] arr = list.toArray(new String[3]);//[haha, xixi, hiahia, heihei]

        System.out.println(Arrays.toString(arr));
    }
}
```

# 19_20foreach循环

JDK5.0出现的语法糖，为了简化书写

```java
import java.util.ArrayList;
import java.util.List;

class Demo19_20 {
    public static void main(String[] args){
        int[] arr = {1,2,3};
        for(int i:arr){
            System.out.println(i);
        }

        String[] arr1 = {"xixi", "haha", "hiahia"};
        for(String s:arr1){
            System.out.println(s);
        }

        List<String> list = new ArrayList<String>();

        list.add("abc1");
        list.add("abc2");
        list.add("abc3");

        for(String s:list){
            System.out.println(s);
        }
    }
}
/*
$ java Demo19_20
1
2
3
xixi
haha
hiahia
abc1
abc2
abc3
*/
```

foreach遍历map集合

```java
import java.util.HashMap;
import java.util.Map;

class Demo19_20_2 {
    public static void main(String[] args){
        Map<String, Integer> map = new HashMap<String, Integer>();

        map.put("zhangsan", 3);
        map.put("wangwu", 5);
        map.put("lisi", 4);

        for(String key:map.keySet()){
            Integer value = map.get(key);
            System.out.println(key+"....."+value);
        }

        for(Map.Entry<String, Integer> me:map.entrySet()){
            String key = me.getKey();
            Integer value = me.getValue();
            System.out.println(key+"........."+value);
        }
    }
}
/*
$ java Demo19_20_2
lisi.....4
zhangsan.....3
wangwu.....5
lisi.........4
zhangsan.........3
wangwu.........5
*/
```

# 19_21函数可变参数

JDK5.0出现的语法糖

```java
class Demo19_21{
    public static void main(String[] args){
        int[] arr = {1,2,3,4,5,6};
        int sum = sum(arr);
        System.out.println("sum"+sum);

        int newSum = newSum(1,2,3,4,5,6);
        System.out.println("newSum......"+newSum);

    }
    public static int sum(int[] arr){
        if(arr==null)
            return 0;
        int iMax = arr.length-1;
        if(iMax==-1)
            return 0;
        int sum = 0;
        for(int i =0;i<=iMax;i++){
            sum+=arr[i];
        }
        return sum;
    }
    public static int newSum(int... arr){
        if(arr==null)
            return 0;
        int iMax = arr.length-1;
        if(iMax==-1)
            return 0;
        int sum = 0;
        for(int i =0;i<=iMax;i++){
            sum+=arr[i];
        }
        return sum;
    }
}
/*
$ java Demo19_21
sum21
newSum......21
*/
```

我们看到sum和newSum的方法功能和内部实现是一样的，加入了函数可变参数这个语法糖之后，数组元素可以直接传入方法参数中，JVM自动将其封装为数组了，需要注意的是可变函数参数只能放在方法参数列表的结尾

public static int newSum(int a, int... arr){}可以

public static int newSum(int... arr, int a){}不可以

# 19_22静态导入

也是JDK5.0新特性

以前我们有程序段如下:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Demo19_22 {
    public static void main(String[] args){
        List<Integer> list = new ArrayList<Integer>();
        list.add(3);
        list.add(5);
        list.add(8);
        list.add(7);

        System.out.println(list);
        
        Collections.sort(list);
        
        System.out.println(list);

        Integer max = Collections.max(list);

        System.out.println(max);
    }
}
/*
$ java Demo19_22
[3, 5, 8, 7]
[3, 5, 7, 8]
8
*/
```

工具类Collections中全部为静态方法，我们可以直接导入静态方法，使之使用时不用写类名Collecions

import static java.util.Collections.sort;

import static java.util.Collections.max;

或者将Collections类中的静态方法都导入进来

import java.util.Collections.*;

```java
import java.util.ArrayList;
import static java.util.Collections.*;
import java.util.List;

class Demo19_22 {
    public static void main(String[] args){
        List<Integer> list = new ArrayList<Integer>();
        list.add(3);
        list.add(5);
        list.add(8);
        list.add(7);

        System.out.println(list);
        
        sort(list);
        
        System.out.println(list);

        Integer max = max(list);

        System.out.println(max);
    }
}
```

静态导入特性不仅适用于静态方法还适用于静态变量

# 20

# 20_01System类

### getProperties方法

    static Properties getProperties() 
        确定当前的系统属性。 

    java.util 
    类 Properties
    java.lang.Object
        继承者 java.util.Dictionary<K,V>
            继承者 java.util.Hashtable<Object,Object>
                继承者 java.util.Properties
    所有已实现的接口： 
        Serializable, Cloneable, Map<Object,Object> 


```java
import java.util.Properties;
import java.util.Set;

class Demo20_01{
    public static void main(String[] args){
        
        Properties prop = System.getProperties();

        Set<String> nameSet = prop.stringPropertyNames();

        for(String name:nameSet){
            String value = prop.getProperty(name);
            System.out.println(name+"......"+value);
        }
    }
}
/*部分输出
$ java Demo20_01
java.runtime.name......Java(TM) SE Runtime Environment
sun.boot.library.path......E:\Program Files\Java\jre1.8.0_201\bin
java.vm.version......25.201-b09
java.vm.vendor......Oracle Corporation
java.vendor.url......http://java.oracle.com/
path.separator......;
java.vm.name......Java HotSpot(TM) 64-Bit Server VM
file.encoding.pkg......sun.io
user.script......
user.country......CN
sun.java.launcher......SUN_STANDARD
sun.os.patch.level......
java.vm.specification.name......Java Virtual Machine Specification
user.dir......F:\doctor\JiuXieXiangGuan\XiuLian\GEEK\BiXiangDong\project
java.runtime.version......1.8.0_201-b09
java.awt.graphicsenv......sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs......E:\Program Files\Java\jre1.8.0_201\lib\endorsed
os.arch......amd64
java.io.tmpdir......C:\Users\Ivan\AppData\Local\Temp\
line.separator......

java.vm.specification.vendor......Oracle Corporation
*/
```

我们注意有一些东西在不同系统上是不同的，比如说转义符号

```java
System.out.println("hello\r\nworld");
```

在UNIX系统上可能就不识别\r符号，那怎么办呢？怎么才能使得含这种语句的程序跨平台呢？

```java
private static final String LINE_SEPARATOR = System.getProperties().getProperty("line.separator");

System.out.println("hello"+LINE_SEPARATOR+"world");
```

### currentTimeMillis方法

    public static long currentTimeMillis()

    返回以毫秒为单位的当前时间。注意，当返回值的时间单位是毫秒时，值的粒度取决于底层操作系统，并且粒度可能更大。例如，许多操作系统以几十毫秒为单位测量时间。 

    请参阅 Date 类的描述，了解可能发生在“计算机时间”和协调世界时（UTC）之间的细微差异的讨论。 
    返回：
    当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）。

```java
class Demo20_01_2{
    public static void main(String[] args){
        long currenttime = System.currentTimeMillis();
        System.out.println(currenttime);
        System.out.println(currenttime/1000/60/60/24/365);
        System.out.println(currenttime/(double)1000/60/60/24/365);
        System.out.println(currenttime/(double)1000/(60*60*24*365));
        System.out.println(currenttime/(double)(1000*60*60*24*365));
    }
}
/*
$ java Demo20_01_2
1576050226835
49
49.976224848902845
49.976224848902845
1071.2474427603154
*/
```

该方法一般用来测量代码执行的时间，在代码头获取当前时间，在代码尾获取当前时间，两者相减得出代码运行时间

# 20_02Runtime类

类的API介绍

    java.lang.Object
        继承者 java.lang.Runtime

    --------------------------------------------------------------------------------

    public class Runtimeextends Object每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。 

    应用程序不能创建自己的 Runtime 类实例。

1.Runtime类没有构造函数，说明构造函数被私有化

2.方法不都是静态，说明一定存在至少一个静态方法返回该类的实例

3.只有一个静态方法返回该类的实例，说明该类采用单例设计模式(其实也不一定的，完全可以在该静态方法中创建对象)

类中的方法:

    static Runtime getRuntime() 
        返回与当前 Java 应用程序相关的运行时对象。 

    Process exec(String command) 
        在单独的进程中执行指定的字符串命令。 

exec代表execute执行的意思，.exe就代表的是execute可执行

```java
import java.io.IOException;

class Demo20_02 {
    public static void main(String[] args) {
        Runtime r = Runtime.getRuntime();
        try {
            r.exec("notepad.exe");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

执行此文件就会打开记事本功能，也就是说开启了一个进程，如果要控制该进程的话，我们需要获取该进程对象

### Process类

    java.lang 
    类 Process
    java.lang.Object
        继承者 java.lang.Process

    --------------------------------------------------------------------------------

    public abstract class Process extends Object

我们看到该类为抽象类

    abstract  void destroy() 
        杀掉子进程。 

```java
import java.io.IOException;

class Demo20_02_02 {
    public static void main(String[] args) {
        Runtime r = Runtime.getRuntime();
        try {
            Process p = r.exec("notepad.exe");
            try{Thread.sleep(5000);}catch(Exception e){}
            p.destroy();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

执行该文件后，会打开记事本功能，5s后关闭

# 20_03Math类

常用方法(很多方法都被重载，这里只记录重载中的一种):

    static int abs(int a) //有重载
        返回 int 值的绝对值。 

    static int max(int a, int b)//有重载 
        返回两个 int 值中较大的一个。 

    static double pow(double a, double b) //无重载
        返回第一个参数的第二个参数次幂的值。 

以下3个方法注意区分，返回的都是double类型的值

1.ceil()方法返回数轴上在参数值右边，最靠近参数值的整数

2.floor()方法返回数轴上在参数值左边，最靠近参数值的整数

3.round()方法返回将参数值四舍五入后的值

另外:
    static double random() 
        返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 

上述方法用于生成随机数，此外Java中还有类Random也用于生成伪随机数

# 20_04Date类

```java
import java.util.Date;

class Demo20_04 {
    public static void main(String[] args){
        Date date = new Date();
        System.out.println(date);
    }
}
/*
$ java Demo20_04
Wed Dec 11 15:35:52 CST 2019
*/
```

1.毫秒值--->日期

构造函数Date d = new Date(timeMillis);

通过setTime方法

2.日期--->毫秒值

通过getTime方法

演示:

```java
import java.util.Date;

class Demo20_04 {
    public static void main(String[] args){
        Date date = new Date();
        System.out.println(date);

        Date date2 = new Date(1576050226835l);
        System.out.println(date2);
        
        System.out.println(date2.getTime());

    }
}
/*
$ java Demo20_04
Wed Dec 11 15:49:05 CST 2019
Wed Dec 11 15:43:46 CST 2019
1576050226835
*/
```

# 20_05DateFormate类_将Date类型转换为String类型

DateFormate类

    java.text 
    类 DateFormat
    java.lang.Object
        继承者 java.text.Format
            继承者 java.text.DateFormat
    所有已实现的接口： 
    Serializable, Cloneable 
    直接已知子类： 
    SimpleDateFormat 

    --------------------------------------------------------------------------------

    public abstract class DateFormat extends FormatDateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -> 文本）、解析（文本-> 日期）和标准化。


    static DateFormat getDateInstance() 
        获取日期格式器，该格式器具有默认语言环境的默认格式化风格。 
    
    static DateFormat getDateInstance(int style) 
        获取日期格式器，该格式器具有默认语言环境的给定格式化风格。 

    static DateFormat getDateTimeInstance() 
        获取日期/时间格式器，该格式器具有默认语言环境的默认格式化风格。 

    static DateFormat getDateTimeInstance(int dateStyle, int timeStyle) 
        获取日期/时间格式器，该格式器具有默认语言环境的给定日期和时间格式化风格。 

    String format(Date date) 
        将一个 Date 格式化为日期/时间字符串。 

获取默认格式化风格的格式器:

```java
import java.text.DateFormat;
import java.util.Date;

class Demo20_05 {
    public static void main(String[] args){
        Date date = new Date();

        DateFormat dateFormat = DateFormat.getDateInstance();

        String str_date = dateFormat.format(date);

        System.out.println(str_date);
    }
}
/*
$ java Demo20_05
2019-12-11
*/
```

获取给定格式化风格的格式器:

```java
import java.text.DateFormat;
import java.util.Date;

class Demo20_05_02 {
    public static void main(String[] args){
        Date date = new Date();

        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);

        String str_date = dateFormat.format(date);

        System.out.println(str_date);
    }
}
/*
$ java Demo20_05_02
2019年12月11日 星期三
*/
```

我们看到DateFormate为抽象类，那么类中的静态方法获取类的实例是什么类型的呢？

```java
import java.text.DateFormat;

class Demo20_05_03 {
    public static void main(String[] args){
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);
        Class<?> c = dateFormat.getClass();
        System.out.println(c.getName());
    }
}
/*
$ java Demo20_05_03
java.text.SimpleDateFormat
*/
```

我们看到getDateInstance()方法返回的是DateFormate类的子类对象SimpleDateFormate类的实例

### SimpleDateFormate类_自定义Date类型转换为String类型的格式

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class Demo20_05_04 {
    public static void main(String[] args){
        Date date = new Date();

        SimpleDateFormat sdf = new SimpleDateFormat("yyyy--MM--dd");//2019--12--11
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy--MM-+++***&^%$#@!-dd");//2019--12-+++***&^%$#@!-11
        String str_date = sdf.format(date);
        System.out.println(str_date);
    }
}
```

# 20_06DateFormate类_将String类型转换为Date类型

parse方法用于将String类型的数据转换为Date类型的数据，该方法会抛出异常

```java
import java.text.DateFormat;
import java.util.Date;

class Demo20_06{
    public static void main(String[] args) throws Exception{

        DateFormat dateFormat = DateFormat.getDateInstance();//默认格式器，只能解析yyyy-MM-dd格式
        String str_date = "2019-9-11";

        /*
        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG);
        String str_date = "2019年9月11日";
        $ java Demo20_06
        Wed Sep 11 00:00:00 CST 2019
         */
        Date date = dateFormat.parse(str_date);
        System.out.println(date);
    }
}
/*
$ java Demo20_06
Wed Sep 11 00:00:00 CST 2019
*/
```

使用SimpleDateFormate类解析自定义格式的时间

```java
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

class Demo20_06_2{
    public static void main(String[] args) throws Exception{


        DateFormat dateFormat = new SimpleDateFormat("yyyy年MM**dd啦啦");
        String str_date = "2019年9**11啦啦";

        Date date = dateFormat.parse(str_date);
        System.out.println(date);
    }
}
/*
$ java Demo20_06_2
Wed Sep 11 00:00:00 CST 2019
*/
```

# 20_07Date类练习

问题:

2012-3-17到2012-4-6中间一共有多少天？

```java
import java.text.DateFormat;
import java.util.Date;

class Demo20_07{
    public static void main(String[] args) throws Exception{
        
        DateFormat df = DateFormat.getDateInstance();

        Date startDate = df.parse("2012-3-17");
        Date endDate = df.parse("2012-4-6");

        long startMillis = startDate.getTime();
        long endMillis = endDate.getTime();
        long result = endMillis - startMillis;
        System.out.print(result/1000/60/60/24);
    }
}
/*
$ java Demo20_07
20
*/
```

# 20_08Calendar类

```java
import java.util.Calendar;

class Demo20_08{
    public static void main(String[] args){
        Calendar c = Calendar.getInstance();

        int year = c.get(Calendar.YEAR);
        int month = c.get(Calendar.MONTH);
        int day = c.get(Calendar.DAY_OF_MONTH);
        
        System.out.println(year+"年"+month+"月"+day+"日");
    }
}
/*
$ java Demo20_08
2019年11月12日
*/
```

# 20_03IO_字符流_FileWriter

```java
import java.io.FileWriter;
import java.io.IOException;

class DemoIO20_03 {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("e:/FileWriter.txt");//类似于建立FileWriter.txt文件并打开

        fw.write("str");//类似于在FileWriter.txt中写入东西

        fw.flush();//类似于保存

        fw.close();//类似于关闭FileWriter.txt
    }
}
```

FileWriter fw = new FileWriter("e:/FileWriter.txt");如果该文件不存在会建立该文件，如果该文件存在会覆盖该文件

![DemoIO20_03.png](https://github.com/geekavan/BiXiangdong/blob/master/DemoIO20_03.png)

# 20_04IO_字符流_FileWriter细节_换行和续写

怎么换行写入呢？联系我们之前学过的System类就可以了

```java
import java.io.FileWriter;
import java.io.IOException;

class DemoIO20_03_2 {
    private static final String LINE_SEPARATOR = System.getProperty("line.separator");

    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("e:/FileWriter.txt");

        fw.write("str"+LINE_SEPARATOR+"第二行");

        fw.flush();

        fw.close();
    }
}
```

![DemoIO20_03_2.png](https://github.com/geekavan/BiXiangdong/blob/master/DemoIO20_03_2.png)

续写示例:

```java
import java.io.FileWriter;
import java.io.IOException;

class DemoIO20_04 {
    public static void main(String[] args) throws IOException {
        
        FileWriter fw = new FileWriter("e:/FileWriter.txt",true);

        fw.write("续写内容");

        fw.close();
    }
}
```

![DemoIO20_04.png](https://github.com/geekavan/BiXiangdong/blob/master/DemoIO20_04.png)

注意:

1.我们看到若想续写，只要调用适当的构造方法就好了

2.我们这里们并没有调用flush()方法，"续写内容"怎么还写入了呢？这是因为close()方法里边封装了flush()方法，就类似于我们关闭记事本软件时，软件会提醒我们是否保存，而我们点击了保存这个过程一样

# 20_05IO_字符流_FileWriter_异常处理

```java
import java.io.FileWriter;
import java.io.IOException;

class DemoIO20_04 {
    public static void main(String[] args){
        
        FileWriter fw = null;
        try {
            fw = new FileWriter("e:/FileWriter.txt", true);
            fw.write("续写内容");
        } catch (IOException e) {
            e.printStackTrace();
        }
        finally{
            if(fw!=null)
            try {
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

注意:

1.资源要在finally内关闭，因为如果一旦try语句内出现异常，程序会跳转到其它地方，这将占用资源，所以finally语句中有fw.close();

2.FileWriter对象fw要定义在trycatch语句外边，因为finally语句里面要用到FileWriter对象fw，如果定义在trycatch语句里边的话，finally中的fw将无法识别

3.fw.close()语句也可能会抛出异常，所以它也需要trycatch

4.如果try语句中建立文件失败，会直接执行finally中的语句fw.close()方法，但是try中的语句异常，fw还是null值，这将会抛出空指针异常，所以前面加上了判断，使得fw不可以在为null条件下执行fw.close()

# 20_06IO_字符流_FileReader_读取方式一

```java
import java.io.FileReader;
import java.io.IOException;

class DemoIO20_06 {
    public static void main(String[] args) throws IOException {
        FileReader fr = new FileReader("e:/FileWriter.txt");

        int ch = 0;
        while((ch=fr.read())!=-1)                       
            System.out.print((char)ch);

        fr.close();
    } 
}
/*
$ java DemoIO20_06
str
第二行续写内容
*/
```

# 20_06IO_字符流_FileReader_读取方式二

abc.txt的内容为:

![abc](https://github.com/geekavan/BiXiangdong/blob/master/abc.png)

```java
import java.io.FileReader;
import java.io.IOException;

class DemoIO20_07_2{
    public static void main(String[] args){
        FileReader fr = null;

        try {
            fr = new FileReader("f:/abc.txt");
            char[] ch = new char[3];
            while((fr.read(ch))!=-1){
                System.out.println(ch);
            }
        } catch (Exception e) {
            throw new RuntimeException("读取失败！");
        }
        finally{
            try{
            fr.close();
            }
            catch(IOException e){throw new RuntimeException("关闭异常！");}
        }
    }
}
/*
abc
dec
*/
```

大家主要看try语句里边的内容，我们可以了解到读取方式一为以int ch这一个变量为"中转站"，从输入流读取一个元素就输出一个元素；方式二以char[] ch这一个char类型的数组作为"中转站"，从输入流读取一整个char的数据之后再输出；

为什么输出是abc和dec呢？因为第一次读取的时候，ch数组长度为3所以读取了3个元素就是abc，而再次读取的时候，读取d覆写了a，读取e覆写了b，继续读取的时候发现读取流已经没有数据了为-1，这个时候ch数组数据为dec第2号索引位置的c没有被覆写，输出就是dec了

那怎么精确输出我们想要的abcde呢？其实我们调用fr.read(ch)的时候，会返回一参数，该参数会记录更新了几个数据，如下:

```java
import java.io.FileReader;
import java.io.IOException;

class DemoIO20_07_2{
    public static void main(String[] args){
        FileReader fr = null;

        try {
            fr = new FileReader("f:/abc.txt");
            char[] ch = new char[3];
            int len = 0;
            while((len = fr.read(ch))!=-1){
                System.out.println(len);
                System.out.println(ch);
            }
        } catch (Exception e) {
            throw new RuntimeException("读取失败！");
        }
        finally{
            try{
            fr.close();
            }
            catch(IOException e){throw new RuntimeException("关闭异常！");}
        }
    }
}
/*
3
abc
2
dec
*/
```

这里我们使用int类型变量len记录每次更新了几个数据，我们能看到第一次更新了3个数据，第二次只更新了2个数据，为了准确输出我们想要输出的数据，我们有(下面这个完整正确的例子以上面讲过的FileWriter.txt为源数据):


```java
import java.io.FileReader;
import java.io.IOException;

class DemoIO20_07 {
    public static void main(String[] args) throws IOException {
        FileReader fr = new FileReader("e:/FileWriter.txt");

        char[] ch = new char[3];
        int num = 0;

        while((num = fr.read(ch))!=-1){
            System.out.print(new String(ch, 0, num));
        }
        
        fr.close();
    }
}
/*
$ java DemoIO20_07
str
第二行续写内容
*/
```

# 21

# 21_08_练习_复制文本文件

题目:将d盘的文本文件复制到f盘

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

class Demo21_08{
    public static void main(String[] args) throws IOException{
        /**
         * 思路：
         * 1.打开读文件流
         * 2.打开写文件流
         * 3.频繁读取文件
         * 4.关闭流
         */
        FileReader fr = new FileReader("e:/FileWriter.txt");
        FileWriter fw = new FileWriter("f:/随便起的名字.txt");
        int ch = 0;
        while((ch=fr.read())!=-1){
            fw.write(ch);
        }
        fr.close();
        fw.close();
    }
}
```

# 21_09_练习2_复制文本文件

练习一使用的是单个字符读写，使用抛出异常，本篇内容练习二使用数组读写，使用捕获异常

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

class Demo21_09{
    private static final int BUFFER_SIZE = 4096;
    public static void main(String[] args){
        FileReader fr = null;
        FileWriter fw = null;
        try{
            fr = new FileReader("e:/FileWriter.txt");
            fw = new FileWriter("f:/就叫这个名字了.txt");

            char[] ch = new char[BUFFER_SIZE];
            int len = 0;

            while((len=fr.read(ch))!=-1){
                fw.write(ch, 0, len);
            }
        }
        catch(IOException e){}
        finally{
            try{if(fr!=null) fr.close();}catch(IOException e){throw new RuntimeException("读取流关闭异常");}
            try{if(fw!=null) fw.close();}catch(IOException e){throw new RuntimeException("写入流关闭异常");}
        }
    }
}
```

# 21_11字符流_缓冲区

何为缓冲区？我们所举的例子中int ch与char[] ch都可以认为是缓冲区，缓冲区是一个大的概念，是提高软件性能的一个常用手段

生活中有很多能体现"缓冲区"概念的例子，如去超市买东西，如果我们打算买的东西比较多，我们会拿一个篮子，或者推一个手推车，没有说我打算买一堆的东西，但是我买一个东西结一下帐，再去买另一个东西这样子的情景；这里"篮子"或者"手推车"就是一个"缓冲区"的例子，我们看到"缓冲区"的出现，提高了我们购物的效率

其实这个例子很有意思，我们再来看"篮子"和"手推车"，篮子的特点是体积较小，好拿；手推车的特点是省力，体积较大；如果我们使用手推车装东西的话，一个缺点就是我们在付款的时候需要把物品一件件的捡到扫描台上，我们可以在手推车上放置一个篮子，这样付款的时候我们就可以直接提着篮子出来，不用弯腰去捡物品，还可以使用手推车的有轮子的便捷

# 21_12字符流_缓冲区_BufferedWriter

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

class Demo21_12{
    public static void main(String[] args) throws IOException{
        FileWriter fw = new FileWriter("e:/test.txt");

        BufferedWriter bufw = new BufferedWriter(fw);

        for(int i=1;i<5;i++){
            bufw.write("abcde"+i);
            bufw.newLine();
            bufw.flush();
        }

        bufw.close();
    }
}
```

程序结果:

![test](https://github.com/geekavan/BiXiangdong/blob/master/test.png)

其实字符流缓冲区就是字符流再加上数组实现的，BufferedWriter为了提高效率而生

# 21_13字符流_缓冲区_BufferedReader

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

class Demo21_13{
    public static void main(String[] args) throws IOException{
        FileReader fr = new FileReader("e:/test.txt");

        BufferedReader bufr = new BufferedReader(fr);

        String line = null;

        while((line = bufr.readLine())!=null){
            System.out.println(line);
        }

        bufr.close();
    }
}
/*
abcde1
abcde2
abcde3
abcde4
*/
```

# 21_16MyBufferedReader的read方法

我们知道所谓的字符流缓冲区就是格外维护了一个数组而已，在这一节中我们尝试自己建立一个BufferedReader类并且模拟read方法与readLine方法

自己的写法:

```java
import java.io.FileReader;
import java.io.IOException;

class Demo21_16{
    public static void main(String[] args) throws IOException{
        FileReader fr = new FileReader("e:/test.txt");

        MyBufferedReader bufr = new MyBufferedReader(fr);

        int ch = 0 ;
        while((ch = bufr.myRead())!=-1){
            System.out.print((char)ch);
        }
        bufr.close();
    }
}
class MyBufferedReader{
    private FileReader fr;
    private char[] buffer;
    private static final int BUFFER_SIZE = 3;//容量大小都试验过可以
    private int index = 0;
    private int endIndex = -2;
    MyBufferedReader(FileReader fr){
        this.fr = fr;
        this.buffer = new char[BUFFER_SIZE];
    }
    public int myRead() throws IOException{
        if(endIndex==-2)
            endIndex = this.fr.read(buffer);
        if(index==BUFFER_SIZE){
            endIndex = this.fr.read(buffer);
            this.index = 0;
        }
        if(this.index<this.endIndex){
            return buffer[this.index++];
        }
        return -1;
    }
    public void close()throws IOException{
        this.fr.close();
        return ;
    }
}
/*
abcde1
abcde2
abcde3
abcde4
*/
```

其实自己的写法中有一点不爽在于if(endIndex==-2)只执行一次而已，却要每回都做判断，放在构造函数中却也要使得构造函数抛出或者处理异常，没有很快地想到好的解决办法

老师的写法:

```java
import java.io.FileReader;
import java.io.IOException;

class Demo21_16_2{
    public static void main(String[] args) throws IOException{
        FileReader fr = new FileReader("e:/test.txt");

        MyBufferedReader bufr = new MyBufferedReader(fr);

        int ch = 0 ;
        while((ch = bufr.myRead())!=-1){
            System.out.print((char)ch);
        }
        bufr.close();
    }
}
class MyBufferedReader{
    private FileReader fr;
    private char[] buffer;
    private static final int BUFFER_SIZE = 2;
    private int pos = 0;
    private int count = 0;
    MyBufferedReader(FileReader fr){
        this.fr = fr;
        this.buffer = new char[BUFFER_SIZE];
    }
    public int myRead() throws IOException{
        if(count==0){
            count = this.fr.read(buffer);
            pos = 0;
        }
        if(count<0)
            return -1;
        char ch = buffer[pos++];
        count--;
        return ch;
    }
    public void close()throws IOException{
        this.fr.close();
        return ;
    }
}
/*
abcde1
abcde2
abcde3
abcde4
*/
```

# 21_17MyBufferedReader的readLine方法

```java
import java.io.FileReader;
import java.io.IOException;

class Demo21_17{
    public static void main(String[] args) throws IOException{
        FileReader fr = new FileReader("e:/test.txt");

        MyBufferedReader bufr = new MyBufferedReader(fr);

        String line = null ;
        while((line = bufr.MyReadLine())!=null){
            System.out.println(line);
        }
        bufr.close();
    }
}
class MyBufferedReader{
    private FileReader fr;
    private char[] buffer;
    private static final int BUFFER_SIZE = 2;
    private int pos = 0;
    private int count = 0;
    MyBufferedReader(FileReader fr){
        this.fr = fr;
        this.buffer = new char[BUFFER_SIZE];
    }
    public int myRead() throws IOException{
        if(count==0){
            count = this.fr.read(buffer);
            pos = 0;
        }
        if(count<0)
            return -1;
        char ch = buffer[pos++];
        count--;
        return ch;
    }
    public void close()throws IOException{
        this.fr.close();
        return ;
    }
    public String MyReadLine() throws IOException{
        StringBuilder sb = new StringBuilder();

        int ch = 0;
        while((ch = myRead())!=-1){
            if(ch=='\r')
                continue;
            if(ch=='\n')
                return sb.toString();
            sb.append((char)ch);
        }
        if(sb.length()!=0)
            return sb.toString();
        return null;
    }
}
/*
abcde1
abcde2
abcde3
abcde4
*/
```

# 21_18_19装饰设计模式_与继承的区别

```java
class Demo21_18_19{
    public static void main(String[] args){
        NewWorker newW = new NewWorker();

        newW.walk();
    }
}
abstract class Person{
    int age;
    String name;
    Person(){}
    Person(String name, int age){this.name = name;this.age = age;}
    abstract void walk();
}
class Worker extends Person{
    Worker(){}
    Worker(String name, int age){
        super(name, age);
    }
    void walk(){
        System.out.println("两条腿走路");
    }
}
class NewWorker extends Worker{
    void walk(){
        System.out.println(this.name+"......"+this.age+"......."+"坐地铁");
        super.walk();
    }
}
/*
null......0.......坐地铁
两条腿走路
*/
```

1.上述程序中，我们先有了一个类Worker，类Worker中有一个方法walk，随着程序的发展，类Worker中的walk方法升级了，需要对原有的walk方法进行**功能的扩展和增强**，我们必须要明确的一点是不能在原有的Worker类里边进行修改，因为改动原有的已经正确的程序可能是一场灾难

2.很多小伙伴可能会想到利用Java的继承机制，上面的程序中我们就是以Java的继承机制实现的，我们这里先讨论Java的继承机制的缺点，再引出装饰器设计模式

这种方式有什么缺点呢？比如说我们又有一个类为Student，这个类继承了Person类，也有walk方法，但是我们也要对其进行功能的增强，使得Student对象的walk方法也具备"坐地铁"的高效性，这样子的话，这个Person体系为：

    Person
        |--Worker
            |--NewWorker
        |--Student
            |--NewStudent

那么如果我再出现其他的类别呢？比如说又出现了Doctor类，他也具备walk的功能，我也想让他具备"坐地铁"的高效性，我要专门为了提高walk的效率而再次新建一个类NewDoctor这样子的话就会使得Person的体系越来越臃肿

怎么解决呢？不让体系变得臃肿而且使得已存在的一些类中的一些方法变得高效？我们可以将高效的方法抽离出来，封装成一个独立的对象，如:

```java
class Demo21_18_19_2{
    public static void main(String[] args){

        Worker w = new Worker();
        NewPerson newP = new NewPerson(w);

        newP.walk();
    }
}
abstract class Person{
    int age;
    String name;
    Person(){}
    Person(String name, int age){this.name = name;this.age = age;}
    abstract void walk();
}
class Worker extends Person{
    Worker(){}
    Worker(String name, int age){
        super(name, age);
    }
    void walk(){
        System.out.println("两条腿走路");
    }
}
class NewPerson extends Person{
    private Person p;
    NewPerson(Person p){
        this.p = p;
    }
    void walk(){
        System.out.println(p.name+"......"+p.age+"......"+"坐地铁");
        p.walk();
    }
}
/*
null......0......坐地铁
两条腿走路
*/
```

我们看到上述程序中，我们没有使用继承机制，而是建立了一个NewPerson的类，里边封装了"坐地铁"的使walk方法变得高效的方法，这样子的话无论我们传入什么Peroson的子类，无论是Worker还是Student类对象都可以使用，使得自己的walk方法变得高效，这样子的话Person的体系就为:

    Person
        |--Worker
        |--Student
        |--NewPerson

体系结构清晰多了，这里使用的就是装饰设计模式

# 21_20LineNumberReader

```java
import java.io.FileReader;
import java.io.IOException;
import java.io.LineNumberReader;

class Demo21_20{
    public static void main(String[] args) throws IOException{
        FileReader fr = new FileReader("e:/test.txt");

        LineNumberReader lnfr = new LineNumberReader(fr);

        String line = null;
        while((line = lnfr.readLine())!=null){
            System.out.println(lnfr.getLineNumber()+":"+line);
        }
    }
}
```

LineNumberReader类就是使用了装饰设计模式，所以建立类对象的时候需要传入被装饰类对象，这个类提高效率的同时，也增加了可以阅读行号这一个功能

# 21_21字节流

字符流只能操作文本文件，有了字节流对象之后我们就可以操作媒体文件了，当然数据的存储都要落实到字节上，所以文本文件也可以用字节流对象操作

写入:

```java
import java.io.FileOutputStream;
import java.io.IOException;

class Demo21_21{
    public static void main(String[] args) throws IOException{
        FileOutputStream fos = new FileOutputStream("e://fostest.txt");

        fos.write("abcdef".getBytes());
    }
}
```

结果:

![fostest](https://github.com/geekavan/BiXiangdong/blob/master/fostest.png)

其实操作字节流和操作字符流差不多，这里要注意的一点是，字节流对象写入数据的时候并不用flush方法，我们打开FileOutputStream源码就可以发现，它的flush方法继承于OutputStream，而OutputStream类的flush方法中没有任何语句

但是关闭流还是要的，不然别的资源访问不了该文件

读取:

```java
import java.io.FileInputStream;
import java.io.IOException;

class Demo21_21_2{
    public static void main(String[] args) throws IOException{
        FileInputStream fis = new FileInputStream("e://fostest.txt");

        //方式一
        //一次读入一个字节
        // int ch = 0;
        // while((ch=fis.read())!=-1){
        //     System.out.print((char)ch);
        // }

        // 方式二
        //利用byte类型的数组
        // byte[] b = new byte[1024];
        // int len = 0;
        // while((len = fis.read(b))!=-1){
        //     System.out.println(new String(b, 0, len));
        // }

        //方式三
        //使用byte类型的数组
        // byte[] b = new byte[fis.available()];
        // fis.read(b);
        // System.out.println(new String(b));
    }
}
```

# 21_22复制MP3

四种方式用时一览表:
    方式一:FileInputStream类使用自定义缓冲区         159
    方式二:BufferedInputStream类加上自定义缓冲区     70
    方式三:BufferedInputStream类加上read方法        390
    方式四:FileInputStream类加上read方法            73658

### 方式一_FileInputStream类使用自定义缓冲区

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

class Demo21_22{
    public static void main(String[] args) throws IOException{
        long start = System.currentTimeMillis();
        FileInputStream fis = new FileInputStream("e://0.mp3");
        FileOutputStream fos = new FileOutputStream("e://1.mp3");

        byte[] b = new byte[1024];

        int len = 0;
        while((len = fis.read(b))!=-1){
            fos.write(b,0,len);
        }

        fos.close();
        fis.close();
        long end = System.currentTimeMillis();
        System.out.println(end-start);
    }
}
/*
159
*/
```

### 方式二_BufferedInputStream类加上自定义缓冲区

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

class Demo21_22_2{
    public static void main(String[] args) throws IOException{
        long start = System.currentTimeMillis();
        FileInputStream fis = new FileInputStream("e://0.mp3");
        BufferedInputStream bufi = new BufferedInputStream(fis);

        FileOutputStream fos = new FileOutputStream("e://2.mp3");
        BufferedOutputStream bufo = new BufferedOutputStream(fos);

        byte[] b = new byte[1024];

        int len = 0;
        while((len = bufi.read(b))!=-1){
            bufo.write(b,0,len);
        }
        bufo.close();
        bufi.close();
        long end = System.currentTimeMillis();
        System.out.println(end-start);
    }
}
/*
70
*/
```

### 方式三_BufferedInputStream类加上read方法

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

class Demo21_22_3{
    public static void main(String[] args) throws IOException{
        long start = System.currentTimeMillis();
        FileInputStream fis = new FileInputStream("e://0.mp3");
        BufferedInputStream bufi = new BufferedInputStream(fis);

        FileOutputStream fos = new FileOutputStream("e://3.mp3");
        BufferedOutputStream bufo = new BufferedOutputStream(fos);

        int ch = 0;
        while((ch = bufi.read())!=-1){
            bufo.write(ch);
        }

        bufo.close();
        bufi.close();
        long end = System.currentTimeMillis();
        System.out.println(end-start);
    }
}
/*
390
*/
```

### 方式四_FileInputStream类加上read方法

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

class Demo21_22_4{
    public static void main(String[] args) throws IOException{
        long start = System.currentTimeMillis();
        FileInputStream fis = new FileInputStream("e://0.mp3");

        FileOutputStream fos = new FileOutputStream("e://4.mp3");

        int ch = 0;
        while((ch = fis.read())!=-1){
            fos.write(ch);
        }

        fos.close();
        fis.close();
        long end = System.currentTimeMillis();
        System.out.println(end-start);
    }
}
/*
73658
*/
```

# 22

# 22_23演示键盘录入

```java
import java.io.IOException;
import java.io.InputStream;

class Demo22_23 {
    public static void main(String[] args) throws IOException {
        InputStream in  = System.in;

        int ch = in.read();//阻塞式方法
        System.out.println(ch);

        int ch1 = in.read();
        System.out.println(ch1);

        int ch2 = in.read();
        System.out.println(ch2);

        System.out.println("'\\r'"+(int)'\r');
        System.out.println("'\\n'"+(int)'\n');
    }
}
```

1.System.in会返回一个InputStream类对象

2.in.read()方法是阻塞式方法，就是程序会一直等待键盘的输入

3.当键盘输入Enter时，键盘输入完毕

4.示例中键盘输入字母a与Enter，其中Enter在Windows系统中其实为两个字符分别为'\r'与'\n'，其中'\r'对应光标回退到第一格，'\n'对应光标到下一行

5.'\r'对应的ASCII码为13，'\n'对应的ASCII码为10

6.和字符与字节输入流不同，标准输入流关闭后本程序里不能够再开启，如:

        InputStream in  = System.in;

        int ch = in.read();//阻塞式方法
        System.out.println(ch);

        in.close();

        InputStream in0  = System.in;

        int ch1 = in0.read();
        System.out.println(ch1);

        /*输出为(部分):
        Exception in thread "main" java.io.IOException: Stream closed
        */

# 22_24读取键盘录入

读取键盘录入，将输入变为大写输出，读取到over后结束

```java
import java.io.IOException;
import java.io.InputStream;

class Demo22_24 {
    public static void main(String[] args) throws IOException {
        InputStream in = System.in;

        StringBuilder sb = new StringBuilder();

        int ch = 0;

        while((ch = in.read())!=-1){
            String temp = sb.toString();
            if(ch=='\r')
                continue;
            if(ch=='\n'){
                System.out.println(temp.toUpperCase());
                if(temp.equals("over"))
                    break;
                sb.delete(0, sb.length());
            }
            else
                sb.append((char)ch);
        }
    }
}
```

# 22_25转换流

### 输入转换流

我们再看Demo22_24的例子，可以发现大部分代码就是在读取一行字符，这使我们想起BufferedReader对象的readLine方法，但是BufferedReader是字符流的装饰器，不能够装饰字节流InputStream对象，这该怎么办呢？这就需要用到转换流InputStreamReader

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

class Demo22_25 {
    public static void main(String[] args) throws IOException {
        // 键盘输入的字节流
        InputStream in = System.in;

        //将字节流转换为字符流
        InputStreamReader isr = new InputStreamReader(in);

        //将字符流进行高效装饰
        BufferedReader bufr = new BufferedReader(isr);

        String line = null;

        while((line = bufr.readLine())!=null){
            if("over".equals(line))
                break;
            System.out.println(line.toUpperCase());
        }
    }
}
/*
jijiejid
JIJIEJID
skfjosdjq
SKFJOSDJQ
over
*/
```

1.BufferedReader bufr = new BufferedReader(isr);语句不是必须的，它只是进行了一个高效的封装

2.字节读取和字符读取有什么区别吗？

    当然是有区别的，字节读取每次只读取一个字节，字符读取底层会调用2次字节读取并进行一次字符查表，显示字符；英文里两者也没有什么区别，因为英文字母每个字母只有一个字节，但是汉语就不同了，汉语的一个中文用了2个字节来存储，示例程序如下

示例1，使用字节流读取一个汉字需要读取两次

```java
import java.io.IOException;
import java.io.InputStream;

class Demo22_25_2 {
    public static void main(String[] args) throws IOException {
        InputStream in = System.in;
        int ch = in.read();
        System.out.println(ch);
        int ch1 = in.read();
        System.out.println(ch1);
    }
}
/*
爱
176
174
*/
```

示例2，使用字符流读取一个汉字只需要读取一次

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

class Demo22_25_2 {
    public static void main(String[] args) throws IOException {
        InputStream in = System.in;

        InputStreamReader isr = new InputStreamReader(in);
        int ch = isr.read();
        System.out.println((char)ch);
    }
}
/*
爱
爱
*/
```
    
### 输出转换流

System.out.println()这句我们一直在用的语句就用到了输出流，这句话是将字符数据转变为字节数据打印在控制台上，或许有些难以理解，但就类似于在硬盘上写数据一样，就纯文本数据来说肯定是将字符数据转变为字节数据再写入硬盘中，这两中情况下都用到了输出转换流技术

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintStream;

class Demo22_25_3 {
    public static void main(String[] args) throws IOException {
        InputStream is = System.in;
        InputStreamReader isr = new InputStreamReader(is);
        BufferedReader bufr = new BufferedReader(isr);

        PrintStream out = System.out;
        OutputStreamWriter osw = new OutputStreamWriter(out);
        BufferedWriter bufw = new BufferedWriter(osw);

        String line = null;
        while((line = bufr.readLine())!=null){
            if("over".equals(line))
                break;
            bufw.write((line.toUpperCase()));
            bufw.newLine();
            bufw.flush();
        }
    }
}
/*
niahoa
NIAHOA
kjdslf
KJDSLF
jfljoies
JFLJOIES
over
*/
```

上述程序的类似程序的解析图如下:

![22_25](https://github.com/geekavan/BiXiangdong/blob/master/22_25.png)

# 22_27流操作的基本规律

之所以总结流操作的规律是因为流的体系对象众多，初学者可能会搞不懂需要使用哪个对象来满足开发需求

1，明确是否有源和目的

    源分为      InputStream体系和Reader体系
    目的分为    OuputStream体系和Writer体系

2，明确是否为纯文本数据

    源      是     Reader体系
            否     InputStream体系

    目的    是     Writer体系
            否     OuputStream体系

3，明确源和目的的设备

    源
        硬盘：File
        键盘：System.in
        内存：数组
        网络：Socket

    目的
        硬盘：File
        控制台：System.out
        内存：数组
        网络：Socket

4，是否需要其他功能能

    高效
        BufferedInputStream装饰类   为了使InputStream的子类处理数据更加高效
        BufferedOutputStream装饰类   为了使OutputStream的子类处理数据更加高效

        BufferedReader装饰类        为了使Reader的子类处理数据更加高效  
        BufferedWriter装饰类        为了使Writer的子类处理数据更加高效
    转换
        InputStreamReader
        OuputStreamWriter

# 22_28_29流操作的基本规律_需求体现

### 需求1_复制一个文本

1.明确源和目的

    存在源      可能选择InputStream或Reader
    存在目的    可能选择OutputStream或Writer

2.明确是否为纯文本

    是          源选择体系：Reader
                目的选择体系：Writer

3.明确设备

    源设备      硬盘    File
    目的设备    硬盘    File

    所以综上所选择的对象为FileReader与FileWriter，注意后缀为对象所属体系

    FileReader fr = new FileReader("e:\\a.txt");
    FileWriter fw = new FileWriter("e:\\b.txt");

4.明确是否需要其他功能

    高效

    BufferedReader bufr = new BufferedReader(new FileReader("e:\\a.txt"));
    BufferedWriter bufw = new BufferedWriter(new FileWriter("e:\\b.txt"));


### 需求2_读取键盘录入信息_并写入到一个文件中

1，明确是否有源和目的

    有源        可选择InputStream体系与Reader体系
    有目的      可选择OutputStream体系与Writer体系

2，明确是否为纯文本数据

    是          源Reader
                目的：Writer

3，明确设备

    源
        键盘    System.in
    目的
        硬盘    File

    到这里就可以确定使用的对象了

    InputStream in = System.in;
    FileWriter fw = new FileWriter("e://a.txt");

    这两个对象就足以完成这个任务，但是上边是字节流，下边是字符流，键盘输入的最终也是字符数据，如果使用字节流，我们需要将获取的字节数据转换为字符串，再使用字符流操作，为了操作方便，我们将输入流从字节流转换为字符流

4，明确格外功能

    转换，需要

        InputStreamReader isr = new InputStreamReader(System.in);
        FileWriter fw = new FileWriter("e://a.txt");

    高效，需要

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new bufferedWriter(new FileWriter("e://a.txt"));

### 需求3_将一个文本数据显示在控制台上

1.明确是否存在源和目的

    存在源      可选择InputStream与Reader
    存在目的    可选择OutputStream与Writer

2.明确是否为纯文本数据

    是  源      Reader
        目的    Writer

3.明确设备

    源      文本    File
    目的    控制台  System.out

    FileReader fr = new FileReader("e:\\a.txt");
    OuputStream os = System.out;

4.明确是否需要额外功能

    转换
    FileReader fr = new FileReader("e:\\a.txt");
    OuputStreamWriter osw = new OuputStreamWriter(System.out);
    这样上下都是字符流，操作起来比较便捷

    高效
    BufferedReader bufr = new BufferedReader(new FileReader("e:\\a.txt"));
    BUfferedWriter bufw = new BufferedWriter(new OuputStreamWriter(System.out));

### 需求4_读取键盘录入数据_打印控制台上

1.明确是否存在源和目的

    存在源      可选择InputStream与Reader
    存在目的    可选择OutputStream与Writer

2.明确是否为纯文本数据

    是  源      Reader
        目的    Writer

3.明确设备

    源      键盘      System.in
    目的    控制台    System.out

    InputStream in = System.in;
    OuputStream os = System.out;

4.明确是否需要额外功能

    转换
    InputStreamReader isr = new InputStreamReader(System.in);
    OuputStreamWriter osw = new OuputStreamWriter(System.out);
    都转换为字符流

    高效
    BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
    BUfferedWriter bufw = new BufferedWriter(new OuputStreamWriter(System.out));

# 22_30转换流的编解码

我们先看下面一段代码

```java
import java.io.FileWriter;
import java.io.IOException;

class Demo22_30 {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("e:\\a.txt");
        fw.write("热血");
        fw.close();
    }
}
```

![22_30](https://github.com/geekavan/BiXiangdong/blob/master/22_30.png)

1.当执行fw.write("热血");语句时，会调用默认码表，也就是系统的设定码表，比如我们最常见系统的就是windows，语言设定的是中文简体，那么该系统的设定码表就是GBK

2.在GBK码表中，一个中文对应两个字节

3.程序在写入"热"这个汉字时，会先查找GBK码表，比如查找到该汉字对应的两个字节为8956，那么就会把该两个字节的数据存储到硬盘上，在写"血"汉字时同理

4.在读取时，如果我们使用FileReader对象读取，那么一样的道理，比如先读取"热"这个汉字，我们根据默认码表，一看是GBK两个字节代表一个字符，那么我们一次读取两个字节，比如我们读取到了两个字节8956，那么就会根据GBK来显示这两个字节所对应的字符为汉字"热"

那么如果我们想文本数据根据指定的编码表来存储到硬盘中，那么该怎么办呢？比如我们希望"热血"两个汉字通过UTF-8编码表来存储到硬盘中，这就需要用到转换流，在转换流对象里我们可以指定编码表

```java
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

class Demo22_30 {
    public static void main(String[] args) throws IOException {
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("e:\\a.txt"),"gbk");
        osw.write("你好");
        osw.close();

        InputStreamReader osr = new InputStreamReader(new FileInputStream("e:\\a.txt"));
        // 等价于InputStreamReader osr = new InputStreamReader(new FileInputStream("e:\\a.txt"),"gbk");
        BufferedReader bufr = new BufferedReader(osr);
        System.out.println(bufr.readLine());
        bufr.close();

    }
}
/*
你好
*/
```

编码时使用gbk码表解码时也使用gbk码表，程序正常执行，生成的a.txt为4个字节大小

```java
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

class Demo22_30 {
    public static void main(String[] args) throws IOException {
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("e:\\a.txt"),"utf-8");
        osw.write("你好");
        osw.close();

        InputStreamReader osr = new InputStreamReader(new FileInputStream("e:\\a.txt"));
        BufferedReader bufr = new BufferedReader(osr);
        System.out.println(bufr.readLine());
        bufr.close();

    }
}
/*
浣犲ソ
*/
```

生成文件时使用utf-8编码，在utf-8编码中每个汉字占有的字节数目不一致，"你好"两个字都占有3个字节，所以生成的a.txt文件占有6个字节，当读取时，程序按系统默认的编码表读取，在博主的机器上为gbk(windows下简体中文为GBK码表)，所以读取的时候为2个字节2个字节的读取，故出现3个字符

# 22_31File对象构造函数及字段

目前为止，利用流对象我们能操作文件的数据，但是不能操作一些其他的与文件相关的东西，比如说我们没办法获取文件的大小，文件的最后修改日期，没办法操作文件夹等，File对象就是解决这些问题的

```java
import java.io.File;

class Demo22_31 {
    public static void main(String[] args){
        File f1  = new File("e:\\a\\b\\a.txt");
        File f2 =new File("e:\\h","c");
        File f  = new File("e:\\a\\b");
        File f3  = new File(f,"\\c\\a.txt");

        System.out.println("f1......"+f1);
        System.out.println("f2......"+f2);
        System.out.println("f3......"+f3);
        
    }
}
/*
f1......e:\a\b\a.txt
f2......e:\h\c
f3......e:\a\b\c\a.txt
*/
```

1.我们看到f1将e:\a\b下a.txt封装成一个File对象，f2将e:\h下c封装成一个对象，f3将e:\a\b\c下a.txt封装成一个File对象

2.我们需要知道a.txt不一定是一个文件的名称，也有可能是一个文件夹的名称，c不一定是一个文件夹也有可能是一个文件

3.上述程序体现了File类的三种构造函数

4.我们要知道\\符号是名称分隔符，但是是Windows下的名称分隔符，在Unix下名称分隔符就为/，所以说上述程序在Unix下就会出错，为了让上述程序在哪一个系统下都可以正常运行，我们使用File对象中可以获取到系统名称分隔符的字段separator

```java
import java.io.File;
class Demo22_31_2 {
    public static void main(String[] args){
        File f1  = new File("e:"+File.separator+"a"+File.separator+"b"+File.separator+"a.txt");
        System.out.println("f1......"+f1);
    }
}
```

# 22_32File对象常见功能_获取

```java
import java.io.File;
import java.io.IOException;

class Demo22_32 {
    public static void main(String[] args) throws IOException {
        /*
        1.获取(这里文件指文件或文件夹)
            获取文件名称
            获取文件大小
            获取文件所在路径
            获取文件最后修改日期
        */
        File f = new File("e:\\a.txt");

        String name = f.getName();
        long len = f.length();
        String absPath = f.getAbsolutePath();
        String canPath = f.getCanonicalPath();
        long time = f.lastModified();

        System.out.println("name......"+name);
        System.out.println("len......"+len);
        System.out.println("absPath......"+absPath);
        System.out.println("canPath......"+canPath);
        System.out.println("time......"+time);
    }
}
/*
name......a.txt
len......0
absPath......e:\a.txt
canPath......E:\a.txt
time......0
*/
```

因为e盘下现在还不存在a.txt所以显示大小len为0，最后修改日期time为0，将文件改为一个已经存在的文件，并且将最后修改日期格式化有

```java
import java.io.File;
import java.io.IOException;
import java.sql.Date;
import java.text.DateFormat;

class Demo22_32_2 {
    public static void main(String[] args) throws IOException {
        /*
        1.获取(这里文件指文件或文件夹)
            获取文件名称
            获取文件大小
            获取文件所在路径
            获取文件最后修改日期
        */
        File f = new File("e:\\b.txt");

        String name = f.getName();
        long len = f.length();
        String absPath = f.getAbsolutePath();
        String canPath = f.getCanonicalPath();
        long time = f.lastModified();

        Date date = new Date(time);
        DateFormat df = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);
        String str_time = df.format(date);

        System.out.println("name......"+name);
        System.out.println("len......"+len);
        System.out.println("absPath......"+absPath);
        System.out.println("canPath......"+canPath);
        System.out.println("time......"+time);
        System.out.println("str_time......"+str_time);
    }
}
/*
name......b.txt
len......6
absPath......e:\b.txt
canPath......E:\b.txt
time......1578041595669
str_time......2020年1月3日 下午04时53分15秒
*/
```

# 22_33File对象常见功能_创建和删除

创建方法

```java
import java.io.File;
import java.io.IOException;

class Demo22_33 {
    public static void main(String[] args) throws IOException {
        File f = new File("F:\\a.txt");
        f.createNewFile();

        File f1 = new File("F:\\b.txt");
        System.out.println(f1.mkdir());

        File f2  = new File("f:\\a\\a.txt\\b.txt");
        f2.mkdirs();
    }
}
```

1.该程序会在f盘下创建a.txt文件，b.txt文件夹，会创建a文件夹，在a文件夹下创建a.txt文件夹，在a.txt文件夹下创建b.txt文件夹

2.f对象是f盘下a.txt文件，f1对象是b.txt文件夹，f2对象是f盘下a文件夹下a.txt文件夹下b.txt文件夹

3.创建File对象，如果目标不存在则创建，存在则创建失败

删除方法

```java
import java.io.File;
import java.io.IOException;

class Demo22_33 {
    public static void main(String[] args) throws IOException {
        File f2  = new File("f:\\a\\a.txt\\b.txt");
        f2.mkdirs();
        f2.delete();
    }
}
```

注意这里是b.txt文件夹被删除掉了

# 22_34File对象常见功能_判断

```java
import java.io.File;

class Demo22_34 {
    public static void main(String[] args){
        File f = new File("E:\\b.txt");

        System.out.println(f.exists());
        System.out.println(f.isFile());
        System.out.println(f.isDirectory());
    }
}
/*
true
true
false
*/
```

注意b.txt不一定是文件，也可能是文件夹，同理b不一定是文件夹，也可能是文件

把文件b.txt删除之后

```java
import java.io.File;

class Demo22_34 {
    public static void main(String[] args){
        File f = new File("E:\\b.txt");

        f.mkdir();//这里b.txt就是文件夹
        System.out.println(f.exists());
        System.out.println(f.isFile());
        System.out.println(f.isDirectory());
    }
}
/*
true
false
true
*/
```

# 22_35File对象常见功能_重命名

```java
import java.io.File;

class Demo22_35 {
    public static void main(String[] args){
        File f = new File("f:\\a.txt");
        f.renameTo(new File("e:\\eee.txt"));
    }
}
```

该程序段把f盘下a.txt文件移动到e盘下，并改名为eee.txt文件

# 22_36File对象常见功能_系统根目录和容量获取

获取系统根目录

```java
import java.io.File;

class Demo22_36 {
    public static void main(String[] args){

        File[] files = File.listRoots();

        for(File file:files){
            System.out.println(file);
        }
    }
}
/*
C:\
E:\
F:\
*/
```

容量获取

```java
import java.io.File;

class Demo22_36 {
    public static void main(String[] args){

        File f = new File("e:\\");

        System.out.println("getTotalSpace()......"+f.getTotalSpace());
        System.out.println("getFreeSpace()......"+f.getFreeSpace());
        System.out.println("getUsableSpace()......"+f.getUsableSpace());
    }
}
/*
getTotalSpace()......215016796160   总空间
getFreeSpace()......7096311808      可用空间
getUsableSpace()......7096311808    可供JVM使用的空间
*/
```

# 22_37File对象常见功能_获取目录内容

```java
import java.io.File;

class Demo22_37 {
    public static void main(String[] args){

        File f = new File("f:\\");

        String[] names = f.list();

        for(String name:names){
            System.out.println(name);
        }
    }
}
/*
$RECYCLE.BIN
360Downloads
a
abc.txt
b.txt
BaiduNetdiskDownload
circle
CloudMusic
Competition
doctor
graph
JavaTest
jobSortAndBinaryTree
MyDrivers
Program Files
Program Files (x86)
python
qqpcmgr_docpro
System Volume Information
Users
workUsingGit
小宇宙
桌面壁纸
英语
*/
```

另外获取目录内容还有其他的类似方法，这里不一一介绍

# 22_38File对象常见功能_过滤器

```java
import java.io.File;
import java.io.FilenameFilter;

class FilterByTxt implements FilenameFilter{
    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(".txt");
    }
}

class Demo22_38 {
    public static void main(String[] args){

        File f = new File("f:\\");

        String[] names = f.list(new FilterByTxt());

        for(String name:names){
            System.out.println(name);
        }
    }
}
/*
abc.txt
b.txt
*/
```

# 23

# 23_39深度遍历文件夹

备注:该题目与老师的题目有出入，但和老师的本质相同，比老师的稍难一点

题目:对指定目录进行指定后缀文件的查找(包括指定目录的所有子目录，可以以.txt文件为例)

### 广度遍历方式

以按层遍历二叉树的思路很容易写出本题代码，即建立一个辅助队列用来存储文件夹，不断对队列中的文件夹进行指定后缀文件的搜索，搜索到文件夹就添加到文件夹队列中，搜索到文件就输出(或者添加到一个容器中，最后输出等)，直到文件夹队列为空停止操作，只不过这种遍历为广度遍历

```java
import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

class Demo23_39 {
    public static void main(String[] args){
        ArrayList<File> alDirs = new ArrayList<File>();
        ArrayList<File> alFiles = new ArrayList<File>();

        File root = new File("f:\\testDir");
        alDirs.add(root);
        while(!alDirs.isEmpty()){
            File temp = alDirs.remove(0);
            File[] dirs = temp.listFiles(new FileFilter(){
            
                @Override
                public boolean accept(File pathname) {
                    return pathname.isDirectory();
                }
            });
            if(dirs!=null)
                alDirs.addAll(Arrays.asList(dirs));
            File[] files = temp.listFiles(new FileFilter(){
            
                @Override
                public boolean accept(File pathname) {
                    return pathname.isFile();
                }
            });
            if(files!=null)
                alFiles.addAll(Arrays.asList(files));
        }
        Iterator<File> it = alFiles.iterator();
        while(it.hasNext()){
            System.out.println(it.next());
        }
    }
}
/*
f:\testDir\1_a.txt
f:\testDir\1_b.txt
f:\testDir\1\2_a.txt
f:\testDir\1\2_b.txt
f:\testDir\1\2_c.txt
f:\testDir\1\2_2\3_1\4_a.txt
*/
```

### 深度遍历方式

```java
import java.io.File;

class Demo23_39_2 {
    public static void main(String[] args) {
        File dirs = new File("f:\\testDir");
        filterFiles(dirs);
    }

    private static void filterFiles(File dirs) {
        File[] files = dirs.listFiles();
        for(int i=0;i<files.length;i++){
            File temp = files[i];
            if(temp.isDirectory())
                filterFiles(temp);
            else if(temp.getName().endsWith(".txt"))
                System.out.println(temp);
        }
    }
}
/*
f:\testDir\1\2_2\3_1\4_a.txt
f:\testDir\1\2_a.txt
f:\testDir\1\2_b.txt
f:\testDir\1\2_c.txt
f:\testDir\1_a.txt
f:\testDir\1_b.txt
*/
```

# 23_41删除一个带内容的目录

```java
import java.io.File;

class Demo23_41 {
    public static void main(String[] args){
        File dir = new File("f:\\testDir");
        deleteFiles(dir);
    }
    private static void deleteFiles(File dir) {
        File[] files = dir.listFiles();
        for(int i=0;i<files.length;i++){
            File temp = files[i];
            if(temp.isFile()){
                temp.delete();
                System.out.println(temp);
            }
            if(temp.isDirectory())
            deleteFiles(temp);
            if(temp.length()==0)
                temp.delete();
        }
    }
}
/*
f:\testDir\1\2_2\3\4_a.txt
f:\testDir\1\2_a.txt
f:\testDir\1\2_b.txt
f:\testDir\1\2_c.txt
f:\testDir\1_a.txt
f:\testDir\1_b.txt
*/
```

需要注意的是，虽然删除了temp但是temp仍然存在，可以控制台输出，在length==0语句中这些temp又执行了一次delete

老师的做法:

老师的编程手法就比较高明了，我们的做法在删除了文件后又想办法删除该级已经空了的文件夹，老师直接递归删除所有文件，先不管文件夹，最后最上层的文件夹包含了很多空的文件夹，直接删除最上层的文件夹就可以了

```java
import java.io.File;

class Demo23_41_2 {
    public static void main(String[] args){
        File dir = new File("F:\\testDir");
        removeDir(dir);
    }

    private static void removeDir(File dir) {
        File[] files = dir.listFiles();
        for(File file:files){
            if(file.isDirectory())
                removeDir(file);
            else
                file.delete();
        }
        dir.delete();
    }
}
```

# 23_42Properties集合的基本功能

    Map
        |--HashTable
            |--Properties
    
特点:

    1.该集合中的键和值都是字符串类型
    2.该集合中的数据可以保存到流中或者从流中获取

该集合经常用于操作以键值对形式存储的配置信息

```java
import java.util.Properties;
import java.util.Set;

class Demo23_42 {
    public static void main(String[] args){
        Properties prop = new Properties();

        prop.setProperty("zhangsan", "21");
        prop.setProperty("lisi", "22");
        prop.setProperty("wangwu", "25");
        prop.setProperty("zhaoliu", "36");

        Set<String> names = prop.stringPropertyNames();

        //修改
        prop.setProperty("zhaoliu", "0");

        for(String name:names){
            String age = prop.getProperty(name);
            System.out.println(name+"......"+age);
        }

    }
}
/*
zhangsan......21
lisi......22
wangwu......25
zhaoliu......0
*/
```

# 23_43Properties的list方法

该方法的输入参数是PrintStream对象，一般调试的时候使用

```java
import java.util.Properties;
import java.util.Set;

class Demo23_43 {
    public static void main(String[] args){
        Properties prop = new Properties();

        prop.setProperty("zhangsan", "21");
        prop.setProperty("lisi", "22");
        prop.setProperty("wangwu", "25");
        prop.setProperty("zhaoliu", "36");

        //System.out就是PrintStream的类型
        prop.list(System.out);

    }
}
/*
-- listing properties --
zhangsan=21
lisi=22
wangwu=25
zhaoliu=36
*/
```

```java
import java.util.Properties;

class Demo23_43_2 {
    public static void main(String[] args){
        Properties prop = (System.getProperties());

        prop.list(System.out);
    }
}
/*
-- listing properties --
java.runtime.name=Java(TM) SE Runtime Environment
sun.boot.library.path=C:\Program Files\Java\bin
java.vm.version=25.201-b09
java.vm.vendor=Oracle Corporation
java.vendor.url=http://java.oracle.com/
path.separator=;
java.vm.name=Java HotSpot(TM) 64-Bit Server VM
file.encoding.pkg=sun.io
user.script=
user.country=CN
sun.java.launcher=SUN_STANDARD
sun.os.patch.level=
java.vm.specification.name=Java Virtual Machine Specification
user.dir=F:\doctor\JiuXieXiangGuan\XiuLian\GEE...
java.runtime.version=1.8.0_201-b09
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.endorsed.dirs=C:\Program Files\Java\lib\endorsed
os.arch=amd64
java.io.tmpdir=C:\Users\Ivan\AppData\Local\Temp\
line.separator=

java.vm.specification.vendor=Oracle Corporation
user.variant=
os.name=Windows 10
sun.jnu.encoding=GBK
java.library.path=C:\Program Files (x86)\Common Files\O...
java.specification.name=Java Platform API Specification
java.class.version=52.0
sun.management.compiler=HotSpot 64-Bit Tiered Compilers
os.version=10.0
user.home=C:\Users\Ivan
user.timezone=
java.awt.printerjob=sun.awt.windows.WPrinterJob
file.encoding=GBK
java.specification.version=1.8
user.name=Ivan
java.class.path=.
java.vm.specification.version=1.8
sun.arch.data.model=64
java.home=C:\Program Files\Java
sun.java.command=Demo23_43_2
java.specification.vendor=Oracle Corporation
user.language=zh
awt.toolkit=sun.awt.windows.WToolkit
java.vm.info=mixed mode
java.version=1.8.0_201
java.ext.dirs=C:\Program Files\Java\lib\ext;C:\WIND...
sun.boot.class.path=C:\Program Files\Java\lib\resources.j...
sun.stderr.encoding=ms936
java.vendor=Oracle Corporation
file.separator=\
java.vendor.url.bug=http://bugreport.sun.com/bugreport/
sun.cpu.endian=little
sun.io.unicode.encoding=UnicodeLittle
sun.stdout.encoding=ms936
sun.desktop=windows
sun.cpu.isalist=amd64
*/
```

# 23_44Properties的store方法

```java
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;

class Demo23_44 {
    public static void main(String[] args) throws IOException {
        Properties prop = new Properties();

        prop.setProperty("zhangsan", "23");
        prop.setProperty("lisi", "24");
        prop.setProperty("wangwu", "35");
        prop.setProperty("zhaoliu", "46");

        FileOutputStream fos = new FileOutputStream("f:\\info.txt");
        prop.store(fos,"info");
        fos.close();
    }
}
```

![Demo23_44](https://github.com/geekavan/BiXiangdong/blob/master/Demo23_44.png)


# 23_45Properties修改配置信息

利用Properties容器读取配置信息，该容器可以读取流中的数据，当然该流必须是以键值对方式存储的，方法为load

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Properties;

class Demo23_45 {
    public static void main(String[] args) throws IOException {
        Properties prop = new Properties();
        File file = new File("f:\\info.txt");
        FileInputStream fis = new FileInputStream(file);       
        prop.load(fis);
        prop.list(System.out);
    }
}
/*
-- listing properties --
zhangsan=23
lisi=24
zhaoliu=46
wangwu=35
*/
```

Properties容器的load方法很好实现，下面我们自己实现一下，下面演示的是用字符流方式

```java
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

class Demo23_45_2 {
    public static void main(String[] args) throws IOException {
        myLoad();
    }

    public static void myLoad() throws IOException {
        Properties prop = new Properties();
        BufferedReader bufr =  new BufferedReader(new FileReader("f:\\info.txt"));

        String line = null;
        while((line=bufr.readLine())!=null){
            if(line.startsWith("#"))
                continue;
            String[] temp = line.split("=");
            prop.setProperty(temp[0], temp[1]);
        }
        prop.list(System.out);
    }
}
/*
-- listing properties --
zhangsan=23
lisi=24
zhaoliu=46
wangwu=35
*/
```

下面一段程序使用的是字节流方式，使用转换流将字节流转换为字符流，从而使用字符流的readLine方式

```java
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Properties;

class Demo23_45_3 {
    public static void main(String[] args) throws IOException {
        myLoad();
    }

    public static void myLoad() throws IOException {
        Properties prop = new Properties();
        FileInputStream fis = new FileInputStream("f:\\info.txt");
        InputStreamReader isr = new InputStreamReader(fis);
        BufferedReader bufr =  new BufferedReader(isr);

        
        String line = null;
        while((line=bufr.readLine())!=null){
            if(line.startsWith("#"))
                continue;
            String[] temp = line.split("=");
            prop.setProperty(temp[0], temp[1]);
        }
        prop.list(System.out);
    }
}
/*
-- listing properties --
zhangsan=23
lisi=24
zhaoliu=46
wangwu=35
*/
```

修改配置信息，思路为先利用输入流，将配置文件的键值对信息导入到Properties容器中，更改要更改的配置信息，在利用输出流将配置信息导入到同一个配置文件中

```java
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

class Demo23_45_4 {
    public static void main(String[] args) throws IOException {
        File file = new File("f:\\info.txt");
        if(!file.exists()){
            //因为如果文件不存在的话，FileReader就会抛出异常，为了防止其抛出文件未发现异常，我们这里加入了判断机制，如果文件不存在我们就建立一个
            file.createNewFile();
        }
        Properties prop = new Properties();
        FileReader fr = new FileReader(file);
        prop.load(fr);
        prop.setProperty("zhangsan", "98");
        FileWriter fw = new FileWriter("f:\\info.txt");
        prop.store(fw,"");
        fw.close();
        fr.close();
    }
}
```

![Demo23_45_4](https://github.com/geekavan/BiXiangdong/blob/master/Demo23_45_4.png)

这里需要注意FileReader是与已经存在的文件相关联，如果文件不存在会抛出文件未发现异常，而FileWriter不同，如果文件存在与文件关联，flush，close时候会覆盖原文件，如果文件不存在则会创建新文件

# 23_48打印流PrintStream

IO包中的其他类

    打印流
    PrintStream类和PrintWriter类
    可以直接操作输入流和文件

```java
import java.io.IOException;
import java.io.PrintStream;

class Demo23_48 {
    public static void main(String[] args) throws IOException {
        PrintStream pw = new PrintStream("f:\\test.txt");
        pw.write(609);
        pw.write(97);
        pw.print(97);
    }
}
```

pw.write(609)与pw.write(97)执行之后都会在f:\\test.txt文件中写入字母a，因为PrintStream类的write方法只会保存一个字节，也就是8位二进制，97与609的后八位二进制相同所以两者相同，记事本一解析两者都为字母a

PrintStream类中的print会保留原数据形式，会将97原原本本地打印在控制台上，因为实质上它写入的是String类型

# 23_49打印流PrintWriter

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

class Demo23_49 {
    public static void main(String[] args) throws IOException {
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));

        PrintWriter pw = new PrintWriter(System.out);

        String line = null;

        while((line=bufr.readLine())!=null){
            if("over".equals(line))
                break;
            pw.println(line.toUpperCase());
            pw.flush();
        }

        pw.close();
        bufr.close();
    }
}
/*
xixi
XIXI
hhe
HHE
over
*/
```

# 23_50序列流SequenceInputStream

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.Enumeration;
import java.util.Vector;

class Demo23_50 {
    public static void main(String[] args) throws IOException {

        Vector<FileInputStream> v = new Vector<FileInputStream>();
        v.add(new FileInputStream("f:\\1.txt"));
        v.add(new FileInputStream("f:\\2.txt"));
        v.add(new FileInputStream("f:\\3.txt"));

        Enumeration<FileInputStream> en = v.elements();
        SequenceInputStream sis = new SequenceInputStream(en);

        FileOutputStream fos = new FileOutputStream("f:\\4.txt");

        byte[] buf = new byte[1024];

        int len = 0;

        while((len = sis.read(buf))!=-1){
            fos.write(buf, 0, len);
        }

        fos.close();
        sis.close();
    }
}
```

该程序将原本三个输入流才能关联的三个文件使用一个序列流就关联了，SequenceInputStream序列流将输入流串联了起来

SequenceInputStream的构造函数如果输入两个以上的输入流，那么必须使用枚举接口，这使得我们使用了Vector容器，但是Vector容器是不够高效的，我们想用其他的容器，比如ArrayList容器，这就需要我们自己实现Enumeration接口

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;

class Demo23_50_2 {
    public static void main(String[] args) throws IOException {

        ArrayList<FileInputStream> v = new ArrayList<FileInputStream>();
        v.add(new FileInputStream("f:\\1.txt"));
        v.add(new FileInputStream("f:\\2.txt"));
        v.add(new FileInputStream("f:\\3.txt"));
        final Iterator<FileInputStream> it = v.iterator();

        Enumeration<FileInputStream> en = new Enumeration<FileInputStream>() {

            @Override
            public boolean hasMoreElements() {
                return it.hasNext();
            }

            @Override
            public FileInputStream nextElement() {
                return it.next();
            }
        };
        SequenceInputStream sis = new SequenceInputStream(en);

        FileOutputStream fos = new FileOutputStream("f:\\4.txt");

        byte[] buf = new byte[1024];

        int len = 0;

        while((len = sis.read(buf))!=-1){
            fos.write(buf, 0, len);
        }

        fos.close();
        sis.close();
    }
}
```

另一种方式为利用工具类Collections，获取ArrayList的枚举

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.Iterator;

class Demo23_50_3 {
    public static void main(String[] args) throws IOException {

        ArrayList<FileInputStream> v = new ArrayList<FileInputStream>();
        v.add(new FileInputStream("f:\\1.txt"));
        v.add(new FileInputStream("f:\\2.txt"));
        v.add(new FileInputStream("f:\\3.txt"));
        
        Enumeration<FileInputStream> en = Collections.enumeration(v);
        SequenceInputStream sis = new SequenceInputStream(en);

        FileOutputStream fos = new FileOutputStream("f:\\4.txt");

        byte[] buf = new byte[1024];

        int len = 0;

        while((len = sis.read(buf))!=-1){
            fos.write(buf, 0, len);
        }

        fos.close();
        sis.close();
    }
}
```

# 24

# 24_52文件切割

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

class Demo23_52 {
    private static final int SIZE = 51200;//1024*50*1字节=50k

    public static void main(String[] args) throws IOException {
        File file = new File("F:\\0.jpg");
        splitFile(file);
    }
    public static void splitFile(File file) throws IOException{
        FileInputStream fis = new FileInputStream(file);
        File dir = new File("f:\\");
        int count = 1;        
        FileOutputStream fos = null;

        byte[] buff = new byte[SIZE];

        int len  = 0;
        while((len=fis.read(buff))!=-1){
            fos = new FileOutputStream(new File(dir,(count++)+".haha"));
            fos.write(buff,0,len);
        }
        fos.close();
        fis.close();
    }
}
```

1.该程序将一个133k的0.jpg图片分割为1.haha大小为50k，2.haha大小为50k，3.haha大小为33k

2.分割之后的文件后缀名是自定义的，随便都是可以的，反正都是用自己设计的软件来解析，所以任意的后缀名称都是可以接受的，不要后缀也是可以的，但是最好还是添加后缀，用于查找文件等来使用

3.博主自己进行了小的实验发现，若将1.haha，2.haha，3.haha的后缀名称均改为.jpg后，即将三者分别改为1.jpg，2.jpg，3.jpg，再打开，发现只有1.jpg可以正常打开，但是图片显示不全，博主猜测就像JVM中magic number一样，.jpg格式存在识别码，同样在文件开头存在，分割后，第一个图片文件的开头依然存在，图片查看软件可以正常识别打开，但是另外的几个分割文件的开头就已经没有magic number了所以软件识别不了也不能够正常打开

# 24_53文件合并

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;

class Demo23_53 {
    public static void main(String[] args) throws IOException {
        File dir = new File("f:\\");
        mergeFile(dir);
    }

    private static void mergeFile(File dir) throws IOException {
        ArrayList<FileInputStream> files = new ArrayList<FileInputStream>();
        for(int i = 0;i<3;i++){
            files.add(new FileInputStream(new File(dir, (++i)+".haha")));
        }
        SequenceInputStream sis = new SequenceInputStream(Collections.enumeration(files));
        FileOutputStream fos = new FileOutputStream("F:\\mergeFile.jpg");

        byte[] buff = new byte[1024];
        
        int len = 0;
        while((len=sis.read(buff))!=-1){
            fos.write(buff,0,len);
        }
        fos.close();
        sis.close();  
    }
}
```

1.博主和老师一样用的是自定义的缓冲区读取的数据，这里再提一下，从硬盘读数据的过程就像吃馒头，缓冲区就像一个盘子，以前是在屋子里吃完一个馒头再去厨房拿一个馒头，有了缓冲区就是将厨房也就是硬盘中的数据装入盘子(缓冲区)中，再拿进屋子里边吃，这样子吃馒头就方便多了

# 24_54文件切割合并_配置文件

需求:切割文件并保存切割的文件名称，切割成的文件个数等信息到配置文件中，读取配置文件并合并文件

思路:

1.创建一个类，里面提供切割与合并文件的方法

2.方法参数列表应该输入哪些信息呢？要处理的文件具体位置名称，最后合并的文件的位置，分割的文件的大小

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Properties;

class Demo24_54 {
    public static void main(String[] args) throws IOException {
        File file = new File("f:\\0.jpg");
        File desDir = new File("f:\\test");
        int size = 40;
        SplitAndMerge.merge(new File("f:\\test\\"));
    }
}

class SplitAndMerge {
    public static void split(File file, File desDir, int size) throws IOException {
        if (!desDir.exists()) {
            desDir.mkdirs();
        }
        FileInputStream fis = new FileInputStream(file);
        FileOutputStream fos = null;
        byte[] buff = new byte[1024 * size];
        int len = 0;
        int count = 1;
        while ((len = fis.read(buff)) != -1) {
            fos = new FileOutputStream(new File(desDir, (count++) + ".part"));
            fos.write(buff, 0, len);
            fos.close();
        }
        Properties prop = new Properties();
        prop.setProperty("count", count + "");
        prop.setProperty("filename", file.getName());
        fos = new FileOutputStream(new File(desDir, count + ".properties"));
        prop.store(fos, "");
        fos.close();
        fis.close();
    }

    public static void merge(File propDir) throws IOException {
        /**
         * 1.方法输入为File类型参数
         * 2.方法输入为配置文件所在的父目录
         * 3.利用File类的listFiles方法过滤所有文件，选出配置文件列表，判断是否唯一
        */
        File[] propFiles = propDir.listFiles(new FilenameFilterByProp());
        if(propFiles.length!=1){
            throw new RuntimeException("配置文件不存在或不唯一！");
        }
        /**
         * 1.创建Properties容器用于接收配置文件内的信息
         * 2.只要和文件打交道，不妨就将文件封装成为File对象，这里已经是File对象了(propFiles[0])
         * 3.硬盘文件向内存输入信息必然要用到输入流
         * 4.由于是配置文件，所以用Properties容器直接载入或者说读取输入流中的信息
        */
        Properties prop = new Properties();
        FileInputStream fis = new FileInputStream(propFiles[0]);
        prop.load(fis);
        int count = Integer.parseInt(prop.getProperty("count"));
        String filename = prop.getProperty("filename");
        /**
         * 1.将碎片文件用FileInputStream流分别关联起来，当然涉及到文件可以先将文件封装成为File对象，之后再用输入流与之对应关联起来
         * 2.利用ArrayList容器将各个输入流存储起来
        */
        ArrayList<FileInputStream> al = new ArrayList<FileInputStream>();
        for(int i=1;i<count;i++){
            al.add(new FileInputStream(new File(propDir, i+".part")));
        }
        /**
         * 1.利用SequenceInputStream序列流将各个流连接起来
        */
        SequenceInputStream sis = new SequenceInputStream(Collections.enumeration(al));
        //之后为简单的读写过程
        FileOutputStream fos = new FileOutputStream(new File(propDir, filename));
        byte[] buff = new byte[1024];
        int len = 0;
        while((len=sis.read(buff))!=-1){
            fos.write(buff, 0, len);
        }
        fos.close();
        sis.close();
    }
}

class FilenameFilterByProp implements FilenameFilter{
    String suffix = ".properties";
    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(suffix);
    }

}
```

# 24_55ObjectOutputStream对象的序列化

我们现在学习了如何存储数据，但是Java是面向对象的语言，我们时刻都在和对象打交道，如何将对象存储到硬盘上呢？这就需要用到ObjectOutputStream类，这个类是添加辅助功能用的就像BufferedOutputStream一样，两者的用法也是类似的

```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class Demo24_55 {
    public static void main(String[] args) throws IOException{
        writeObj();
    }

    public static void writeObj() throws IOException {
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("f:\\obj.txt")));
        oos.writeObject(new Person("xiaoqiang",13));
        oos.close();
    }
}

class Person implements Serializable{
    private String name;
    private int age;
    Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    public String getName(){
        return this.name;
    }
    public int getAge(){
        return this.age;
    }
}
```

1.ObjectOutputStream类可以将堆内存上的对象保存到硬盘文件中，是用于存储对象的，用于对象序列化的，但是序列化的类必须继承Serializable接口，该接口没有方法需要实现，是一个标识性接口

2.所谓对象序列化，就是对象的排序的意思

3.存储对象是将对象的一些信息存储到硬盘上，包括类名，类中的方法等，我们存储之后的文件后缀为.txt这使得该文件可以以记事本的码表打开，但是打开之后肯定就会存在乱码，所以并没有必要将其后缀名称写为.txt，它又不是纯文本文件，一般地我们的后缀名称写为.object

# 24_56对象的反序列化

ObjectOutputStream与ObjectInputStream是一对对象序列化类

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;

class Demo24_56 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        ObjectInputStream oos = new ObjectInputStream(new FileInputStream(new File("f:\\obj.txt")));
        Person p =(Person)oos.readObject();
        String name = p.getName();
        int age = p.getAge();
        System.out.println(name+"......"+age);
        oos.close();
    }
}
class Person implements Serializable{
    private String name;
    private int age;
    Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    public String getName(){
        return this.name;
    }
    public int getAge(){
        return this.age;
    }
}
```

# 24_57序列化接口Serializable

将程序24_56即上一个程序中Person类里边的类成员name的权限从private改为public有

Exception in thread "main" java.io.InvalidClassException: Person; local class incompatible: stream classdesc serialVersionUID = -3366449691062570620, local class serialVersionUID = -3858351854550583623

1.出现了错误，其实当一个类继承Serializable接口之后，JVM会为该类计算一个ID号，从上述错误中我们知道，f:\\obj.txt中记录的Person类的序列化ID号码为stream classdesc serialVersionUID = -3366449691062570620，而本地的改完的Person类的序列化ID号码为local class serialVersionUID = -3858351854550583623，两者不匹配所以程序报错

2.官方建议自定义一个类的序列号，因为类的序列号的默认计算很敏感，与JVM的版本号等相关，容易造成序列化时和反序列化是同一个类，但是不识别的情况

3.定义的格式为:

    ANY-ACCESS-MODIFIER static final long serialVersionUID

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;

class Demo24_57 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        ObjectInputStream oos = new ObjectInputStream(new FileInputStream(new File("f:\\obj.txt")));
        Person p =(Person)oos.readObject();
        String name = p.getName();
        int age = p.getAge();
        System.out.println(name+"......"+age);
        oos.close();
    }
}
class Person implements Serializable{
    public static final long serialVersionUID = 41l;
    public String name;
    private int age;
    Person(String name,int age){
        this.name = name;
        this.age = age;
    }
    public String getName(){
        return this.name;
    }
    public int getAge(){
        return this.age;
    }
}
```

# 24_58transient关键字

1.由于对象序列化是记录了堆内存中的数据，所以如果一个数据是静态的也就是在方法区中是不会被序列化的，如Person类中age被定义为静态成员变量，那么在反序列化读取它的数值的时候它的数值就会是int类型成员变量的初始化值为0

2.如果一个成员变量不是对象共有数据，即不是静态成员变量但是也不想让它序列化，我们就可以用transient关键字来修饰，被它修饰的成员变量为瞬态数据不能够被序列化

# 24_59RandomAccessFile写入

特点:

1.该对象可读可写

2.该对象内部维护了一个byte类型的数组，可以操作其元素

3.可以通过getFilePointer获取指针位置，并通过seek设置指针位置

4.其实该指针就是内部同时包含了字节数输入和输出流

5.该对象的源或目的只能是File对象，这一点从构造函数就可以看出

```java
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

class Demo24_59 {
    public static void main(String[] args) throws IOException {
        RandomAccessFile rsf = new RandomAccessFile(new File("f:\\random.txt"), "rw");
        rsf.write("zhangsan".getBytes());
        rsf.write(97);
        rsf.write(609);
        rsf.writeInt(609);
        rsf.close();
    }
}
```

![Demo24_59](https://github.com/geekavan/BiXiangdong/blob/master/Demo24_59.png)

# 24_60_61RandomAccessFile读取与随机读取_细节

```java
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

class Demo24_60 {
    public static void main(String[] args) throws IOException {
        File desFile = new File("f:\\random.txt");
        if(desFile.exists()){
            desFile.delete();
        }
        RandomAccessFile raf = new RandomAccessFile(desFile, "rw");
        raf.write("张三".getBytes());
        raf.write(97);
        raf.writeInt(97);
        
        RandomAccessFile rafr = new RandomAccessFile(desFile, "r");
        byte[] buff = new byte[2];
        // byte[] buff = new byte[4];//张三
        // byte[] buff = new byte[5];//张三a
        // byte[] buff = new byte[6];//张三a
        // byte[] buff = new byte[8];//张三a
        // byte[] buff = new byte[9];//张三a   a中间有三个空格字符
        rafr.read(buff);
        String s = new String(buff);
        System.out.println(s);
    }
}
/*
张
*/
```

我们通过seek可以设置指针的位置，也就可以设置读或写的开始位置，这里仅以写举例

```java
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

class Demo24_60 {
    public static void main(String[] args) throws IOException {
        File desFile = new File("f:\\random.txt");
        if(desFile.exists()){
            desFile.delete();
        }
        RandomAccessFile raf = new RandomAccessFile(desFile, "rw");
        raf.write("张三".getBytes());
        raf.write(97);
        raf.writeInt(97);
        
        RandomAccessFile rafr = new RandomAccessFile(desFile, "r");
        rafr.seek(5);
        byte[] buff = new byte[4];
        rafr.read(buff);
        String s = new String(buff);
        System.out.println(s);
    }
}
/*
   a
*/
```

1.我们可以通过设置指针位置来设置读或写的开始位置

2.我们可以利用RandomAccessFile的可以设置读写开始位置的特点进行多线程的读写操作

# 24_62管道流PipedStream

我们之前学习的输入输出流都不是直接连接在一起的，需要一个中转站，管道流中输入与输出可以直接连接在一起

```java
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

class Demo24_62 {
    public static void main(String[] args) throws IOException {
        PipedInputStream in = new PipedInputStream();
        PipedOutputStream out = new PipedOutputStream();
        in.connect(out);
        new Thread(new Input(in)).start();
        new Thread(new Output(out)).start();
    }
}

class Input implements Runnable {

    private PipedInputStream in;

    Input(PipedInputStream in) {
        this.in = in;
    }

    @Override
    public void run() {
        byte[] buff = new byte[1024];
        try {
            int len = in.read(buff);
            String s = new String(buff, 0, len);
            System.out.println(s);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
class Output implements Runnable{
    private PipedOutputStream out;
    Output(PipedOutputStream out){
        this.out = out;
    }
    public void run(){
        try {
            Thread.sleep(5000);
            out.write("zhangsan".getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        } 
    }
}
/*
zhangsan
*/
```

# 24_63操作基本数据类型的流对象DataInputStream

操作基本数据类型时候使用

```java
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

class Demo24_63 {
    public static void main(String[] args) throws IOException {
        DataOutputStream dos = new DataOutputStream(new FileOutputStream("f:\\test.txt"));
        dos.writeUTF("张三");
        dos.close();

        DataInputStream dis = new DataInputStream(new FileInputStream("f:\\test.txt"));
        String s = dis.readUTF();
        System.out.println(s);
    }
}
```

# 24_64操作数组的流

```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;

class Demo24_64 {
    public static void main(String[] args) throws IOException {
        ByteArrayInputStream bais = new ByteArrayInputStream("abcde".getBytes());
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buff = new byte[1024];
        int len = bais.read(buff);
        baos.write(buff, 0, len);
        System.out.println(baos.toString());
    }
}
/*
abcde
*/
```

1.输入输出都是在内存中，没有与硬盘数据相关联

2.由于没有和底层数据打交道，所以close方法无效

3.相当于byte类型数组的读写的另一种体现

4.类似的类还有CharArrayInputStream与CharArrayOutputStream，StringReader与StringWriter

# 24_65编码表

ASCII美国标准信息交换码，用一个字节的7位表示一个字符

ISO8859-1拉丁码表，欧洲码表，用一个字节表示一个字符

GB2312中国的中文码表

GBK中国的中文码表的扩充版

Unicode码表国际标准码表，融合了多种文字，用两个字节表示一个字符

UTF-8最多用三个字节来表示一个字符

# 24_66_67_68简单的编码解码及问题

简单的编码解码演示程序如下

```java
import java.io.UnsupportedEncodingException;

class Demo24_66 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        //编码过程
        byte[] buf = "你好".getBytes("gbk");

        //解码过程
        String s = new String(buf,"gbk");
        System.out.println(s);
    }
}
```

注意的问题:

编码编错了肯定就解不出来了，但是解码解错了，还有可能解的出来

可以解的出来的例子:

```java
import java.io.UnsupportedEncodingException;

class Demo24_66_2 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        //编码过程
        byte[] buf = "你好".getBytes("gbk");

        //解码解错了
        String s = new String(buf,"iso8859-1");
        System.out.println(s);

        //重新解
        byte[] bu = s.getBytes("iso8859-1");
        String ss = new String(bu,"gbk");
        System.out.println(ss);
    }
}
/*
????
你好
*/
```

解不出来的例子:

```java
import java.io.UnsupportedEncodingException;

class Demo24_66_3 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        //编码过程
        byte[] buf = "你好".getBytes("gbk");

        //解码解错了
        String s = new String(buf,"utf-8");
        System.out.println(s);

        //重新解
        byte[] bu = s.getBytes("utf-8");
        String ss = new String(bu,"gbk");
        System.out.println(ss);
    }
}
/*
???
锟斤拷锟?
*/
```

解出来和解不出来都很好理解，编码表就是一个将人类看得懂的字符和底层的字节联系起来的工具，字符看为变量x，那么字节可以看为因变量y，编码表为对应关系f(x)，如果在一个映射关系f(x)下的x被映射为y，而y在另一个映射关系g(x)下被映射为z如果z可以被g'(x)再次映射为y那么就可以解的出来，不然就不可以

# 25

# 26

# 26_01网络模型概述

    OSI参考模型:                TCP/IP模型:
        应用层
        表达层                      应用层
        会话层
        传输层                      传输层
        网络层                      网际层
        数据链路层                  主机至网络层
        物理层

1.OSI的全称为Open System Interconnection为开放系统交互的意思

2.在数据链路层:在此层进行MAC地址的封装与解封装，MAC是网卡出厂就带有的唯一识别码，交换机就工作在这个层面

3.网络层:在此层进行IP地址的封装与解封装，路由器就工作在这个层面

4.传输层:定义了一些网络传输协议与端口号，如TCP协议，TCP协议传输效率低，可靠性强，用于传输可要性要求高，数据量大的数据，UDP协议恰恰相反，用于传输可要性要求低，数据量较小的数据，QQ的聊天数据就是通过这种协议传输的

5.会话层:和谁会话啊

6.表达层:传输的数据是什么类型啊？图片，媒体文件等

7.应用层:各个APP

# 26_02网络要素_IP地址

在网络中我们要想和其他连接网络的设备通信，需要具备IP地址，端口号，传输协议三个条件

    IP地址:
        网络中设备的标识符
        本机回环IP地址127.0.0.1，主机名:localhost

我们ping 127.0.0.1一定是通的，不然就是你的电脑网卡坏掉了

# 26_03网络要素_端口

我用QQ发给你一段数据，你的网络设备的IP地址为192.168.1.1，那么这段数据发给你之后该怎么解析呢？肯定还是使用QQ来解析，那么怎么才能让你的设备使用QQ来解析我发过来的数据呢？你的网络设备上有很多个软件程序，为了正确地让接收者使用发送者发送信息所用的软件，我们为每一个软件设置了一个识别号码，这就是端口号(老师是这样说的，我觉得倒不如将这段话中的"软件"改为"进程"或者"聊天进程"更为合理)

下面是360安全卫士中流量监控中网络连接的内容，从中我们可以看到QQ这个应用程序占用了很多个端口号，这也是我说将上段话中的"软件"改为"进程"或者"聊天进程"的原因，一个软件可以有很多个进程，每一个进程就占用了一个端口号

![26_03](https://github.com/geekavan/BiXiangdong/blob/master/26_03.png)

注意:

1.有效端口为0-65535，0-1024为系统使用或保留端口

# 26_04网络要素_传输协议

UDP用户数据报协议(UDP，User Datagram Protocol)

特点:

1.将数据及源和目的封装在数据报中，不用建立连接通道

2.数据报的大小有限制，在64k以内，数据的大小若大于64k则分为多个数据包发送

3.因无连接，是不可靠协议

4.因不需要建立连接速度快

生活中类似的例子:对讲机，我们玩密室逃脱的时候经常会遇到对讲机，比如你在3频道，有的时候你不小心调节到了其他频道，店家并不知情，但还是给你发消息，这就是事先不建立连接的UDP传输方式，不论连接线路通不通直接就发送消息了

TCP传输控制协议(Transmission Control Protocol)

特点:

1.建立连接，形成数据连接的通道

2.在连接中进行大量的数据传输

3.通过三次握手完成连接，是可靠协议

4.必须建立连接，速度会降低

生活中的例子:手机来电，你接了电话才能够通话

两个传输协议并无高低之分，各有特点，要根据实际情况选择传输协议

# 26_05IP对象InetAddress

Java将IP封装成了一个对象，IP工作在网际层

示例程序1

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

class Demo26_05 {
    public static void main(String[] args) throws UnknownHostException {
        InetAddress ip = InetAddress.getLocalHost();
        System.out.println(ip.getHostAddress());
        System.out.println(ip.getHostName());
    }
}
/*
192.168.1.106
DESKTOP-312EHQ8
*/
```

示例程序2

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

class Demo26_05_02 {
    public static void main(String[] args) throws UnknownHostException {
        // InetAddress ip = InetAddress.getByName("192.168.1.106");
        InetAddress ip = InetAddress.getByName("DESKTOP-312EHQ8");
        System.out.println(ip.getHostAddress());
        System.out.println(ip.getHostName());
    }
}
/*
192.168.1.106
DESKTOP-312EHQ8
*/
```

示例程序3

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

class Demo26_05_02 {
    public static void main(String[] args) throws UnknownHostException {
        // InetAddress ip = InetAddress.getByName("www.mzitu.com");
        InetAddress ip = InetAddress.getByName("www.baidu.com");
        System.out.println(ip.getHostAddress());
        System.out.println(ip.getHostName());
    }
}
/*
111.206.223.173
www.baidu.com
*/
```

# 26_06域名解析

1.在网络中一台设备寻找另一台设备依靠的是IP地址，但是IP地址太麻烦不便于记忆，于是便有了域名，它是IP地址的另一个便于记忆的名字，比如百度服务器的IP地址为111.206.223.173但是不便于记忆，便给它起了一个便于记忆的名字为www.baidu.com

2.但是当我们在搜寻这个地址的时候，我们最终还是要根据IP地址来找，这就需要在一个地方存储域名与IP地址之间的对应表，这个东西在本机内有一个，位置在C:\Windows\System32\drivers\etc\hosts文件中，另外一个在互联网中，被称为DNS服务器

3.本机在通过域名访问网络上一个位置的时候，本机会先查看本机的hosts文件中可不可以解析该域名，在不可以解析的情况下才通过网络上的DNS服务器来解析

4.该原理可以用来屏蔽恶意弹出网站，记录经常恶意弹出的网站的域名，并在本机的hosts文件中改写该域名对应的IP地址，弹出窗口就会找不到所要显示的网页，从而达到屏蔽恶意网页的目的

5.机器都有默认的DNS服务器地址，这是由宽带服务商给你设置的，如果联通移动允许的话，你购买了联通的宽带也可以挂移动的DNS服务器

# 26_07UDP协议_发送端

Socket:

1.Socket是套接字

2.Scoket为网络服务提供的一种机制

3.通信两端都有Socket

4.网络通信就是Socket之间的通信

5.数据在两个Socket之间通过IO进行传输

Socket就是港口

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

class Demo26_07 {
    public static void main(String[] args) throws IOException {
        /**
         * 1.建立Socket对象
         * 2.建立数据报包对象
         * 3.将要发送的数据装入数据报包中，还包括目的地址，端口号等
         * 4.通过Socket发送
         * 5.关闭资源
         */

        System.out.println("发送端开启......");

         //1.建立Socket对象
        DatagramSocket ds = new DatagramSocket();

        //2.建立数据报包对象
        //3.将要发送的数据装入数据报包中，还包括目的地址，端口号等
        byte[] buf = "这里是发送端!".getBytes();
        DatagramPacket dp = new DatagramPacket(buf, buf.length, InetAddress.getByName("192.168.1.106"),8888);

        //4.通过Socket发送
        ds.send(dp);

        //5.关闭资源
        ds.close();
        
    }
}
```

# 26_08UDP协议_接收端

```java
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;

class Demo26_08 {
    public static void main(String[] args) throws IOException {
        /**
         * 1.建立Socket接收端，并记得输入接收端口
         * 2.建立数据报包对象，用于接收数据
         * 3.接收数据
         * 4.关闭资源
         */

        System.out.println("接收端开启......");
        //建立Socket接收端，并记得输入接收端口
        DatagramSocket ds = new DatagramSocket(8888);

        //2.建立数据报包对象，用于接收数据
        byte[] buf = new byte[1024];
        DatagramPacket dp = new DatagramPacket(buf,buf.length);

        //3.接收数据
        ds.receive(dp);

        //4.关闭资源
        ds.close();

        String s = new String(buf,0,dp.getLength());
        System.out.println(s);
    }
}
```

# 26_09UDP协议_聊天程序

1.我们将上述两个程序进行改动，首先发送的信息不应该是固定的，我们利用IO技术实时录入键盘信息

2.我们利用多线程技术使发送端与接收端程序同时运行

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

class Demo26_09 {
    public static void main(String[] args) throws SocketException {
        DatagramSocket send = new DatagramSocket();
        DatagramSocket rece = new DatagramSocket(3331);
        new Thread(new Send(send)).start();
        new Thread(new Rece(rece)).start();
    }
}

class Send implements Runnable {
    private DatagramSocket ds;

    Send(DatagramSocket ds) {
        this.ds = ds;
    }

    @Override
    public void run() {
        try {
            BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));

            String line = null;
            while((line=bufr.readLine())!=null){
                byte[] buf = line.getBytes();
                DatagramPacket dp = new DatagramPacket(buf, buf.length, InetAddress.getByName("192.168.1.106"),3331);
                ds.send(dp);
                if("886".equals(line))
                    break;
            }
        }
        catch(Exception e){
        }
        finally{
            ds.close();
        }
    }
}
class Rece implements Runnable{
    private DatagramSocket ds;
    Rece(DatagramSocket ds){
        this.ds = ds;
    }
    @Override
    public void run() {
        try{
            while(true){
                byte[] buf = new byte[1024];
                DatagramPacket dp = new DatagramPacket(buf, buf.length);
                ds.receive(dp);

                String ip = dp.getAddress().getHostAddress();
                int port = dp.getPort();
                String text = new String(dp.getData(),0,dp.getLength());

                if("886".equals(text)){
                    System.out.println(ip+"......"+port+"......"+text);
                    System.out.println(ip+"已经退出群聊");
                    continue;
                }
                System.out.println(ip+"......"+port+"......"+text);
            }
        }
        catch(Exception e){}
        finally{
            ds.close();
        }
    }
}
```

博主猜测dp.getData()与buf是相同的，即getData()方法返回的就是buf数组的引用

# 26_10TCP协议客户端

1.在UDP协议中DatagramSocket对象可以用于发送与接收数据，但是在TCP协议中，发送与接收数据涉及两个对象，客户端对象为Socket，服务器端对象为ServerSocket

2.建议建立客户端Socket对象时就明确要访问的目的地址IP与端口号

3.TCP协议需要源与目的之间建立虚拟连接，建立连接之后就存在流，既然有流就有输入流与输出流

```java
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;

class Demo26_10 {
    public static void main(String[] args) throws IOException {
        Socket s = new Socket("192.168.1.106",10002);
        OutputStream os = s.getOutputStream();
        os.write("客户端".getBytes());
        s.close();
    }
}
```

# 26_11TCP协议服务器端

1.服务器端需要先获取客户端的对象才能接收数据

```java
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;

class Demo26_11 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(10002);
        Socket s = ss.accept();
        InputStream is = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = is.read(buf);
        String text = new String(buf, 0, len);
        System.out.println(text);
        s.close();
        ss.close();
    }
}
```

# 26_12TCP协议客户端与服务器端的交互

发数据是相互的，上一个程序中我们演示了从客户端向服务器端发数据，这下面的程序中我们将要演示加上从服务器端向客户端发数据的效果

客户端

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class Demo26_10 {
    public static void main(String[] args) throws IOException {
        Socket s = new Socket("192.168.1.106",10003);
        OutputStream os = s.getOutputStream();
        os.write("我想要查找新型冠状病毒的最新消息".getBytes());

        InputStream is = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = is.read(buf);
        String text = new String(buf,0,len);
        System.out.println("客户端接收到的数据______"+text);
        s.close();
    }
}
```

服务器端

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

class Demo26_11 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(10003);
        Socket s = ss.accept();
        InputStream is = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = is.read(buf);
        String text = new String(buf, 0, len);
        System.out.println("服务器端收到的数据______"+text);

        OutputStream os = s.getOutputStream();
        os.write("截至2020年2月1日18时43分，新型冠状病毒已致259人死亡".getBytes());

        s.close();
        ss.close();
    }
}
```

![Demo26_12](https://github.com/geekavan/BiXiangdong/blob/master/Demo26_12.png)

上述程序中首先客户端向服务器端发送信息"我想要查找新型冠状病毒的最新消息"，服务器端收到该信息后向客户端回复信息"截至2020年2月1日18时43分，新型冠状病毒已致259人死亡"


# 26_13_14TCP协议_练习_文本转换客户端_服务器端

需求:客户端向服务器端发送字母，服务器端收到字母后在控制台打印出来，并转换为大写发送给客户端，客户端收到后在控制台打印出来，直到客户端发送over转换结束

客户端

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;

import java.io.InputStream;

class Demo26_13 {
    public static void main(String[] args) throws IOException {
        /**
         * 1.建立客户端Socket对象
         * 2.获取输出流对象 
         * 3.建立键盘输入流
         * 4.获取键盘输入数据，打印到输出流中
         * 5.获取输入流对象，读取服务器端发送来的数据
         * 6.关流
         */
        Socket s = new Socket("192.168.1.106",10007);
        BufferedWriter bufOut = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));
        BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));
        InputStream in = s.getInputStream();
        String line = null;
        while ((line = bufr.readLine()) != null) {
            if("over".equals(line))
                break;
            // bufOut.write(line+System.getProperty("line.separator"));
            bufOut.write(line+"\r\n");
            bufOut.flush();
            byte[] buf = new byte[1024];
            int len = in.read(buf);
            System.out.println(new String(buf,0,len));
        }
        s.close();
    }
}
```

服务器端

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

class Demo26_14 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(10007);
        Socket s = ss.accept();
        System.out.println(s.getInetAddress().getHostAddress()+"......connected");
        BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream()));
        OutputStream out = s.getOutputStream();
        String line = null;
        while((line=bufIn.readLine())!=null){
            System.out.println(line);
            out.write(line.toUpperCase().getBytes());
        }
        s.close();
        ss.close();
    }
}
```

1.客户端与服务器端写法都是不唯一的，这里的不唯一是指建立流对象的不唯一性，从Socket流中获取了输入或输出流之后，加的额外功能不一样得出的流也就不一样

2.加的额外功能有很多种选择，因为网络间不仅仅会传纯文本文件还会传送语音，图片，视频等媒体文件所以从Socket流获取的输入或输出流是字节流

    1.获取字节流之后如果我们想要高效一点那么我们可以添加缓冲区建立BufferedInputStream或BufferedOutputStream对象，或者我们可以选择自己建立字节缓冲区

    2.如果我们想利用BufferedReader的readLine方法，那么我们就需要利用InputStreamReader类将InputStream类转变为Reader类(字节流转变为字符流)，再利用BufferedReader类将Reader类加上缓冲区功能

    3.InputStream与Reader都是抽象类，两者都有read()方法，前者是读取一个字节，后者是读取一个字符，两者的read()方法中都可以带有数组参数，InputStream接收的是byte类型的数组，Reader接收的是char类型的数组，我们经常用byte类型数组或char类型的数组分别建立缓冲区

3.对于Socket流中的输出流，完全可以用PrintWriter对象，该对象可以将要打印的数据按原形式直接打印到输出流中

    1.该对象带自动刷新功能，设置形式为PrintWriter pw = new PrintWriter(s.getOutputStream(), true);构造函数中true的位置为开启自动刷新的开关，虽然打开了开关但是当调用该对象的println、printf 或 format 的其中一个方法时才可能完成此刷新操作

4.readLine方法是阻塞式方法只有读取到换行符时才能结束读取数据，所以客户端在写入Socket流中的数据时要加入line+"\r\n"或line+System.getProperty("line.separator")，否则程序会出现客户端与服务器端都等待的情况

# 26_16TCP协议_练习_上传文本文件

客户端

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;

class Demo26_16 {
    public static void main(String[] args) throws IOException {
        //建立客户端Socket对象
        Socket s = new Socket("192.168.1.106",8888);
        System.out.println(s.getInetAddress().getHostAddress()+"......conneted");
        // 获取输出流，并且转换为字符流，加上缓冲区
        BufferedWriter bufOut = new BufferedWriter(new OutputStreamWriter(s.getOutputStream(),"utf-8"));
        //建立文件对象，建立输入流
        // BufferedReader bufr = new BufferedReader(new FileReader(new File("f:\\tt.txt")));
        BufferedReader bufr = new BufferedReader(new InputStreamReader(new FileInputStream(new File("f:\\tt.txt")), "utf-8"));
        String line = null;
        while((line=bufr.readLine())!=null){
            bufOut.write(line+System.getProperty("line.separator"));
            bufOut.flush();
        }
        s.shutdownOutput();
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        System.out.println(new String(buf,0,len));
        bufr.close();
        s.close();
    }
}
```

服务器端

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;

class Demo26_16_2 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(8888);
        Socket s = ss.accept();
        BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream(),"utf-8"));
        BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File("f:\\服务器端文件.txt")),"utf-8"));
        // BufferedWriter bufw = new BufferedWriter(new FileWriter(new File("f:\\服务器端文件.txt")));
        String line = null;
        while((line = bufIn.readLine())!=null){
            bufw.write(line);
            bufw.newLine();
            bufw.flush();
        }
        OutputStream out = s.getOutputStream();
        out.write("上传成功!".getBytes());
        out.close();
        bufw.close();
        s.close();
        ss.close();
    }
}
```

1.我们要注意编码的问题，客户端原来的一段读取文本的代码为BufferedReader bufr = new BufferedReader(new FileReader(new File("f:\\tt.txt")));但是bufr.readLine()读出来的却是乱码，经过博主查找知道了问题所在，f:\\tt.txt文件为utf-8编码格式(点击文件另存为界面可见)，而FileReader为读取字符文件的便捷类，该类假定默认的字符编码和字节缓冲区大小都是适当的，这里假定的默认编码就是GBK，原来的字符使用utf-8来存储，现在使用GBK来读取当然会出现问题，所以要利用FileInputStream与InputStreamReader来指定编码格式

2.我们不要忘记客户端在向输出流输出数据时添加System.getProperty("line.separator")因为服务端代码的原因不加上此句话会出错

# 27

# 27_17_18TCP协议_练习_上传图片

练习:从客户端向服务器端上传一个图片文件，服务器端收到文件后在本地备份并且向客户端发送"上传成功!"消息

本练习与上传文本文件练习类似

客户端

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class Demo27_17 {
    public static void main(String[] args) throws IOException {
        //建立Socket对象
        Socket s = new Socket("192.168.1.106",8889);
        //获取输出流
        OutputStream out = s.getOutputStream();
        //建立输入流，关联图片
        InputStream is = new FileInputStream(new File("f:\\0.jpg"));
        //读写操作
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=is.read(buf))!=-1){
            out.write(buf,0,len);
        }
        //发送数据结束，告诉服务器端
        s.shutdownOutput();
        //获取输入流，接收服务器端发送的数据
        InputStream in = s.getInputStream();
        byte[] bufIn = new byte[1024];
        int lenIn = in.read(bufIn);
        System.out.println(new String(bufIn, 0, lenIn));

        in.close();
        is.close();
        s.close();
    }
}
```

服务器端

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

class Demo27_17_2 {
    public static void main(String[] args) throws IOException {
        //建立ServerScoket对象
        ServerSocket ss = new ServerSocket(8889);
        
        //获取Socket对象
        Socket s = ss.accept();
        String ip = s.getInetAddress().getHostAddress();
        //获取输入流
        InputStream in = s.getInputStream();
        //建立输出流，与文件相关联
        OutputStream os = new FileOutputStream("f:\\"+ip+".jpg");
        //读写操作
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=in.read(buf))!=-1){
            os.write(buf,0,len);
        }
        //获取输出流
        OutputStream out = s.getOutputStream();
        out.write("上传成功!".getBytes());

        os.close();
        s.close();
        ss.close();
    }
}
```

# 27_19TCP协议_练习_服务器端多线程技术

上述程序有一个问题，就是一旦一个客户端连接到了服务器端，其他用户就不能够连接服务器，没办法上传图片，这个问题可以通过多线程技术来解决

客户端

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

class Demo27_19 {
    public static void main(String[] args) throws IOException {
        //建立Socket对象
        Socket s = new Socket("192.168.1.106",8889);
        //获取输出流
        OutputStream out = s.getOutputStream();
        //建立输入流，关联图片
        InputStream is = new FileInputStream(new File("f:\\0.jpg"));
        //读写操作
        byte[] buf = new byte[1024];
        int len = 0;
        while((len=is.read(buf))!=-1){
            out.write(buf,0,len);
        }
        //发送数据结束，告诉服务器端
        s.shutdownOutput();
        //获取输入流，接收服务器端发送的数据
        InputStream in = s.getInputStream();
        byte[] bufIn = new byte[1024];
        int lenIn = in.read(bufIn);
        System.out.println(new String(bufIn, 0, lenIn));

        in.close();
        is.close();
        s.close();
    }
}
```

服务器端

```java
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

class Demo27_19_2 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(8889);
        while(true){
            Socket s = ss.accept();
            new Thread(new ServerTask(s)).start();
        }        
    }
}
class ServerTask implements Runnable{
    private Socket s;
    ServerTask(Socket s){
        this.s = s;
    }

    @Override
    public void run() {
        try{
            int count = 0;
            String ip = s.getInetAddress().getHostAddress();
            InputStream in = s.getInputStream();
            File file = new File("f:\\"+ip+".jpg");
            while(file.exists()){
                file = new File("f:\\"+ip+"("+(++count)+")"+".jpg");
            }
            OutputStream os = new FileOutputStream(file);
            byte[] buf = new byte[1024];
            int len = 0;
            while((len=in.read(buf))!=-1){
                os.write(buf,0,len);
            }
            //获取输出流
            OutputStream out = s.getOutputStream();
            out.write("上传成功!".getBytes());

            os.close();
            s.close();
        }
        catch(IOException e){}
    }
}
```

注意:上述程序中为了使程序简单，并没有将关闭资源写在finally语句中

# 27_20常见的客户端与服务器端

1.常见的客户端:

    这个非常多，比如QQ，比如IE浏览器等等

2.常见的服务器端:

    服务器即能够提供服务的机器，在服务器上也是安装某些软件来提供服务的，对外暴露端口，比如Tomcat就是提供访问网页数据的软件，Oracle为提供访问数据库的软件

3.何为http或https，这两个是应用层的协议，TCP/UDP是传输层的协议，ip是网际层的协议

4.Tomcat中执行的程序可以划分为两步操作，处理请求和给予应答，直接使用java语言就可以，但是为什么Tomcat可以识别你用Java语言书写的处理请求和给予应答的程序呢？Tomcat制定一些规则，Java语言编写的时候实现这些规则就可以了，即实现了一个接口，这个接口为Servlet，所以服务器编程也称为Servlet编程

5.从网上下载Tomcat软件，安装并运行，在你的浏览器输入:192.168.1.106:8080回车就会看见Tomcat的默认浏览页面

    其中192.168.1.106为你的本机回环IP号码查看方式为String ip = InetAddress.getLocalHost().getHostAddress();本机名称为String name = InetAddress.getLocalHost().getHostName();

    端口的查看方式为:Tomcat 9.0\conf\server.xml文件中<Connector executor="tomcatThreadPool"
    port="8080"部分

    IP地址与端口之间要用冒号隔开 

# 27_21了解客户端和服务器端原理

我们完全可以自己建立一个类似于Tomacat的软件，处理客户端发来的请求

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

class Demo27_21 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(9527);
        Socket s = ss.accept();
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        System.out.println(new String(buf, 0, len));
        OutputStream out = s.getOutputStream();
        out.write("你好".getBytes());
        out.flush();
        s.close();
        ss.close();
    }
}
```

浏览器的网页是应该能够收到"你好"字样才对,但是不知道是什么原因,浏览器并没有收到信息,但是服务器端确实收到了来自浏览器端的请求,请求如下,介绍写在了旁边以#区分

GET / HTTP/1.1 #请求行:包含了请求方式GET/POST,请求资源路径(这里没有),所用协议HTTP1.1
#以下部分是请求头,如果有请求体,请求头和请求体之间要有一空行
Host: 192.168.1.106:9527请求访问的ip地址与端口号
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36#这是客户端所用的浏览器版本等信息,有些网页的某些信息显示不了,提示需要更高版本的浏览器就是用这些信息判断的
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
#客户端浏览器多支持的文件类型
Accept-Encoding: gzip, deflate#客户端浏览器所支持的压缩文件类型,如果请求的网页文件过大,服务器会根据浏览器所支持的压缩文件类型将网页资源压缩发送给浏览器
Accept-Language: zh-CN,zh;q=0.9#浏览器支持的语言,这个在浏览器上可以设置
#以上部分是请求头

# 27_22网络编程_模拟一个浏览器获取信息

在接下来的演示中我们自己建立一个html网页文件,具体方式为在Tomcat的安装目录下Tomcat 9.0\webapps\ROOT文件夹下建立一个.txt文件(注意这个之后要更改为.html类型文件),在其中写下:

    <html>
        <meta charset="utf-8" />
	    <head>
		<title>这是我的网页</title>
	    </head>

	    <body>
		    <h1>欢迎光临</h1>
		    <font color='red' size='7'>最好看的网页</font>
	    </body>
    </html>

将其更改为1.html之后打开Tomcat软件,在任意浏览器上运行192.168.1.106:8080/1.html回车就会访问到该网页,效果如下

![27_22](https://github.com/geekavan/BiXiangdong/blob/master/27_22.png)

接下来我们将模拟浏览器的功能,向Tomcat服务器发送访问该网页的请求

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.Socket;

class Demo27_22 {
    public static void main(String[] args) throws IOException {
        Socket s = new Socket("192.168.1.106",8080);
        PrintWriter out = new PrintWriter(s.getOutputStream(),true);
        out.println("GET /1.html HTTP/1.1");
        out.println("Host: 192.168.1.106:8080");
        // out.println("Connection: keep-alive");
        // out.println("Cache-Control: max-age=0");
        // out.println("User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36");
        // out.println("Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9");
        // out.println("Accept-Encoding: gzip, deflate");
        // out.println("Accept-Language: zh-CN,zh;q=0.9");
        out.println();
        out.println();
        InputStream in = s.getInputStream();
        byte[] buf = new byte[2048];
        int len = in.read(buf);
        System.out.println(new String(buf,0,len,"utf-8"));
        s.close();
    }
}
/*
HTTP/1.1 200 #应答行 协议类型及版本 应答状态码 200是正确响应的意思
#应答头
Accept-Ranges: bytes
ETag: W/"199-1580798489962"
Last-Modified: Tue, 04 Feb 2020 06:41:29 GMT#最近一次修改时间,一旦浏览器再次向服务器发送此页面请求,会把该消息也发送过去,浏览器发现最近一次修改时间和自己保存的页面的最近一次修改时间一致的话,就不用发送数据了,直接告诉浏览器,浏览器显示缓存页面就可以了
Content-Type: text/html
Content-Length: 199
Date: Tue, 04 Feb 2020 08:54:35 GMT
#应答头结束
#空行
#应答体
<html>
<meta charset="utf-8" />
        <head>
                <title>这是我的网页</title>
        </head>

        <body>
                <h1>欢迎光临</h1>
                <font color='red' size='7'>最好看的网页</font>
        </body>
</html>
*/
```

# 27_23网络编程_URL_URLConnection

1.我们自己模拟的浏览器与IE浏览器不同,IE浏览器中不会出现应答信息头,只会呈现给我们应答信息体,那么我们为什么会收到应答信息头呢?这是因为IE浏览器带有http协议的解析内核而我们自己写的程序中却没有,Java中提供了能够解析http协议数据的对象,这就是URL

2.URL为统一资源定位符(Uniform Resource Locator)(也是Java中类名),例如http://192.168.1.106:8080/1.html就是一个URL,有了它我们就可以定位到网络上的一个具体资源

3.有了URL之后我们可以获取到很多信息,比如应用层的协议为http,目的地的ip地址为192.168.1.106,访问的端口为8080,访问的资源文件为1.html等

```java
import java.net.MalformedURLException;
import java.net.URL;

class Demo27_23 {
    public static void main(String[] args) throws MalformedURLException {
        URL url = new URL("http://192.168.1.106:8080/1.html?name=lisi");
        System.out.println("getProtocol()......"+url.getProtocol());
        System.out.println("getHost()......"+url.getHost());
        System.out.println("getPort()......"+url.getPort());
        System.out.println("getPath()......"+url.getPath());
        System.out.println("getFile()......"+url.getFile());
        System.out.println("getQuery()......"+url.getQuery());
    }
}
/*
getProtocol()......http
getHost()......192.168.1.106
getPort()......8080
getPath()....../1.html
getFile()....../1.html?name=lisi
getQuery()......name=lisi
*/
```

其中?name=lisi为访问的附加信息,输入url之后网页显示欢迎光临,加上?name=lisi之后网页就可以显示为欢迎lisi光临,加上附加信息之后就可以看出getPath()与getFile()之间的区别

有了url之后我们可以获取输入流,利用的是URLConnection对象,利用URL对象也可以完成,但是其也是调用的URLConnection工具

```java
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;

class Demo27_23_2 {
    public static void main(String[] args) throws IOException {
        URL url = new URL("http://192.168.1.106:8080/1.html?name=lisi");
        URLConnection conn = url.openConnection();
        InputStream in = conn.getInputStream();
        byte[] buf = new byte[1024];
        int len =in.read(buf);
        System.out.println(new String(buf,0,len,"utf-8"));
        in.close();
    }
}
/*
<html>
<meta charset="utf-8" />
        <head>
                <title>这是我的网页</title>
        </head>

        <body>
                <h1>欢迎光临</h1>
                <font color='red' size='7'>最好看的网页</font>
        </body>
</html>
*/
```

我们看到从输入流获取的数据并没有应答信息头,因为URLConnection对象把满足http协议的信息头解析了,URLConnection就相当于http协议与Socket的结合,如果想的话我们也可以获取应答头的信息,这里不再演示查阅API即可

# 27_24网络编程_常见网络结构

1.C/S结构 client/server

    缺点:该结构的软件,客户端与服务端都需要编写
    开发成本高,维护较为麻烦

    优点:本地会分担一部分算力

2.B/S结构 browser/server

    优点:该结构的软件,只需要编写服务器端,客户端由浏览器代替
    开发成本相对较低,维护更为简单

    缺点:所有的计算都需要在服务端完成

# 28

# 28_03正则表达式_匹配

正则表达式的出现就是为了使我们能够更加方便地操作字符串，如现在有这样一个需求:判断一个qq号码是否合法，假定一个合法的qq号码需要满足:5-15位，全部是数字，不以数字0作为开头，如果没有正则表达式，我们需要编写的程序为

```java
class Demo28_03_01{
    public static void main(String[] args){
        String qq = "12345678901o4";
        boolean b = isQQ(qq);
        System.out.println(b);
    }

    private static boolean isQQ(String qq) {
        int length = qq.length();
        if(length>=5 && length<=15){
            if(!qq.startsWith("0")){
                try{
                    long l = Long.parseLong(qq);
                    return true;
                }
                catch(NumberFormatException e){
                    return false;
                }
            }
            return false;
        }
        return false;
    }
}
```

有了正则表达式之后我们就可以将上述程序简化为:

```java
class Demo28_03{
    public static void main(String[] args){
        /**
         * 1.匹配
         * 2.应用的是String类中matches方法
         */
        String qq = "1234567890123456";
        String regex = "[1-9][0-9]{4,14}";
        // String regex = "[1-9]\\d{4,14}";
        System.out.println(qq.matches(regex));
    }
}
```

1.我们看到有了正则表达式之后，程序大大简化了，其中

    [1-9]代表1位数字，该数字为阿拉伯数字1到9这9个数中任意一个数字都可以，由于写在了正则表达式最开头，这代表要匹配的字符串的第一位必须为这9个数字的任意一个

    [0-9]代表1位数字，该数字为阿拉伯数字0到9这10个数中任意一个数字都可以，由于写在了正则表达式"第二个"的位置，这代表要匹配的字符串的第二位必须为这10个数字的任意一个

    {4,14}代表符合[0-9]这个规则的数字可以继续出现至少4次(包含第二位的1次)，至多出现14次(包含第二位的1次)

    这就满足了qq号合法检验的要求

2.正则表达式中，[0-9]可以使用\d表示，但是单个字母d表示一个字符，\d表示正则表达式中[0-9]规则，但是当它变为字符串"\d"之后，\就代表字母d进行了转义，变成了别的含义，为了让其在字符串中也能正确表示为\d需要将\也进行转义，前面再加上一个\即可，综上应该写为\\d，官方解释如下

3.根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 "\b" 与单个退格字符匹配，而 "\\b" 与单词边界匹配

4.所以

    String regex="[1-9][0-9]{4,14}"也可以写为

    String regex="[1-9]\\d{4,14}"

# 28_04正则表达式_切割

切割涉及的是String类中的split方法

示例1

```java
class Demo28_04{
    public static void main(String[] args){
        String str = "zhangsan lisi   wangwu";
        String regex = " +";
        String[] names = str.split(regex);
        for(String name:names){
            System.out.println(name);
        }
    }
}
/*
zhangsan
lisi
wangwu
*/
```

其中+是正则表达式中的符号，代表它前面的东西出现了一次或多次，这里就代表空格出现了一次或多次

示例2

```java
class Demo28_04_2{
    public static void main(String[] args){
        String str = "zhangsan.lisi.wangwu";
        String regex = "\\.";
        String[] names = str.split(regex);
        for(String name:names){
            System.out.println(name);
        }
    }
}
/*
zhangsan
lisi
wangwu
*/
```

在regex中为什么不能够只写"."呢？这是因为在正则表达式中.被赋予了特殊含义被表示为任意字符，所以若想要字符串以.进行分割需要将.进行转义，\.就不会被识别为正则表达式可能会被认为是字符串中类似于\r与\n的含义，所以要再加一个\符号，综上为\\.

示例3

```java
class Demo28_04_3{
    public static void main(String[] args){
        String str = "zhangsantttttttttttlisimmmmmmmmmmmmmmmwangwu";
        String regex = "(.)\\1+";
        String[] names = str.split(regex);
        for(String name:names){
            System.out.println(name);
        }
    }
}
/*
zhangsan
lisi
wangwu
*/
```

1.上述程序中我们想要字符串正确分割出三个人的名字，这里涉及到"组"的概念，类似于函数，组的概念的出现也是为了复用，以()表示，.表示任意字符，(.)表示一个组(该例子中是第一组)，紧接着后边的\\1表示第一组的数字，+表示该数字出现了一次或多次

2.\\1也好理解，1是数字1，\1不会被识别为正则表达式，所以要写为\\1

3.正则表达式的整体是第0组

4.捕获组(即我们所说的"组")可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组： 

    1     ((A)(B(C))) 
    2     \A 
    3     (B(C)) 
    4     (C) 

    组零始终代表整个表达式

# 28_05正则表达式_替换

示例1

```java
class Demo28_05{
    public static void main(String[] args){
        String str = "zhangsanttttttttlisimmmmmmmmmmmmwangwu";
        String newStr = str.replaceAll("(.)\\1+","#");
        System.out.println(newStr);
    }
}
/*
zhangsan#lisi#wangwu
*/
```

将str中ttttt与mmmmm替换为#，这是比较简单的，那么如果将多个t与多个m替换成单个t与单个m呢？

示例2

```java
class Demo28_05_2{
    public static void main(String[] args){
        String str = "zhangsanttttttttlisimmmmmmmmmmmmwangwu";
        String newStr = str.replaceAll("(.)\\1+","$1");
        System.out.println(newStr);
    }
}
/*
zhangsantlisimwangwu
*/
```

这个需求难在第二个参数里要用到第一个参数中的内容，这时需要使用$符号，$1就代表第一个参数中第一个"组"

示例3，手机号码隐藏部分

```java
class Demo28_05_3{
    public static void main(String[] args){
        String str = "12345678901";
        String newStr = str.replaceAll("(\\d{4})\\d{4}(\\d{3})","$1****$2");
        System.out.println(newStr);
    }
}
/*
1234****901
*/
```

# 28_06正则表达式_获取

想要学习正则表达式的获取操作必须要了解Pattern与Matcher对象

```java
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class Demo28_06{
    public static void main(String[]args){
        String str = "da jia hao,ming tian bu fang jia";
        String regex = "\\b[a-z]{3}\\b";
        //将正则表达式封装成Pattern对象
        Pattern p = Pattern.compile(regex);
        //通过Pattern对象获取Matcher对象，并与字符串关联
        Matcher m = p.matcher(str);
        //调用Matcher方法对字符串进行操作
        while(m.find()){
            System.out.println(m.group());
        }
    }
}
/*
jia
hao
jia
*/
```

其中\\b是边界的意思

# 28_07正则表达式_练习1

需求:治疗口吃

```java
class Demo28_07{
    public static void main(String[] args){
        String str = "我我...我我..我我.我....我我.我要.要要..要.要要要.要....要.要学..学学.......学学..学...学.学....编编编.编....编程程程程";
        //去掉.
        str = str.replaceAll("\\.+","");
        str = str.replaceAll("(.)\\1+", "$1");
        System.out.println(str);
    }
}
/*
我要学编程
*/
```

# 28_08正则表达式_练习2

ip地址排序

```java
import java.util.Iterator;
import java.util.TreeSet;

class Demo28_08_2 {
    public static void main(String[] args){
        String str = "192.168.1.106  92.168.113.0 3.3.3.3 255.255.255.0";
        str = str.replaceAll("\\d+","00$0");
        str = str.replaceAll("0*(\\d{3})","$1");
        String regex = " +";
        String[] ips = str.split(regex);
        TreeSet<String> hm = new TreeSet<String>();
        for(String ip:ips){
            hm.add(ip);
        }
        Iterator<String> it = hm.iterator();
        while(it.hasNext()){
            System.out.println(it.next().replaceAll("0*(\\d+)", "$1"));
        }
    }
}
/*
3.3.3.3
92.168.113.0
192.168.1.106
255.255.255.0
*/
```

也可以将这些规则写在TreeSet集合的比较器Comparator中，程序如下:

```java
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

class Demo28_08_3 {
    public static void main(String[] args){
        String str = "192.168.1.106  92.168.113.0 3.3.3.3 255.255.255.0";
        String regex = " +";
        String[] ips = str.split(regex);
        TreeSet<String> hm = new TreeSet<String>(new Comparator<String>() {

            @Override
            public int compare(String o1, String o2) {
                String regex = "\\d+";
                String replacement = "00$0";
                o1 = o1.replaceAll(regex, replacement);
                o2 = o2.replaceAll(regex, replacement);
                regex = "0*(\\d{3})";
                replacement = "$1";
                o1 = o1.replaceAll(regex, replacement);
                o2 = o2.replaceAll(regex, replacement);
                return o1.compareTo(o2);
            }
        });
        for(String ip:ips){
            hm.add(ip);
        }
        Iterator<String> it = hm.iterator();
        while(it.hasNext()){
            System.out.println(it.next().replaceAll("0*(\\d+)", "$1"));
        }
    }
}
```

# 28_10正则表达式_练习_爬虫

本程序段并没有在本地运行，原因为博主没有写带有可爬取的邮件地址的网页页面，也没有找符合我们初学者爬取的网页页面

```java
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

class Demo28_10 {
    public static void main(String[] args) throws FileNotFoundException, MalformedURLException {
        BufferedReader bufr = new BufferedReader(new FileReader("f:\\1.html"));
        // URL url = new URL("192.168.1.106:8080/1.html");
        // BufferedReader burIn = new BufferedReader(new InputStreamReader(url.openStream(),"uf-8"));
        String regex = "\\w+@\\w+(\\.\\w+)+";
        Pattern p = Pattern.compile(regex);
        String line = null;
        List<String> list = new ArrayList<String>();
        while((line=bufr.readLine())!=null){
            Matcher m = p.matcher(line);
            if(m.find())
                list.add(m.group());
        }
    }
}
```

# 29

# 29_01_02HTML概述与演示

1.HTML是超文本标记语言，格式一般为<标签名 属性值="属性值">数据内容</标签名>

2.HTML语言一般格式如下

    <html>
        <head>
        </head>
        <body>
        </body>
    </html>

3.HTML语言不区分大小写

4.一个例子，下述文本存储在test.html文件中，位置在Tomcat软件的安装路径下的Tomcat 9.0\webapps\ROOT\test.html

    <html>
        <head>
            <meta charset="utf-8" />
            <title>这是网页名称</title>
        </head>
        <body>
            <font color="red" size="8">这是网页内容</font><br />这是第二行内容
        </body>
    </html>

5.其中

    <meta charset="utf-8">指明的是这个html文件中字符的编码方式

6.

    <font></font>中添加的是字体，可以设置其中字体的大小颜色等等

7.

    <br>与<br />都是换行的意思，html语言并不严谨

8.其他

    <hr />是水平线的意思

    <h1></ h1>是一级标题的意思，html支持1到6级标题，分别改变标签中的数字就可以了

    

![29_01_02](https://github.com/geekavan/BiXiangdong/blob/master/29_01_02.png)

# 29_04HTML列表标签

1.HTML语言的注释符号为

    <!--注释内容-->

2.HTML语言的列表标签

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>淘宝网-淘！我喜欢</title>
    </head>

    <body>
        <dl>
            <dt>上层目录</dt>
            <dd>下层目录</dd>
            <dd>下层目录</dd>
            <dd>下层目录</dd>
        </dl>
    </body>
</html>
```

![29_04](https://github.com/geekavan/BiXiangdong/blob/master/29_04.png)

从图片中我们看到下层目录前面有缩进

语言记忆窍门:

    1.由于是列表标签，所以标签的名称里边有一个l代表list，而下层目录前面没有东西，是被删除了所以有一个d代表delete

    2.上层目录top所以为dt，下层目录为down所以为dd

3.前面带有符号的列表标签

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>淘宝网-淘！我喜欢</title>
    </head>

    <body>
        <dl>
            <dt>上层目录</dt>
            <dd>下层目录</dd>
            <dd>下层目录</dd>
            <dd>下层目录</dd>
        </dl>

        <hr/>

        <ol>
            <li>有序项目列表</li>
            <li>有序项目列表</li>
            <li>有序项目列表</li>
            <li>有序项目列表</li>
            <li>有序项目列表</li>
        </ol>
        
        <hr>

        <ul>
            <li>无序项目列表</li>
            <li>无序项目列表</li>
            <li>无序项目列表</li>
        </ul>
    </body>
</html>
```

![29_04_2](https://github.com/geekavan/BiXiangdong/blob/master/29_04_2.png)


    html是不严谨的语言，<hr>与<hr/>都识别为了水平线

记忆窍门:

    有序项目列表因为有序所以有order，因为是列表所以有list组合在一起就是ol

    无序项目列表因为无序所以unorder(博主不知是否是无序的意思但是没所谓)，因为列表所以list组合在一起就是ul

    因为都是列表中的项目所以列表里的条目标签为li

    <hr>是水平线，现实生活中hr也是拿着准绳的人，他们依靠手中的准绳来招聘员工

像无序项目列表前面的小黑圆圈可不可以换个颜色呢?这也太难看了，这使用HTML语言是做不到的，需要css语言

# 29_05HTML图像标签

执行下列代码需将图片资源与此html文件保存在同一文件夹下

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>妹子图-性感美女图片每日更新</title>
    </head>

    <body>
        <img src="01a01.jpg" height="300" width="300" border=10 alt="啊，美女" />
    </body>
</html>
```

![29_05](https://github.com/geekavan/BiXiangdong/blob/master/29_05.png)

其中border为图片中黑色的边框，alt参数内容当光标移动到图片上就应该出现，不知道为什么并没有出现，当我们将src参数值改动，即当文件夹中不存在网页代码中所引用的资源时，有

![29_05_2](https://github.com/geekavan/BiXiangdong/blob/master/29_05_2.png)

我们看到alt参数处其实就是资源的名称

# 29_06HTML表格标签

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>格表表-记录你的精彩人生</title>
    </head>

    <body>
        <table>
        <caption>表格标题</caption>
            <tr>
                <td>姓名</td>
                <td>年龄</td>
            </tr>
            <tr>
                <td>张三</td>
                <td>52</td>
            </tr>
        </table>
    </body>
</html>
```

![29_06](https://github.com/geekavan/BiXiangdong/blob/master/29_06.png)

其中

    1.<table></table>为表格标签

    2.<tr></tr>标签标明的是表格中行数据，记忆窍门为行row

    3.<td></td>标签标明的是行中的单元格数据，记忆窍门为单元格的"单"字汉语拼音为dan

    4.<caption></caption>为表格标题标签

表格是可以加入格子的，在table标签里加入属性即可

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>格表表-记录你的精彩人生</title>
    </head>

    <body>
        <table border=1 cellpadding=10 cellspacing=50>
        <caption>表格标题</caption>
            <tr>
                <td>姓名</td>
                <td>年龄</td>
            </tr>
            <tr>
                <td>张三</td>
                <td>52</td>
            </tr>
        </table>
    </body>
</html>
```

![29_06_2](https://github.com/geekavan/BiXiangdong/blob/master/29_06_2.png)

其中:

    1.border控制表格线的粗细

    2.cellpadding控制单元格中字体和单元格之间的间隔大小

    3.cellspacing控制单元格与单元格之间的间隔大小

# 29_07HTML表格标签_2

一些特殊形式的表格的打印，例子1

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>格表表-记录你的精彩人生</title>
    </head>

    <body>
        <table border=1 cellpadding=10 cellspacing=10>
        <caption>表格标题</caption>
            <tr>
                <th colspan=2>个人信息表</th>
            </tr>
            <tr>
                <td>姓名</td>
                <td>年龄</td>
            </tr>
        </table>
    </body>
</html>
```

![29_07](https://github.com/geekavan/BiXiangdong/blob/master/29_07.png)

其中

    1.<th></th>表示文字居中

    2.<th colspan=2></th>表示列合并，合并2列

    3.<th rowspan=2></th>表示行合并，合并2行

例子2

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>格表表-记录你的精彩人生</title>
    </head>

    <body>
        <table border=1 cellpadding=10 cellspacing=10>
        <caption>表格标题</caption>
            <tr>
                <th rowspan=2>个人信息表</th>
                <td>姓名</td>
            </tr>
            <tr>
                <td>年龄</td>
            </tr>
        </table>
    </body>
</html>
```

![29_07_2](https://github.com/geekavan/BiXiangdong/blob/master/29_07_2.png)

    1.注意表结构下面有一行默认的<tbody></tbody>语句，这句语句中就包含了在<table></table>中写的所有语句

    2.因为如果一个网页以一张大表的形式存在的话，若浏览器收不到网页数据结尾处的</table>就不会显示该网页，这样就会导致一些大型网页显示速度慢，为了解决这一个问题，人们将table结构中加入了<thead></thead>与<tbody></tbody>还有<tfoot></tfoot>标签，一旦浏览器收到一个<tbody></tbody>结构就显示该部分，这样人们再看到大型网页的时候就不会等好长时间刷不出来而是一部分一部分刷新了

# 29_08HTML超链接_1

例子1

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>超链接演示</title>
    </head>

    <body>
        <a href="http://baidu.com">百度</a>
    </body>
</html>
```

    1.在该例子中，点击百度字样，就会跳转到百度界面

    2.<a></a>是超链接标记符，与其他标记符不同的是，超链接标记符必须指定href属性才能够正常工作，不指定href属性就不是超链接

    3.href属性的属性值中http指明了协议，该协议浏览器支持，如果遇到浏览器不支持的协议，浏览器会在本机的注册表里边寻找哪一个软件支持某协议，便用哪个软件解析href后面的数据

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>超链接演示</title>
    </head>

    <body>
        <a href="thunder://dslkjfaeionfanojioNNnJKswkjns=">迅雷</a>
    </body>
</html>
```

    1.thunder协议浏览器不支持，浏览器会在本机的注册表里寻找支持此协议的软件，发现迅雷支持此协议便请求打开迅雷，之后迅雷软件会弹出窗口确认是否要下载此视频(本演示并不是可下载的迅雷链接)

# 29_09HTML超链接_2

超链接还有一个定位功能，就是比如说你滑动到网页的底部，点击"回到顶部"的超链接就可以回到顶部，该功能比较好理解，只给出代码并不做实际的演示


```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>超链接演示</title>
    </head>

    <body>
        <a name="top">顶部位置</a>
        <hr/>
        <img src="01a01.jpg" heigth=2000 width=300 border=10 />
        <hr/>
        <a href="#top">回到顶部</a>
    </body>
</html>
```

# 29_10HTML框架

我们希望将一个窗体分为几个部分，每个部分显示不同的资源

```html
<html>
    <head>
        <meta charset="utf-8" />
        <title>框架演示</title>
    </head>
    <frameset rows="30%,*">
        <frame src="top.html" name="top"/>
        <frameset cols="30%,*">
        <frame src="left.html" name="left"/>
        <frame src="right.html" name="right"/>
    </frameset>
    <body>
        <a name="top">顶部位置</a>
        <hr/>
        <img src="01a01.jpg" heigth=2000 width=300 border=10 />
        <hr/>
        <a href="#top">回到顶部</a>
    </body>
</html>
```

    1.其中涉及的网页资源接下来有写，演示效果在本节后边也有

    2.要想一个网页里边显示多个网页资源，需要用到<frameset></frameset>标记符，并且标签中的rows属性表示行分割的比例，<frameset rows="30%,*"></frameset>表示一共分为两行，上一行占比30%，下一行占比70%，类似地<frameset cols="30%,*"></frameset>表示将一行分为两列，左边一列占比30%，右边一列占比70%

    3.现在这一个窗体被分为了多个部分，每一个部分显示什么网页资源需要使用<frame/>标签，并且使用标签中的src属性，以src的属性值标明该部分显示什么网页资源，其中name属性是为了标明这个部分以便以后设置链接的时候，设置链接后的资源显示在什么位置

    4.设置链接后的资源显示在什么位置的标签属性为target，比如我想让美女图片显示在右边的部分就可以设置为<a href="01a01.jpg" target="right">美女图片</a>

    5.注意框架写入的位置，为<head></head>和<body></body>之间

其中top.html

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <h1>这是我的网页logo</h1>
    </body>
</html>
```

left.html

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <h2>请选择网页资源</h2>
        <a href="01a01.jpg" target = "right">美女图片</a>
        <a href="http://www.baidu.com" target = "right">百度</a>
    </body>
</html>
```

right.html

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <h2>网页内容为</h2>
        <hr/>
    </body>
</html>
```

![29_10](https://github.com/geekavan/BiXiangdong/blob/master/29_10.png)

# 29_11HTML画中画标签

在网页中还无痕迹地嵌入另一个网页，上一节框架中能够看到各个网页之间的"界限"，仔细比较两者还是很有不同的

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <iframe src="left.html" height=300 width=300 />
    </body>
</html>
```

![29_11](https://github.com/geekavan/BiXiangdong/blob/master/29_11.png)

# 29_12HTML表单组件_input

表单标签非常重要，因为它是与服务器进行交互的工具

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <form>
            输入姓名:<input type="text"/><br/>
            输入密码:<input type="password"/><br/>
            选择性别:<input type="radio" name="sex"/>男<input type="radio" name="sex" checked="checked"/>女<br/>
            选择技术:<input type="checkbox"/>JAVA
                     <input type="checkbox"/>HTML
                     <input type="checkbox"/>CSS<br/>
            <input type="reset" value="清除数据"/>
            <input type="submit" value="提交数据"/>
        </form>
    </body>
</html>
```

![29_12](https://github.com/geekavan/BiXiangdong/blob/master/29_12.png)

其中:

    1.<form></form>为表单标签

    2."text"属性值是输入文本

    3."password"属性值是不显示地输入文本，即无论你输入什么都会显示为小黑圆点

    4."radio"为单选按钮，但是要想将几个选项设置为单选，需要将那几个选项绑定在一起，通过设置相同的name属性的属性值来完成，其中都设置为了"sex"，checked="checked"为缺省选项

    5."checkbox"属性值是复选框

    6."reset"为重置属性值，"submit"为提交数据属性值

当我们随便输入一些数据，点击提交数据之后，我们发现url变为

    file:///C:/Users/Ivan/Desktop/1.html?sex=on

    多了？sex=on

    1.?后面那些就是浏览器发送给服务器端的数据

    2.我们看到这里只发送了sex=on但是其他数据并没有发送，这是因为要想给服务器发送数据，表单各个input标签中必须要有名称name和值value属性


```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <form>
            输入姓名:<input type="text" name="user" value=""/><br/>
            输入密码:<input type="password" name="psw" value=""/><br/>
            选择性别:<input type="radio" name="sex" value="m"/>男
                    <input type="radio" name="sex" value="f" checked="checked"/>女<br/>
            选择技术:<input type="checkbox" name="tk" value="JAVA"/>JAVA
                     <input type="checkbox" name="tk" value="HTML"/>HTML
                     <input type="checkbox" name="tk" value="CSS"/>CSS<br/>
            <input type="reset" value="清除数据"/>
            <input type="submit" value="提交数据"/>
        </form>
    </body>
</html>
```

修改之后，输入一些数据点击提交之后，url变为

    file:///C:/Users/Ivan/Desktop/1.html?user=JACK&psw=123&sex=m&tk=JAVA&tk=CSS

    1.我们看到，我们输入了user值为JACK，密码输入了123，性别选择了男性为m，技术选择了JAVA和CSS

    2.我们也看到了问题，psw直接就显示出来了，如果要被人截获了，别人不就可以登陆我的账户了？这该怎么办呢？老师并没有提到这一点

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <form>
            输入姓名:<input type="text" name="user" value=""/><br/>
            输入密码:<input type="password" name="psw" value=""/><br/>
            选择性别:<input type="radio" name="sex" value="m"/>男
                    <input type="radio" name="sex" value="f" checked="checked"/>女<br/>
            选择技术:<input type="checkbox" name="tk" value="JAVA"/>JAVA
                     <input type="checkbox" name="tk" value="HTML"/>HTML
                     <input type="checkbox" name="tk" value="CSS"/>CSS<br/>
            选择文件:<input type="file" name ="file"/><br/>
            一个图片:<input type="image" height=25 width=40 src="1.jpg"/><br/>
            隐藏组件:<input type="hidden" name="hi" value="hi"/><br/>
            一个按钮:<input type="button"value="有个按钮" onclick="alert('我是按钮')"/><br/>
            <input type="reset" value="清除数据"/>
            <input type="submit" value="提交数据"/>
        </form>
    </body>
</html>
```

![29_12_2](https://github.com/geekavan/BiXiangdong/blob/master/29_12_2.png)

    1."file"为选择文件的属性值

    2."image"也是提交按钮，可以更改提交按钮的模样

    3."hidden"为隐藏组件，提交给服务器就可以，不需要用户看到

    4."button"为按钮组件，按钮引发事件，其中alert()为弹出窗口的意思

# 29_13HTML表单组件_select_textarea

```html
<html>
    <head>
        <meta charset="utf-8" />
    </head>
    <body>
        <form>
            输入姓名:<input type="text" name="user" value=""/><br/>
            输入密码:<input type="password" name="psw" value=""/><br/>
            选择性别:<input type="radio" name="sex" value="m"/>男
                    <input type="radio" name="sex" value="f" checked="checked"/>女<br/>
            选择技术:<input type="checkbox" name="tk" value="JAVA"/>JAVA
                     <input type="checkbox" name="tk" value="HTML"/>HTML
                     <input type="checkbox" name="tk" value="CSS"/>CSS<br/>
            选择文件:<input type="file" name ="file"/><br/>
            一个图片:<input type="image" height=25 width=40 src="1.jpg"/><br/>
            隐藏组件:<input type="hidden" name="hi" value="hi"/><br/>
            一个按钮:<input type="button"value="有个按钮" onclick="alert('我是按钮')"/><br/>
            <select name="country">
                <option value="null">--请选择国籍--</option>
                <option value="cn">中国</option>
                <option value="usa">美国</option>
                <option value="en">英国</option>
            </select><br/>
            <textarea name="text"></textarea><br/>
            <input type="reset" value="清除数据"/>
            <input type="submit" value="提交数据"/>
        </form>
    </body>
</html>
```

![29_13](https://github.com/geekavan/BiXiangdong/blob/master/29_13.png)

    1.<select></select>为下拉选项标签，为了能够提交给服务端，也需要加上name属性，<option></option>为选项标签

    2.<textarea></textarea>为文本框标签

# 29_14HTML表单格式化

所谓的表单格式化可以认为是表单表格化，很简单

```html
<html>
    <head>
        <meta charset="utf-8"/>
        <title>表单格式化</title>
    </head>
    <body>
        <form>
            <table border=1 bordercolor="#000000" cellpadding=5 cellspacing=1 width=400>
                <th  colspan=2>注册表单</th>
                <tr>
                    <td>用户姓名：</td>
                    <td>
                        <input type="text" name="user">
                    </td>
                </tr>
                <tr>
                    <td>设置密码：</td>
                    <td>
                        <input type="password" name="psw">
                    </td>
                </tr>
                <tr>
                    <td>确认密码：</td>
                    <td>
                        <input type="password" name="repsw">
                    </td>
                </tr>
                <tr>
                    <td>请选择性别：</td>
                    <td>
                        <input type="radio" name="sex" value="nan">男
                        <input type="radio" name="sex" value="nv">女
                    </td>
                </tr>
                <tr>
                    <td>请选择技术：</td>
                    <td>
                        <input type="checkbox" name="tech" value="java"/>JAVA
                        <input type="checkbox" name="tech" value="HTML"/>HTML
                        <input type="checkbox" name="tech" value="CSS"/>CSS
                    </td>
                </tr>
                 <tr>
                    <td>请选择国籍：</td>
                    <td>
                        <select name="country">
                            <option value="ch">--请选择国籍--</option>
                            <option value="ch">中国</option>
                            <option value="en">英国</option>
                            <option value="usa">美国</option>
                        </select>
                    </td>
                </tr>
                <th colspan=2>
                    <input type="reset" name="清除数据"/>
                    <input type="submit" name="提交数据"/>
                </th>
            </table>
        </form>
    </body>
</html>
```

![29_14](https://github.com/geekavan/BiXiangdong/blob/master/29_14.png)

# 29_15_16HTML_GET和POST区别

表单标签可以直接指定将表单数据发送到的地址

```html
<html>
    <head>
        <meta charset="utf-8"/>
        <title>表单格式化</title>
    </head>
    <body>
        <form action="http://192.168.1.106:8080" method="get">
            <table border=1 bordercolor="#000000" cellpadding=5 cellspacing=1 width=400>
                <th  colspan=2>注册表单</th>
                <tr>
                    <td>用户姓名：</td>
                    <td>
                        <input type="text" name="user">
                    </td>
                </tr>
                <tr>
                    <td>设置密码：</td>
                    <td>
                        <input type="password" name="psw">
                    </td>
                </tr>
                <tr>
                    <td>确认密码：</td>
                    <td>
                        <input type="password" name="repsw">
                    </td>
                </tr>
                <tr>
                    <td>请选择性别：</td>
                    <td>
                        <input type="radio" name="sex" value="nan">男
                        <input type="radio" name="sex" value="nv">女
                    </td>
                </tr>
                <tr>
                    <td>请选择技术：</td>
                    <td>
                        <input type="checkbox" name="tech" value="java"/>JAVA
                        <input type="checkbox" name="tech" value="HTML"/>HTML
                        <input type="checkbox" name="tech" value="CSS"/>CSS
                    </td>
                </tr>
                 <tr>
                    <td>请选择国籍：</td>
                    <td>
                        <select name="country">
                            <option value="ch">--请选择国籍--</option>
                            <option value="ch">中国</option>
                            <option value="en">英国</option>
                            <option value="usa">美国</option>
                        </select>
                    </td>
                </tr>
                <th colspan=2>
                    <input type="reset" name="清除数据"/>
                    <input type="submit" name="提交数据"/>
                </th>
            </table>
        </form>
    </body>
</html>
```

其中

    1.action为将表单数据发送到的地址

    2.method的发送方式，有get和post方式后文会比较两者之间的区别

我们自己制作一个服务端来接收这些数据

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

class Demo29_15_16 {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(9090);
        Socket s = ss.accept();
        System.out.println(s.getInetAddress().getHostAddress());
        InputStream in = s.getInputStream();
        byte[] buf = new byte[1024];
        int len = in.read(buf);
        System.out.println(new String(buf,0,len));

        PrintWriter out = new PrintWriter(s.getOutputStream(),true);
        out.println("<html><meta charset='GBK'><body><font color='green' size='7'>注册成功</font></body></html>");

        s.close();
        ss.close();
    }
}
```

其中:

    1.浏览器端总是收不到服务器端发送的注册成功字样，经过实验发现可能是浏览器的原因，又下载了一个qq浏览器，可见到实验效果

### get方式

get方式的url为

    http://192.168.1.106:9090/?user=abc&psw=123&repsw=123&sex=nan&tech=java&tech=HTML&country=ch&%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE=%E6%8F%90%E4%BA%A4

请求消息为

    GET /?user=abc&psw=123&repsw=123&sex=nan&tech=java&tech=HTML&country=ch&%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE=%E6%8F%90%E4%BA%A4 HTTP/1.1
    Accept: text/html, application/xhtml+xml, image/jxr, */*
    Accept-Language: zh-CN
    Accept-Encoding: gzip, deflate
    Host: 192.168.1.106:9090
    Connection: Keep-Alive
    User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko Core/1.70.3742.400 QQBrowser/10.5.3864.400



### post方式

post方式的url为

    http://192.168.1.106:9090/

请求消息为

    POST / HTTP/1.1
    Accept: text/html, application/xhtml+xml, image/jxr, */*
    Content-Type: application/x-www-form-urlencoded
    Accept-Language: zh-CN
    Accept-Encoding: gzip, deflate
    Host: 192.168.1.106:9090
    Content-Length: 121
    Connection: Keep-Alive
    Cache-Control: no-cache
    User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko Core/1.70.3742.400 QQBrowser/10.5.3864.400

    user=abc&psw=123&repsw=123&sex=nan&tech=java&tech=HTML&country=ch&%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE=%E6%8F%90%E4%BA%A4

两者区别:

    1.get方式提交之后，表单信息会在url中体现，信息不安全;post方式提交之后，表单信息不会在url中体现，信息安全

    2.get方式提交之后，表单信息体现在请求行中；post方式提交之后，表单信息体现在请求体中

    3.get方式适合小数据量的表单信息提交，因为url数据位数有限；post方式适合大数据量的表单信息提交

    4.post方式在提交到tomcat服务器中后，可以使用服务器端的一个对象request的setCharacterEncoding方法对数据进行指定解码，该方法只解析请求体中的数据

与服务器交互的三种方式

    1.url方式get

    2.超链接方式get

    3.表单方式get/post

# 29_17HTML服务器端和客户端的校验问题

接上节，如果我们直接在浏览器中输入http://192.168.1.106:9090/?user=abc&psw=123&repsw=123&sex=yao&tech=java&tech=HTML&country=ch&%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE=%E6%8F%90%E4%BA%A4

注意我们在sex这里动了手脚，服务器能直接对客户端发送来的数据进行存储吗？显然需要校验

再说客户端，如果我们填写了一个很大的表单，但是我们其中的身份证号填写错了，等到信息发送给服务端，服务端校验完发现有错误再发回信息提示你修改，这就需要花费很长时间，很影响用户体验，所以再客户端进行校验是有好处的

# 29_18HTML常见的其他标签

    1.<meta/>网页信息描述标签

    2.<b></b>加粗

    3.<i></i>斜体

    4.<u/></u>下划线

这里并不对老师所讲的其他标签进行全部记录，用到什么查什么就可以了

# 29_19HTML标签的分类

    1.<div></div>div区域标签，定义好区域，由其他语言对区域内的数据进行操作

    2.<span></span>sapn区域标签

    3.<p></p>段落标签

    4.标签分为两大类

        块标签:标签后边有换行div p dl ol ul title table等
        行标签:标签后边无换行span img a font input select等

# 30

# 30_01_CSS概述_和HTML结合的方式一二

CSS是层叠样式表(CascadingStyleSheets)，实现了演示内容和显示样式的分离，降低了耦合性，增强了扩展性，博主感觉HTML像是毛坯房，CSS是装修房

### CSS与HTML结合的方式一

CSS和HTML结合的方式一，在标签后面设置style属性，例子中设置了背景颜色与字体颜色

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
</head>
	
<body>
<div style="background-color:#D80C10;color:#F1E20E">这是一个div区域</div>
<div style="background-color:#AFA90B;color:#1E0FDC">这是一个div区域</div>
</body>
</html>
```

### CSS和HTML结合的方式二

方式一有一个明显的问题，比如你有很多个需要设置背景与字体颜色的div区域(或其他区域)，这些个区域大部分都是相同的设置，如果像方式一一样每一个区域都单独设置style属性就比较麻烦，代码的复用性就不强，于是便有了方式二

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style type="text/css">
	div{
	background-color: #000000;
		color:#F1E20E;
	}
	</style>
</head>
	
<body>
	<div >这是一个div区域</div>
<div style="background-color:#D80C10;color:#F1E20E">这是一个div区域</div>

</body>
</html>

```

方式二中:

    1.在<head></head>中加入了<style></style>标签，并在其中写css语句

    2.为了指明<style></style>中的文本是css语句，让解析器调用css的语法来解析，在这个标签的type属性上填写了"text/css"属性值

    3.注意css语句中为了指明background-color: #000000;color:#F1E20E;是div区域的样式，用div{}将其括起来

    4.注意其中div两边没有尖括号，带有尖括号就识别不了该句的意思了

    5.注意background-color: #000000;color:#F1E20E;没有引号

    6.html与css好不严谨，很多地方写错了，不报错就是显示不出预计的效果

    7.例子中上边对div进行了样式的设定，而下边第二个div也进行了同个样式的设定，那么以哪个为主呢？一般以最近的为主，以后边的为主

# 30_02CSS和HTML结合的方式三四

### CSS和HTML结合的方式三

    如果我们有很多个网页需要进行类似的设置，那么我们需要在所有网页html文件的<head></head>中加入<style></style>中的css语句吗？方式三给出了一个跟好的解决方式，即将<style></style>中的css语句封装为一个文件，要用到这个文件的网页调用它就可以了

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style type="text/css">
@import url(div.css);
	</style>
</head>
	
<body>
	<div >这是一个div区域</div>
<div style="background-color:#D80C10;color:#F1E20E">这是一个div区域</div>

</body>
</html>
```

其中div.css文件为

```css
@charset "utf-8";
/* CSS Document */
	div{
	background-color: #000000;
		color:#ffffff;
	}
```

### CSS和HTML结合的方式四

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
	<link rel="stylesheet" href="div.css" type="text/css"/>
<!--
<style type="text/css">
@import url(div.css);
	</style>
-->
</head>
	
<body>
	<div >这是一个div区域</div>
<div style="background-color:#D80C10;color:#F1E20E">这是一个div区域</div>

</body>
</html>
```

    1.该方式中使用<link/>标签，rel属性标明link的资源与本网页是什么关系(relationship),href属性指明关联的资源地址，type标明资源要用什么来解析

    2.方式四与方式三达到的网页效果也是相同的


# 30_03CSS基本选择器_优先级

CSS语言可以定义在HTML的标签中，那个标签就可以称为选择器，选择器有三类

1.HTML标签选择器

2.class选择器

3.id选择器

HTML选择器不再演示，这里演示class选择器与id选择器

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	div.haha{
/*		蓝底白字*/
		background-color:#0420F9;
		color:#FCFCFC;
	}
	div{
/*		红底黄字*/
	background-color:#EF0E12;
		color:#F8D907;
	}

	div#xixi{
/*		紫底绿字*/
		background-color:#D90BED;
		color:#08FB42;
	}
	.oo{
/*		黄底红字*/
		background-color:#F4DC02;
		color:#FB080F;
	}
	</style>
	

</head>
	
<body>
<div >div区域1 红底黄字 div定义</div>
	
<div class="haha">div区域2 蓝底白字 class="haha" div.haha定义</div>
<div class="haha">div区域3 蓝底白字 class="haha" div.haha定义</div>
	
<div id="xixi">div区域4 紫底绿字 id="xixi" div#xixi定义</div>
	
<div class="oo">div区域 黄底红字 class="oo" .oo定义</div>
<p class="oo">p区域 黄底红字 class="oo" .oo定义</p>
		

</body>
</html>
```

![30_03](https://github.com/geekavan/BiXiangdong/blob/master/30_03.png)

其中:

    1.html标签中的class可以将html标签分类，从而css语句可以针对指定的类进行操作，如果class为某一个标签下某一个类，如div下haha类，那么可以通过div.haha{}对其进行样式的设定，如果同一class涉及了多个标签，如div下有haha类，p下也有haha类，可以通过.haha{}对他们进行样式的设定

    2.id与class的用法一致，只不过.符号换为了#符号，而且id值与js语言的东西挂钩，所以要求id值不能够重复，需要具有唯一性，如下面语句就是不建议的，不要写，要换为class

        <div id="y">div区域1<div>
        <div id="y">div区域2<div>

# 30_04关联选择器与组合选择器

### 关联选择器

所谓的关联选择器就是"串联"，你要选择那一段数据进行操作啊？我要选择div标签中的b标签中的i标签中的数据进行操作就为

    div b i{}

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	div b i{
		background-color: #F3CC04;
		color: #FB001F;
	}
	</style>
	

</head>
	
<body>
<div >div区域1 <b>红底<i>黄字</i></b> </div>	
<div >div区域2 <b>蓝底</b>白字 </div>	
<div >div区域 黄底红字 </div>
	
<p >p区域</p>
		
</body>
</html>
```

![30_04](https://github.com/geekavan/BiXiangdong/blob/master/30_04.png)

### 组合选择器

所谓的组合选择器就是"并联"，这里不再讲解，注意"串联"之间用空格，"并联"之间用逗号

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	div b,div b i,p{
		background-color: #F3CC04;
		color: #FB001F;
	}
	</style>
	

</head>
	
<body>
<div >div区域1 <b>红底<i>黄字</i></b> </div>	
<div >div区域2 <b>蓝底</b>白字 </div>	
<div >div区域 黄底红字 </div>
	
<p >p区域</p>
		
</body>
</html>
```

![30_04_2](https://github.com/geekavan/BiXiangdong/blob/master/30_04_2.png)

# 30_05伪元素选择器_1

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	a:link{
		background-color: #F40206;
		color:#F5F400;
		text-decoration: none;
		font-size:16px;
	}
	a:visited{
		background-color: #0086F4;
		color:#000000;
		font-size:56px;
	}
	a:hover{
		background-color: #011DF4;
		color:#000000;
		font-size:32px;
	}
	a:active{
		background-color: #F400E3;
		color:#F40206;
		font-size:48px;
	}
	</style>
	

</head>
	
<body>
<a href="http://www.baidu.com" target="_blank">这是百度链接</a>
		
</body>
</html>
```

1.所谓伪元素选择器就是非元素的选择器，作用的不再是一个元素，而是作用在动作上，比如例子中作用在了链接的link,visited,hover,active上，其中link是没碰链接时候，链接的状态，hover是光标移动到链接上，链接的状态，active是点击了链接但是还没松手时链接的状态，visited是访问完链接，链接的状态

2.博主实验过程中，visited并没有出现效果，可能是因为浏览器的原因，该qq浏览器不支持该语句

# 30_06伪元素选择器_2

还有其他的伪元素选择器first-letter与first-line等

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	p:first-letter{
		font-size:36px;
	}
	div.haha:first-line{
		
		font-size:48px;
	}
	</style>
</head>
	
<body>
<p>这是p区域</p>
<div class="haha">这是div区域</div>	
<div >这也是div区域</div>	
</body>
</html>
```

![30_06](https://github.com/geekavan/BiXiangdong/blob/master/30_06.png)

毕老师还介绍了一个focus选择器，一般在input中使用，一旦我们选中了某个input区域，该区域就会出现focus中的效果，语句类似为

    input:focus{
        background-color:#ffffff;
    }
    
# 30_07CSS样式的结合应用

### ul

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	ul{
		list-style-type:upper-alpha;
/*		list-style-image: url(01a01.jpg);*/将选项前面的图标换为图片
	}
	</style>
</head>
	
<body>
<ul>
	<li>项目列表1</li>
	<li>项目列表2</li>
	<li>项目列表3</li>
	<li>项目列表4</li>
	</ul>	
</body>
</html>
```

![30_07](https://github.com/geekavan/BiXiangdong/blob/master/30_07.png)

### table

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	table{
		border-bottom: #030000 double 3px;
		border-left: #11F807 solid 2px;
		border-right: #0328FD dashed 3px;
		border-top: #D3F804 groove 5px;
		width: 500px;
	}
	table td{
		border:#000000 solid 2px;
		padding: 20px;
	}
	</style>
</head>
	
<body>
<table>
	<tr>
		<td>姓名</td>
		<td>张三</td>
	</tr>
	<tr>
		<td>年龄</td>
		<td>29</td>
	</tr>
	</table>
</body>
</html>
```

![30_07_2](https://github.com/geekavan/BiXiangdong/blob/master/30_07_2.png)

老师还讲解了div，input，这里不再介绍，因为也是和ul和table相似的操作

# 30_08CSS的盒子模型

以前制作网页是以表格的形式，现在制作网页使用的是盒子模型，即div+CSS方式，盒子的属性有

    1.盒子有四条边
        边border
        上边border-top
        右边border-right
        下边border-bottom
        左边border-left

        可以设置颜色，边的类型，边宽，代码示例
        <style>
            div#xixi{
                border-right:#00ff00 solid 3px;
            }
            </style>

        表示body中div中的id为xixi的"盒子"(以前称为区域或div区域)，的右边框为#00ff00色，为实线，占3个像素宽

    2.盒子中数据与盒子的宽度
        宽度padding
        数据距盒子上边框宽度padding-top
        数据距盒子右边框宽度padding-right
        数据距盒子下边框宽度padding-bottom
        数据距盒子左边框宽度padding-left

    3.盒子距盒子的四周的宽度
        宽度margin
        盒子距盒子的上边的宽度margin-top
        盒子距盒子的右边的宽度margin-right
        盒子距盒子的下边的宽度margin-bottom
        盒子距盒子的左边的宽度margin-left

    4.注意即使margin调整到了0px，最上边的div也不会紧靠着浏览器上边，因为最上边的div中的margin是div到body之间的距离，而body到浏览器上边还有距离，若想紧贴浏览器上边需要将body的margin也设置为0px

        <style>
            body{
                margin:0px;
            }
            </style>
        

# 30_09CSS的布局_漂浮

漂浮属性为float，取值可为

    left	元素向左浮动。
    right	元素向右浮动。
    none	默认值。元素不浮动，并会显示在其在文本中出现的位置。
    inherit	规定应该从父元素继承 float 属性的值。

由于毕老师的效果不知道为什么显示不出来预想效果，这里选择菜鸟教程中的例子

```html
<html>
<head>
<meta charset="utf-8"> 
<title>此例子来自菜鸟教程</title>
<style>
img 
{
	float:right;
	width:120px;
	height:150px;
}
	p#img{
	width:500px;
	height:1000px;
	}
</style>
</head>

<body>
<p>在下面的段落中，我们添加了一个 <b>float:right</b> 的图片。导致图片将会浮动在段落的右边。</p>
<p id="img">
<img src="01a01.jpg"/>
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
这是一些文本。这是一些文本。这是一些文本。
</p>
</body>

</html>
```

![30_09](https://github.com/geekavan/BiXiangdong/blob/master/30_09.png)

# 30_10CSS的布局_定位

### absolute

定位的属性为position，常见属性值为

    1.static默认的属性值，正常文件流位置

    2.absolute绝对值定位，相对于非static的父节点的位置，出文件流

    3.relative相对值定位，相对于正常位置(static位置)的位置，不出文件流

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	div{		
		height:100px;
		width:100px;
	}
	#div_0{
		background-color: #BBBBBB;
		height:500px;
		width:500px;
		position:absolute;
		top:0px;
		left:0px;
	}
	#div_1{
		background-color: #F70206;
		position:absolute;
		top:70px;
		left:70px;
	}
	#div_2{
		background-color: #1BF702;
	}
	#div_3{
		background-color: #020EF7;
	}
	</style>
</head>
	
<body>
	<div id="div_0">
	<div id="div_1">这是区域11</div>
	<div id="div_2">这是区域22</div>
	<div id="div_3">这是区域33</div>
	</div>
</body>
</html>
```

![30_10](https://github.com/geekavan/BiXiangdong/blob/master/30_10.png)

其中

    1.我们看到我们将div_0的position设置为absolute，并且将它的top与left都设置为了0px，而div_0(即灰色区域)距离浏览器边框为0，为不是距离body为0(body区域与浏览器边框之间有距离)，这是虽然body是div_0的父节点，但是body区域的position为默认值static，而absolute是相对于非static的父节点的位置

    2.我们将div_1的position设置为了absolute，而它的top与left都设置为了70px，它确实距离div_0上边左边都是70px，注意它是距离它的父节点div_0为70px，因为div_0的position值不不是默认的static

    3.我们注意到div_1脱离了文件流，这里是指div_1的原来的位置(static的位置)已经被div_2取代了

### relative

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	div{		
		height:100px;
		width:100px;
	}
	#div_0{
		background-color: #BBBBBB;
		height:500px;
		width:500px;
		position:absolute;
		top:100px;
		left:100px;
	}
	#div_1{
		background-color: #F70206;
		position:relative;
		top:70px;
		left:70px;
	}
	#div_2{
		background-color: #1BF702;
	}
	#div_3{
		background-color: #020EF7;
	}
	</style>
</head>
	
<body>
	<div id="div_0">
	<div id="div_1">这是区域11</div>
	<div id="div_2">这是区域22</div>
	<div id="div_3">这是区域33</div>
	</div>
</body>
</html>
```

![30_10_2](https://github.com/geekavan/BiXiangdong/blob/master/30_10_2.png)

其中

    1.我们将div_1中position属性值改为relative，我们看到div_1并未出文件流，这里是指div_1原来的位置(static的位置)是空缺的，没有被div_2所占据

# 30_11CSS的布局_图文混排

这一节并没有介绍新的知识点，但是有一个编程思想需要注意一下，即在写html代码时，最好将代码封装为一个个的"小盒子"，这样就方便了CSS的操作

```html
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>

<style type="text/css">
	div{
		height:500px;
		width:300px;
	}
	#img{
		float:right;
		height:240px;
		width:180px;
	}
	#text{
		color: #FC9603;
	}
	</style>
</head>
	
<body>
	<div id="imgtext">
		<img id="img" src="01a01.jpg" alt="美女图片"/>
		<div id="text">这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本，这是美女图片的介绍文本
		</div>
	</div>
</body>
</html>
```

![30_11](https://github.com/geekavan/BiXiangdong/blob/master/30_11.png)


